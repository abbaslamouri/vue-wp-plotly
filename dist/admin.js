/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@vue/devtools-api/lib/esm/api/api.js":
/*!***********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/api/api.js ***!
  \***********************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/api/app.js":
/*!***********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/api/app.js ***!
  \***********************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/api/component.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/api/component.js ***!
  \*****************************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/api/context.js":
/*!***************************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/api/context.js ***!
  \***************************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/api/hooks.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/api/hooks.js ***!
  \*************************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/api/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/api/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ "./node_modules/@vue/devtools-api/lib/esm/api/api.js");
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_api__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _api__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _api__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app */ "./node_modules/@vue/devtools-api/lib/esm/api/app.js");
/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_app__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _app__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _app__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./component */ "./node_modules/@vue/devtools-api/lib/esm/api/component.js");
/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_component__WEBPACK_IMPORTED_MODULE_2__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _component__WEBPACK_IMPORTED_MODULE_2__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _component__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context */ "./node_modules/@vue/devtools-api/lib/esm/api/context.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_context__WEBPACK_IMPORTED_MODULE_3__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _context__WEBPACK_IMPORTED_MODULE_3__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _context__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hooks */ "./node_modules/@vue/devtools-api/lib/esm/api/hooks.js");
/* harmony import */ var _hooks__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_hooks__WEBPACK_IMPORTED_MODULE_4__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _hooks__WEBPACK_IMPORTED_MODULE_4__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _hooks__WEBPACK_IMPORTED_MODULE_4__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ "./node_modules/@vue/devtools-api/lib/esm/api/util.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_util__WEBPACK_IMPORTED_MODULE_5__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _util__WEBPACK_IMPORTED_MODULE_5__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _util__WEBPACK_IMPORTED_MODULE_5__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);








/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/api/util.js":
/*!************************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/api/util.js ***!
  \************************************************************/
/***/ (() => {



/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/const.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/const.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HOOK_SETUP": () => (/* binding */ HOOK_SETUP)
/* harmony export */ });
const HOOK_SETUP = 'devtools-plugin:setup';


/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/env.js":
/*!*******************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/env.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDevtoolsGlobalHook": () => (/* binding */ getDevtoolsGlobalHook),
/* harmony export */   "getTarget": () => (/* binding */ getTarget)
/* harmony export */ });
function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
    // @ts-ignore
    return typeof navigator !== 'undefined'
        ? window
        : typeof __webpack_require__.g !== 'undefined'
            ? __webpack_require__.g
            : {};
}


/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setupDevtoolsPlugin": () => (/* binding */ setupDevtoolsPlugin)
/* harmony export */ });
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env */ "./node_modules/@vue/devtools-api/lib/esm/env.js");
/* harmony import */ var _const__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./const */ "./node_modules/@vue/devtools-api/lib/esm/const.js");
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ "./node_modules/@vue/devtools-api/lib/esm/api/index.js");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _api__WEBPACK_IMPORTED_MODULE_0__) if(["default","setupDevtoolsPlugin"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _api__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);



function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const hook = (0,_env__WEBPACK_IMPORTED_MODULE_1__.getDevtoolsGlobalHook)();
    if (hook) {
        hook.emit(_const__WEBPACK_IMPORTED_MODULE_2__.HOOK_SETUP, pluginDescriptor, setupFn);
    }
    else {
        const target = (0,_env__WEBPACK_IMPORTED_MODULE_1__.getTarget)();
        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
        list.push({
            pluginDescriptor,
            setupFn
        });
    }
}


/***/ }),

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ITERATE_KEY": () => (/* binding */ ITERATE_KEY),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "customRef": () => (/* binding */ customRef),
/* harmony export */   "effect": () => (/* binding */ effect),
/* harmony export */   "enableTracking": () => (/* binding */ enableTracking),
/* harmony export */   "isProxy": () => (/* binding */ isProxy),
/* harmony export */   "isReactive": () => (/* binding */ isReactive),
/* harmony export */   "isReadonly": () => (/* binding */ isReadonly),
/* harmony export */   "isRef": () => (/* binding */ isRef),
/* harmony export */   "markRaw": () => (/* binding */ markRaw),
/* harmony export */   "pauseTracking": () => (/* binding */ pauseTracking),
/* harmony export */   "proxyRefs": () => (/* binding */ proxyRefs),
/* harmony export */   "reactive": () => (/* binding */ reactive),
/* harmony export */   "readonly": () => (/* binding */ readonly),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "resetTracking": () => (/* binding */ resetTracking),
/* harmony export */   "shallowReactive": () => (/* binding */ shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* binding */ shallowReadonly),
/* harmony export */   "shallowRef": () => (/* binding */ shallowRef),
/* harmony export */   "stop": () => (/* binding */ stop),
/* harmony export */   "toRaw": () => (/* binding */ toRaw),
/* harmony export */   "toRef": () => (/* binding */ toRef),
/* harmony export */   "toRefs": () => (/* binding */ toRefs),
/* harmony export */   "track": () => (/* binding */ track),
/* harmony export */   "trigger": () => (/* binding */ trigger),
/* harmony export */   "triggerRef": () => (/* binding */ triggerRef),
/* harmony export */   "unref": () => (/* binding */ unref)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");


const targetMap = new WeakMap();
const effectStack = [];
let activeEffect;
const ITERATE_KEY = Symbol(( true) ? 'iterate' : 0);
const MAP_KEY_ITERATE_KEY = Symbol(( true) ? 'Map key iterate' : 0);
function isEffect(fn) {
    return fn && fn._isEffect === true;
}
function effect(fn, options = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ) {
    if (isEffect(fn)) {
        fn = fn.raw;
    }
    const effect = createReactiveEffect(fn, options);
    if (!options.lazy) {
        effect();
    }
    return effect;
}
function stop(effect) {
    if (effect.active) {
        cleanup(effect);
        if (effect.options.onStop) {
            effect.options.onStop();
        }
        effect.active = false;
    }
}
let uid = 0;
function createReactiveEffect(fn, options) {
    const effect = function reactiveEffect() {
        if (!effect.active) {
            return fn();
        }
        if (!effectStack.includes(effect)) {
            cleanup(effect);
            try {
                enableTracking();
                effectStack.push(effect);
                activeEffect = effect;
                return fn();
            }
            finally {
                effectStack.pop();
                resetTracking();
                activeEffect = effectStack[effectStack.length - 1];
            }
        }
    };
    effect.id = uid++;
    effect.allowRecurse = !!options.allowRecurse;
    effect._isEffect = true;
    effect.active = true;
    effect.raw = fn;
    effect.deps = [];
    effect.options = options;
    return effect;
}
function cleanup(effect) {
    const { deps } = effect;
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].delete(effect);
        }
        deps.length = 0;
    }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === undefined ? true : last;
}
function track(target, type, key) {
    if (!shouldTrack || activeEffect === undefined) {
        return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
        targetMap.set(target, (depsMap = new Map()));
    }
    let dep = depsMap.get(key);
    if (!dep) {
        depsMap.set(key, (dep = new Set()));
    }
    if (!dep.has(activeEffect)) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (( true) && activeEffect.options.onTrack) {
            activeEffect.options.onTrack({
                effect: activeEffect,
                target,
                type,
                key
            });
        }
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
        // never been tracked
        return;
    }
    const effects = new Set();
    const add = (effectsToAdd) => {
        if (effectsToAdd) {
            effectsToAdd.forEach(effect => {
                if (effect !== activeEffect || effect.allowRecurse) {
                    effects.add(effect);
                }
            });
        }
    };
    if (type === "clear" /* CLEAR */) {
        // collection being cleared
        // trigger all effects for target
        depsMap.forEach(add);
    }
    else if (key === 'length' && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
        depsMap.forEach((dep, key) => {
            if (key === 'length' || key >= newValue) {
                add(dep);
            }
        });
    }
    else {
        // schedule runs for SET | ADD | DELETE
        if (key !== void 0) {
            add(depsMap.get(key));
        }
        // also run for iteration key on ADD | DELETE | Map.SET
        switch (type) {
            case "add" /* ADD */:
                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
                    add(depsMap.get(ITERATE_KEY));
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                        add(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)) {
                    // new index added to array -> length changes
                    add(depsMap.get('length'));
                }
                break;
            case "delete" /* DELETE */:
                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
                    add(depsMap.get(ITERATE_KEY));
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                        add(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                break;
            case "set" /* SET */:
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
                    add(depsMap.get(ITERATE_KEY));
                }
                break;
        }
    }
    const run = (effect) => {
        if (( true) && effect.options.onTrigger) {
            effect.options.onTrigger({
                effect,
                target,
                key,
                type,
                newValue,
                oldValue,
                oldTarget
            });
        }
        if (effect.options.scheduler) {
            effect.options.scheduler(effect);
        }
        else {
            effect();
        }
    };
    effects.forEach(run);
}

const isNonTrackableKeys = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)
    .map(key => Symbol[key])
    .filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol));
const get = /*#__PURE__*/ createGetter();
const shallowGet = /*#__PURE__*/ createGetter(false, true);
const readonlyGet = /*#__PURE__*/ createGetter(true);
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();
function createArrayInstrumentations() {
    const instrumentations = {};
    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
        instrumentations[key] = function (...args) {
            const arr = toRaw(this);
            for (let i = 0, l = this.length; i < l; i++) {
                track(arr, "get" /* GET */, i + '');
            }
            // we run the method using the original args first (which may be reactive)
            const res = arr[key](...args);
            if (res === -1 || res === false) {
                // if that didn't work, run it again using raw values.
                return arr[key](...args.map(toRaw));
            }
            else {
                return res;
            }
        };
    });
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
        instrumentations[key] = function (...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
        };
    });
    return instrumentations;
}
function createGetter(isReadonly = false, shallow = false) {
    return function get(target, key, receiver) {
        if (key === "__v_isReactive" /* IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_raw" /* RAW */ &&
            receiver ===
                (isReadonly
                    ? shallow
                        ? shallowReadonlyMap
                        : readonlyMap
                    : shallow
                        ? shallowReactiveMap
                        : reactiveMap).get(target)) {
            return target;
        }
        const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);
        if (!isReadonly && targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
        }
        const res = Reflect.get(target, key, receiver);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
        }
        if (!isReadonly) {
            track(target, "get" /* GET */, key);
        }
        if (shallow) {
            return res;
        }
        if (isRef(res)) {
            // ref unwrapping - does not apply for Array + integer key.
            const shouldUnwrap = !targetIsArray || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key);
            return shouldUnwrap ? res.value : res;
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
            // Convert returned value into a proxy as well. we do the isObject check
            // here to avoid invalid value warning. Also need to lazy access readonly
            // and reactive here to avoid circular dependency.
            return isReadonly ? readonly(res) : reactive(res);
        }
        return res;
    };
}
const set = /*#__PURE__*/ createSetter();
const shallowSet = /*#__PURE__*/ createSetter(true);
function createSetter(shallow = false) {
    return function set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!shallow) {
            value = toRaw(value);
            oldValue = toRaw(oldValue);
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)
            ? Number(key) < target.length
            : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
        const result = Reflect.set(target, key, value, receiver);
        // don't trigger if target is something up in the prototype chain of original
        if (target === toRaw(receiver)) {
            if (!hadKey) {
                trigger(target, "add" /* ADD */, key, value);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
                trigger(target, "set" /* SET */, key, value, oldValue);
            }
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function has(target, key) {
    const result = Reflect.has(target, key);
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {
        track(target, "has" /* HAS */, key);
    }
    return result;
}
function ownKeys(target) {
    track(target, "iterate" /* ITERATE */, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? 'length' : ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get,
    set,
    deleteProperty,
    has,
    ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
        if ((true)) {
            console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
    },
    deleteProperty(target, key) {
        if ((true)) {
            console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
    }
};
const shallowReactiveHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
});
// Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.
const shallowReadonlyHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, readonlyHandlers, {
    get: shallowReadonlyGet
});

const toReactive = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;
const toReadonly = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly = false, isShallow = false) {
    // #1772: readonly(reactive(Map)) should return readonly + reactive version
    // of the value
    target = target["__v_raw" /* RAW */];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
        !isReadonly && track(rawTarget, "get" /* GET */, key);
    }
    !isReadonly && track(rawTarget, "get" /* GET */, rawKey);
    const { has } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
    }
    else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
    }
    else if (target !== rawTarget) {
        // #3602 readonly(reactive(Map))
        // ensure that the nested reactive `Map` can do tracking for itself
        target.get(key);
    }
}
function has$1(key, isReadonly = false) {
    const target = this["__v_raw" /* RAW */];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
        !isReadonly && track(rawTarget, "has" /* HAS */, key);
    }
    !isReadonly && track(rawTarget, "has" /* HAS */, rawKey);
    return key === rawKey
        ? target.has(key)
        : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
    target = target["__v_raw" /* RAW */];
    !isReadonly && track(toRaw(target), "iterate" /* ITERATE */, ITERATE_KEY);
    return Reflect.get(target, 'size', target);
}
function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add" /* ADD */, value, value);
    }
    return this;
}
function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((true)) {
        checkIdentityKeys(target, has, key);
    }
    const oldValue = get.call(target, key);
    target.set(key, value);
    if (!hadKey) {
        trigger(target, "add" /* ADD */, key, value);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
        trigger(target, "set" /* SET */, key, value, oldValue);
    }
    return this;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((true)) {
        checkIdentityKeys(target, has, key);
    }
    const oldValue = get ? get.call(target, key) : undefined;
    // forward the operation before queueing reactions
    const result = target.delete(key);
    if (hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = ( true)
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)
            ? new Map(target)
            : new Set(target)
        : 0;
    // forward the operation before queueing reactions
    const result = target.clear();
    if (hadItems) {
        trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);
    }
    return result;
}
function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw" /* RAW */];
        const rawTarget = toRaw(target);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate" /* ITERATE */, ITERATE_KEY);
        return target.forEach((value, key) => {
            // important: make sure the callback is
            // 1. invoked with the reactive map as `this` and 3rd arg
            // 2. the value received should be a corresponding reactive/readonly.
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly, isShallow) {
    return function (...args) {
        const target = this["__v_raw" /* RAW */];
        const rawTarget = toRaw(target);
        const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);
        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);
        const isKeyOnly = method === 'keys' && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly &&
            track(rawTarget, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        // return a wrapped iterator which returns observed versions of the
        // values emitted from the real iterator
        return {
            // iterator protocol
            next() {
                const { value, done } = innerIterator.next();
                return done
                    ? { value, done }
                    : {
                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                        done
                    };
            },
            // iterable protocol
            [Symbol.iterator]() {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function (...args) {
        if ((true)) {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            console.warn(`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));
        }
        return type === "delete" /* DELETE */ ? false : this;
    };
}
function createInstrumentations() {
    const mutableInstrumentations = {
        get(key) {
            return get$1(this, key);
        },
        get size() {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
    };
    const shallowInstrumentations = {
        get(key) {
            return get$1(this, key, false, true);
        },
        get size() {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
    };
    const readonlyInstrumentations = {
        get(key) {
            return get$1(this, key, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* ADD */),
        set: createReadonlyMethod("set" /* SET */),
        delete: createReadonlyMethod("delete" /* DELETE */),
        clear: createReadonlyMethod("clear" /* CLEAR */),
        forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations = {
        get(key) {
            return get$1(this, key, true, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* ADD */),
        set: createReadonlyMethod("set" /* SET */),
        delete: createReadonlyMethod("delete" /* DELETE */),
        clear: createReadonlyMethod("clear" /* CLEAR */),
        forEach: createForEach(true, true)
    };
    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
    iteratorMethods.forEach(method => {
        mutableInstrumentations[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations[method] = createIterableMethod(method, true, false);
        shallowInstrumentations[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
    });
    return [
        mutableInstrumentations,
        readonlyInstrumentations,
        shallowInstrumentations,
        shallowReadonlyInstrumentations
    ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow
        ? isReadonly
            ? shallowReadonlyInstrumentations
            : shallowInstrumentations
        : isReadonly
            ? readonlyInstrumentations
            : mutableInstrumentations;
    return (target, key, receiver) => {
        if (key === "__v_isReactive" /* IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_raw" /* RAW */) {
            return target;
        }
        return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target
            ? instrumentations
            : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has.call(target, rawKey)) {
        const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);
        console.warn(`Reactive ${type} contains both the raw and reactive ` +
            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +
            `which can lead to inconsistencies. ` +
            `Avoid differentiating between the raw and reactive versions ` +
            `of an object and only use the reactive version if possible.`);
    }
}

const reactiveMap = new WeakMap();
const shallowReactiveMap = new WeakMap();
const readonlyMap = new WeakMap();
const shallowReadonlyMap = new WeakMap();
function targetTypeMap(rawType) {
    switch (rawType) {
        case 'Object':
        case 'Array':
            return 1 /* COMMON */;
        case 'Map':
        case 'Set':
        case 'WeakMap':
        case 'WeakSet':
            return 2 /* COLLECTION */;
        default:
            return 0 /* INVALID */;
    }
}
function getTargetType(value) {
    return value["__v_skip" /* SKIP */] || !Object.isExtensible(value)
        ? 0 /* INVALID */
        : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));
}
function reactive(target) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (target && target["__v_isReadonly" /* IS_READONLY */]) {
        return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
        if ((true)) {
            console.warn(`value cannot be made reactive: ${String(target)}`);
        }
        return target;
    }
    // target is already a Proxy, return it.
    // exception: calling readonly() on a reactive object
    if (target["__v_raw" /* RAW */] &&
        !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {
        return target;
    }
    // target already has corresponding Proxy
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
        return existingProxy;
    }
    // only a whitelist of value types can be observed.
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */) {
        return target;
    }
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) {
        return isReactive(value["__v_raw" /* RAW */]);
    }
    return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly" /* IS_READONLY */]);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    return ((observed && toRaw(observed["__v_raw" /* RAW */])) || observed);
}
function markRaw(value) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, "__v_skip" /* SKIP */, true);
    return value;
}

const convert = (val) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(val) ? reactive(val) : val;
function isRef(r) {
    return Boolean(r && r.__v_isRef === true);
}
function ref(value) {
    return createRef(value);
}
function shallowRef(value) {
    return createRef(value, true);
}
class RefImpl {
    constructor(value, _shallow = false) {
        this._shallow = _shallow;
        this.__v_isRef = true;
        this._rawValue = _shallow ? value : toRaw(value);
        this._value = _shallow ? value : convert(value);
    }
    get value() {
        track(toRaw(this), "get" /* GET */, 'value');
        return this._value;
    }
    set value(newVal) {
        newVal = this._shallow ? newVal : toRaw(newVal);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = this._shallow ? newVal : convert(newVal);
            trigger(toRaw(this), "set" /* SET */, 'value', newVal);
        }
    }
}
function createRef(rawValue, shallow = false) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    return new RefImpl(rawValue, shallow);
}
function triggerRef(ref) {
    trigger(toRaw(ref), "set" /* SET */, 'value', ( true) ? ref.value : 0);
}
function unref(ref) {
    return isRef(ref) ? ref.value : ref;
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        }
        else {
            return Reflect.set(target, key, value, receiver);
        }
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs)
        ? objectWithRefs
        : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory) {
        this.__v_isRef = true;
        const { get, set } = factory(() => track(this, "get" /* GET */, 'value'), () => trigger(this, "set" /* SET */, 'value'));
        this._get = get;
        this._set = set;
    }
    get value() {
        return this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (( true) && !isProxy(object)) {
        console.warn(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};
    for (const key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key) {
        this._object = _object;
        this._key = _key;
        this.__v_isRef = true;
    }
    get value() {
        return this._object[this._key];
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
}
function toRef(object, key) {
    return isRef(object[key])
        ? object[key]
        : new ObjectRefImpl(object, key);
}

class ComputedRefImpl {
    constructor(getter, _setter, isReadonly) {
        this._setter = _setter;
        this._dirty = true;
        this.__v_isRef = true;
        this.effect = effect(getter, {
            lazy: true,
            scheduler: () => {
                if (!this._dirty) {
                    this._dirty = true;
                    trigger(toRaw(this), "set" /* SET */, 'value');
                }
            }
        });
        this["__v_isReadonly" /* IS_READONLY */] = isReadonly;
    }
    get value() {
        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
        const self = toRaw(this);
        if (self._dirty) {
            self._value = this.effect();
            self._dirty = false;
        }
        track(self, "get" /* GET */, 'value');
        return self._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
}
function computed(getterOrOptions) {
    let getter;
    let setter;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions)) {
        getter = getterOrOptions;
        setter = ( true)
            ? () => {
                console.warn('Write operation failed: computed value is readonly');
            }
            : 0;
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    return new ComputedRefImpl(getter, setter, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions) || !getterOrOptions.set);
}




/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey),
/* harmony export */   "BaseTransition": () => (/* binding */ BaseTransition),
/* harmony export */   "Comment": () => (/* binding */ Comment$1),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "KeepAlive": () => (/* binding */ KeepAlive),
/* harmony export */   "Static": () => (/* binding */ Static),
/* harmony export */   "Suspense": () => (/* binding */ Suspense),
/* harmony export */   "Teleport": () => (/* binding */ Teleport),
/* harmony export */   "Text": () => (/* binding */ Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* binding */ callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* binding */ callWithErrorHandling),
/* harmony export */   "cloneVNode": () => (/* binding */ cloneVNode),
/* harmony export */   "compatUtils": () => (/* binding */ compatUtils),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "createBlock": () => (/* binding */ createBlock),
/* harmony export */   "createCommentVNode": () => (/* binding */ createCommentVNode),
/* harmony export */   "createHydrationRenderer": () => (/* binding */ createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* binding */ createRenderer),
/* harmony export */   "createSlots": () => (/* binding */ createSlots),
/* harmony export */   "createStaticVNode": () => (/* binding */ createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* binding */ createTextVNode),
/* harmony export */   "createVNode": () => (/* binding */ createVNode),
/* harmony export */   "defineAsyncComponent": () => (/* binding */ defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* binding */ defineComponent),
/* harmony export */   "defineEmit": () => (/* binding */ defineEmit),
/* harmony export */   "defineEmits": () => (/* binding */ defineEmits),
/* harmony export */   "defineExpose": () => (/* binding */ defineExpose),
/* harmony export */   "defineProps": () => (/* binding */ defineProps),
/* harmony export */   "devtools": () => (/* binding */ devtools),
/* harmony export */   "getCurrentInstance": () => (/* binding */ getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* binding */ getTransitionRawChildren),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "handleError": () => (/* binding */ handleError),
/* harmony export */   "initCustomFormatter": () => (/* binding */ initCustomFormatter),
/* harmony export */   "inject": () => (/* binding */ inject),
/* harmony export */   "isRuntimeOnly": () => (/* binding */ isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* binding */ isVNode),
/* harmony export */   "mergeDefaults": () => (/* binding */ mergeDefaults),
/* harmony export */   "mergeProps": () => (/* binding */ mergeProps),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "onActivated": () => (/* binding */ onActivated),
/* harmony export */   "onBeforeMount": () => (/* binding */ onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* binding */ onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* binding */ onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* binding */ onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* binding */ onErrorCaptured),
/* harmony export */   "onMounted": () => (/* binding */ onMounted),
/* harmony export */   "onRenderTracked": () => (/* binding */ onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* binding */ onRenderTriggered),
/* harmony export */   "onServerPrefetch": () => (/* binding */ onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* binding */ onUnmounted),
/* harmony export */   "onUpdated": () => (/* binding */ onUpdated),
/* harmony export */   "openBlock": () => (/* binding */ openBlock),
/* harmony export */   "popScopeId": () => (/* binding */ popScopeId),
/* harmony export */   "provide": () => (/* binding */ provide),
/* harmony export */   "pushScopeId": () => (/* binding */ pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* binding */ queuePostFlushCb),
/* harmony export */   "registerRuntimeCompiler": () => (/* binding */ registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* binding */ renderList),
/* harmony export */   "renderSlot": () => (/* binding */ renderSlot),
/* harmony export */   "resolveComponent": () => (/* binding */ resolveComponent),
/* harmony export */   "resolveDirective": () => (/* binding */ resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* binding */ resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* binding */ resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* binding */ resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* binding */ setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* binding */ setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* binding */ setTransitionHooks),
/* harmony export */   "ssrContextKey": () => (/* binding */ ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* binding */ ssrUtils),
/* harmony export */   "toHandlers": () => (/* binding */ toHandlers),
/* harmony export */   "transformVNodeArgs": () => (/* binding */ transformVNodeArgs),
/* harmony export */   "useAttrs": () => (/* binding */ useAttrs),
/* harmony export */   "useContext": () => (/* binding */ useContext),
/* harmony export */   "useSSRContext": () => (/* binding */ useSSRContext),
/* harmony export */   "useSlots": () => (/* binding */ useSlots),
/* harmony export */   "useTransitionState": () => (/* binding */ useTransitionState),
/* harmony export */   "version": () => (/* binding */ version),
/* harmony export */   "warn": () => (/* binding */ warn),
/* harmony export */   "watch": () => (/* binding */ watch),
/* harmony export */   "watchEffect": () => (/* binding */ watchEffect),
/* harmony export */   "withAsyncContext": () => (/* binding */ withAsyncContext),
/* harmony export */   "withCtx": () => (/* binding */ withCtx),
/* harmony export */   "withDefaults": () => (/* binding */ withDefaults),
/* harmony export */   "withDirectives": () => (/* binding */ withDirectives),
/* harmony export */   "withScopeId": () => (/* binding */ withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");





const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function warn(msg, ...args) {
    // avoid props formatting or warn handler tracking deps that might be mutated
    // during patch, leading to infinite recursion.
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [
            msg + args.join(''),
            instance && instance.proxy,
            trace
                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)
                .join('\n'),
            trace
        ]);
    }
    else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        /* istanbul ignore if */
        if (trace.length &&
            // avoid spamming console during tests
            !false) {
            warnArgs.push(`\n`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
    }
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
        return [];
    }
    // we can't just use the stack because it will be incomplete during updates
    // that did not start from the root. Re-construct the parent chain using
    // instance parent pointers.
    const normalizedStack = [];
    while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
            last.recurseCount++;
        }
        else {
            normalizedStack.push({
                vnode: currentVNode,
                recurseCount: 0
            });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
/* istanbul ignore next */
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
        logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props
        ? [open, ...formatProps(vnode.props), close]
        : [open + close];
}
/* istanbul ignore next */
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach(key => {
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
        res.push(` ...`);
    }
    return res;
}
/* istanbul ignore next */
function formatProp(key, value, raw) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
    }
    else if (typeof value === 'number' ||
        typeof value === 'boolean' ||
        value == null) {
        return raw ? value : [`${key}=${value}`];
    }
    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
        value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    }
    else {
        value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);
        return raw ? value : [`${key}=`, value];
    }
}

const ErrorTypeStrings = {
    ["sp" /* SERVER_PREFETCH */]: 'serverPrefetch hook',
    ["bc" /* BEFORE_CREATE */]: 'beforeCreate hook',
    ["c" /* CREATED */]: 'created hook',
    ["bm" /* BEFORE_MOUNT */]: 'beforeMount hook',
    ["m" /* MOUNTED */]: 'mounted hook',
    ["bu" /* BEFORE_UPDATE */]: 'beforeUpdate hook',
    ["u" /* UPDATED */]: 'updated',
    ["bum" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
    ["um" /* UNMOUNTED */]: 'unmounted hook',
    ["a" /* ACTIVATED */]: 'activated hook',
    ["da" /* DEACTIVATED */]: 'deactivated hook',
    ["ec" /* ERROR_CAPTURED */]: 'errorCaptured hook',
    ["rtc" /* RENDER_TRACKED */]: 'renderTracked hook',
    ["rtg" /* RENDER_TRIGGERED */]: 'renderTriggered hook',
    [0 /* SETUP_FUNCTION */]: 'setup function',
    [1 /* RENDER_FUNCTION */]: 'render function',
    [2 /* WATCH_GETTER */]: 'watcher getter',
    [3 /* WATCH_CALLBACK */]: 'watcher callback',
    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
    [7 /* VNODE_HOOK */]: 'vnode hook',
    [8 /* DIRECTIVE_HOOK */]: 'directive hook',
    [9 /* TRANSITION_HOOK */]: 'transition hook',
    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
    [12 /* FUNCTION_REF */]: 'ref function',
    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    }
    catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {
            res.catch(err => {
                handleError(err, instance, type);
            });
        }
        return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        // the exposed instance is the render proxy to keep it consistent with 2.x
        const exposedInstance = instance.proxy;
        // in production the hook receives only the error code
        const errorInfo = ( true) ? ErrorTypeStrings[type] : 0;
        while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
                for (let i = 0; i < errorCapturedHooks.length; i++) {
                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                        return;
                    }
                }
            }
            cur = cur.parent;
        }
        // app-level handling
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    if ((true)) {
        const info = ErrorTypeStrings[type];
        if (contextVNode) {
            pushWarningContext(contextVNode);
        }
        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) {
            popWarningContext();
        }
        // crash in dev by default so it's more noticeable
        if (throwInDev) {
            throw err;
        }
        else {
            console.error(err);
        }
    }
    else {}
}

let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
// #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.
function findInsertionIndex(job) {
    // the start index should be `flushIndex + 1`
    let start = flushIndex + 1;
    let end = queue.length;
    const jobId = getId(job);
    while (start < end) {
        const middle = (start + end) >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < jobId ? (start = middle + 1) : (end = middle);
    }
    return start;
}
function queueJob(job) {
    // the dedupe search uses the startIndex argument of Array.includes()
    // by default the search index includes the current job that is being run
    // so it cannot recursively trigger itself again.
    // if the job is a watch() callback, the search will start with a +1 index to
    // allow it recursively trigger itself - it is the user's responsibility to
    // ensure it doesn't end up in an infinite loop.
    if ((!queue.length ||
        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&
        job !== currentPreFlushParentJob) {
        const pos = findInsertionIndex(job);
        if (pos > -1) {
            queue.splice(pos, 0, job);
        }
        else {
            queue.push(job);
        }
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
        queue.splice(i, 1);
    }
}
function queueCb(cb, activeQueue, pendingQueue, index) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {
        if (!activeQueue ||
            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
            pendingQueue.push(cb);
        }
    }
    else {
        // if cb is an array, it is a component lifecycle hook which can only be
        // triggered by a job, which is already deduped in the main queue, so
        // we can skip duplicate check here to improve perf
        pendingQueue.push(...cb);
    }
    queueFlush();
}
function queuePreFlushCb(cb) {
    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
    if (pendingPreFlushCbs.length) {
        currentPreFlushParentJob = parentJob;
        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
        pendingPreFlushCbs.length = 0;
        if ((true)) {
            seen = seen || new Map();
        }
        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
            if (( true) &&
                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
                continue;
            }
            activePreFlushCbs[preFlushIndex]();
        }
        activePreFlushCbs = null;
        preFlushIndex = 0;
        currentPreFlushParentJob = null;
        // recursively flush until it drains
        flushPreFlushCbs(seen, parentJob);
    }
}
function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)];
        pendingPostFlushCbs.length = 0;
        // #1947 already has active queue, nested flushPostFlushCbs call
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        if ((true)) {
            seen = seen || new Map();
        }
        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            if (( true) &&
                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
                continue;
            }
            activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    if ((true)) {
        seen = seen || new Map();
    }
    flushPreFlushCbs(seen);
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child so its render effect will have smaller
    //    priority number)
    // 2. If a component is unmounted during a parent component's update,
    //    its update can be skipped.
    queue.sort((a, b) => getId(a) - getId(b));
    try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && job.active !== false) {
                if (( true) && checkRecursiveUpdates(seen, job)) {
                    continue;
                }
                callWithErrorHandling(job, null, 14 /* SCHEDULER */);
            }
        }
    }
    finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        // some postFlushCb queued jobs!
        // keep flushing until it drains.
        if (queue.length ||
            pendingPreFlushCbs.length ||
            pendingPostFlushCbs.length) {
            flushJobs(seen);
        }
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
        seen.set(fn, 1);
    }
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +
                `This means you have a reactive effect that is mutating its own ` +
                `dependencies and thus recursively triggering itself. Possible sources ` +
                `include component template, render function, updated hook or ` +
                `watcher source function.`);
            return true;
        }
        else {
            seen.set(fn, count + 1);
        }
    }
}

/* eslint-disable no-restricted-globals */
let isHmrUpdating = false;
const hmrDirtyComponents = new Set();
// Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.
if ((true)) {
    const globalObject = typeof __webpack_require__.g !== 'undefined'
        ? __webpack_require__.g
        : typeof self !== 'undefined'
            ? self
            : typeof window !== 'undefined'
                ? window
                : {};
    globalObject.__VUE_HMR_RUNTIME__ = {
        createRecord: tryWrap(createRecord),
        rerender: tryWrap(rerender),
        reload: tryWrap(reload)
    };
}
const map = new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, component) {
    if (!component) {
        warn(`HMR API usage is out of date.\n` +
            `Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant ` +
            `dependency that handles Vue SFC compilation.`);
        component = {};
    }
    if (map.has(id)) {
        return false;
    }
    map.set(id, {
        component: isClassComponent(component) ? component.__vccOpts : component,
        instances: new Set()
    });
    return true;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record)
        return;
    if (newRender)
        record.component.render = newRender;
    // Array.from creates a snapshot which avoids the set being mutated during
    // updates
    Array.from(record.instances).forEach(instance => {
        if (newRender) {
            instance.render = newRender;
        }
        instance.renderCache = [];
        // this flag forces child components with slot content to update
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
        return;
    // Array.from creates a snapshot which avoids the set being mutated during
    // updates
    const { component, instances } = record;
    if (!hmrDirtyComponents.has(component)) {
        // 1. Update existing comp definition to match new one
        newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(component, newComp);
        for (const key in component) {
            if (key !== '__file' && !(key in newComp)) {
                delete component[key];
            }
        }
        // 2. Mark component dirty. This forces the renderer to replace the component
        // on patch.
        hmrDirtyComponents.add(component);
        // 3. Make sure to unmark the component after the reload.
        queuePostFlushCb(() => {
            hmrDirtyComponents.delete(component);
        });
    }
    Array.from(instances).forEach(instance => {
        if (instance.parent) {
            // 4. Force the parent instance to re-render. This will cause all updated
            // components to be unmounted and re-mounted. Queue the update so that we
            // don't end up forcing the same parent to re-render multiple times.
            queueJob(instance.parent.update);
        }
        else if (instance.appContext.reload) {
            // root instance mounted via createApp() has a reload method
            instance.appContext.reload();
        }
        else if (typeof window !== 'undefined') {
            // root instance inside tree created via raw render(). Force reload.
            window.location.reload();
        }
        else {
            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
        }
    });
}
function tryWrap(fn) {
    return (id, arg) => {
        try {
            return fn(id, arg);
        }
        catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +
                `Full reload required.`);
        }
    };
}

let devtools;
function setDevtoolsHook(hook) {
    devtools = hook;
}
function devtoolsInitApp(app, version) {
    // TODO queue if devtools is undefined
    if (!devtools)
        return;
    devtools.emit("app:init" /* APP_INIT */, app, version, {
        Fragment,
        Text,
        Comment: Comment$1,
        Static
    });
}
function devtoolsUnmountApp(app) {
    if (!devtools)
        return;
    devtools.emit("app:unmount" /* APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);
const devtoolsComponentUpdated = /*#__PURE__*/ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);
const devtoolsComponentRemoved = /*#__PURE__*/ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */);
function createDevtoolsComponentHook(hook) {
    return (component) => {
        if (!devtools)
            return;
        devtools.emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
    };
}
const devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */);
const devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */);
function createDevtoolsPerformanceHook(hook) {
    return (component, type, time) => {
        if (!devtools)
            return;
        devtools.emit(hook, component.appContext.app, component.uid, component, type, time);
    };
}
function devtoolsComponentEmit(component, event, params) {
    if (!devtools)
        return;
    devtools.emit("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);
}

const deprecationData = {
    ["GLOBAL_MOUNT" /* GLOBAL_MOUNT */]: {
        message: `The global app bootstrapping API has changed: vm.$mount() and the "el" ` +
            `option have been removed. Use createApp(RootComponent).mount() instead.`,
        link: `https://v3.vuejs.org/guide/migration/global-api.html#mounting-app-instance`
    },
    ["GLOBAL_MOUNT_CONTAINER" /* GLOBAL_MOUNT_CONTAINER */]: {
        message: `Vue detected directives on the mount container. ` +
            `In Vue 3, the container is no longer considered part of the template ` +
            `and will not be processed/replaced.`,
        link: `https://v3.vuejs.org/guide/migration/mount-changes.html`
    },
    ["GLOBAL_EXTEND" /* GLOBAL_EXTEND */]: {
        message: `Vue.extend() has been removed in Vue 3. ` +
            `Use defineComponent() instead.`,
        link: `https://v3.vuejs.org/api/global-api.html#definecomponent`
    },
    ["GLOBAL_PROTOTYPE" /* GLOBAL_PROTOTYPE */]: {
        message: `Vue.prototype is no longer available in Vue 3. ` +
            `Use app.config.globalProperties instead.`,
        link: `https://v3.vuejs.org/guide/migration/global-api.html#vue-prototype-replaced-by-config-globalproperties`
    },
    ["GLOBAL_SET" /* GLOBAL_SET */]: {
        message: `Vue.set() has been removed as it is no longer needed in Vue 3. ` +
            `Simply use native JavaScript mutations.`
    },
    ["GLOBAL_DELETE" /* GLOBAL_DELETE */]: {
        message: `Vue.delete() has been removed as it is no longer needed in Vue 3. ` +
            `Simply use native JavaScript mutations.`
    },
    ["GLOBAL_OBSERVABLE" /* GLOBAL_OBSERVABLE */]: {
        message: `Vue.observable() has been removed. ` +
            `Use \`import { reactive } from "vue"\` from Composition API instead.`,
        link: `https://v3.vuejs.org/api/basic-reactivity.html`
    },
    ["GLOBAL_PRIVATE_UTIL" /* GLOBAL_PRIVATE_UTIL */]: {
        message: `Vue.util has been removed. Please refactor to avoid its usage ` +
            `since it was an internal API even in Vue 2.`
    },
    ["CONFIG_SILENT" /* CONFIG_SILENT */]: {
        message: `config.silent has been removed because it is not good practice to ` +
            `intentionally suppress warnings. You can use your browser console's ` +
            `filter features to focus on relevant messages.`
    },
    ["CONFIG_DEVTOOLS" /* CONFIG_DEVTOOLS */]: {
        message: `config.devtools has been removed. To enable devtools for ` +
            `production, configure the __VUE_PROD_DEVTOOLS__ compile-time flag.`,
        link: `https://github.com/vuejs/vue-next/tree/master/packages/vue#bundler-build-feature-flags`
    },
    ["CONFIG_KEY_CODES" /* CONFIG_KEY_CODES */]: {
        message: `config.keyCodes has been removed. ` +
            `In Vue 3, you can directly use the kebab-case key names as v-on modifiers.`,
        link: `https://v3.vuejs.org/guide/migration/keycode-modifiers.html`
    },
    ["CONFIG_PRODUCTION_TIP" /* CONFIG_PRODUCTION_TIP */]: {
        message: `config.productionTip has been removed.`,
        link: `https://v3.vuejs.org/guide/migration/global-api.html#config-productiontip-removed`
    },
    ["CONFIG_IGNORED_ELEMENTS" /* CONFIG_IGNORED_ELEMENTS */]: {
        message: () => {
            let msg = `config.ignoredElements has been removed.`;
            if (isRuntimeOnly()) {
                msg += ` Pass the "isCustomElement" option to @vue/compiler-dom instead.`;
            }
            else {
                msg += ` Use config.isCustomElement instead.`;
            }
            return msg;
        },
        link: `https://v3.vuejs.org/guide/migration/global-api.html#config-ignoredelements-is-now-config-iscustomelement`
    },
    ["CONFIG_WHITESPACE" /* CONFIG_WHITESPACE */]: {
        // this warning is only relevant in the full build when using runtime
        // compilation, so it's put in the runtime compatConfig list.
        message: `Vue 3 compiler's whitespace option will default to "condense" instead of ` +
            `"preserve". To suppress this warning, provide an explicit value for ` +
            `\`config.compilerOptions.whitespace\`.`
    },
    ["CONFIG_OPTION_MERGE_STRATS" /* CONFIG_OPTION_MERGE_STRATS */]: {
        message: `config.optionMergeStrategies no longer exposes internal strategies. ` +
            `Use custom merge functions instead.`
    },
    ["INSTANCE_SET" /* INSTANCE_SET */]: {
        message: `vm.$set() has been removed as it is no longer needed in Vue 3. ` +
            `Simply use native JavaScript mutations.`
    },
    ["INSTANCE_DELETE" /* INSTANCE_DELETE */]: {
        message: `vm.$delete() has been removed as it is no longer needed in Vue 3. ` +
            `Simply use native JavaScript mutations.`
    },
    ["INSTANCE_DESTROY" /* INSTANCE_DESTROY */]: {
        message: `vm.$destroy() has been removed. Use app.unmount() instead.`,
        link: `https://v3.vuejs.org/api/application-api.html#unmount`
    },
    ["INSTANCE_EVENT_EMITTER" /* INSTANCE_EVENT_EMITTER */]: {
        message: `vm.$on/$once/$off() have been removed. ` +
            `Use an external event emitter library instead.`,
        link: `https://v3.vuejs.org/guide/migration/events-api.html`
    },
    ["INSTANCE_EVENT_HOOKS" /* INSTANCE_EVENT_HOOKS */]: {
        message: event => `"${event}" lifecycle events are no longer supported. From templates, ` +
            `use the "vnode" prefix instead of "hook:". For example, @${event} ` +
            `should be changed to @vnode-${event.slice(5)}. ` +
            `From JavaScript, use Composition API to dynamically register lifecycle ` +
            `hooks.`,
        link: `https://v3.vuejs.org/guide/migration/vnode-lifecycle-events.html`
    },
    ["INSTANCE_CHILDREN" /* INSTANCE_CHILDREN */]: {
        message: `vm.$children has been removed. Consider refactoring your logic ` +
            `to avoid relying on direct access to child components.`,
        link: `https://v3.vuejs.org/guide/migration/children.html`
    },
    ["INSTANCE_LISTENERS" /* INSTANCE_LISTENERS */]: {
        message: `vm.$listeners has been removed. In Vue 3, parent v-on listeners are ` +
            `included in vm.$attrs and it is no longer necessary to separately use ` +
            `v-on="$listeners" if you are already using v-bind="$attrs". ` +
            `(Note: the Vue 3 behavior only applies if this compat config is disabled)`,
        link: `https://v3.vuejs.org/guide/migration/listeners-removed.html`
    },
    ["INSTANCE_SCOPED_SLOTS" /* INSTANCE_SCOPED_SLOTS */]: {
        message: `vm.$scopedSlots has been removed. Use vm.$slots instead.`,
        link: `https://v3.vuejs.org/guide/migration/slots-unification.html`
    },
    ["INSTANCE_ATTRS_CLASS_STYLE" /* INSTANCE_ATTRS_CLASS_STYLE */]: {
        message: componentName => `Component <${componentName ||
            'Anonymous'}> has \`inheritAttrs: false\` but is ` +
            `relying on class/style fallthrough from parent. In Vue 3, class/style ` +
            `are now included in $attrs and will no longer fallthrough when ` +
            `inheritAttrs is false. If you are already using v-bind="$attrs" on ` +
            `component root it should render the same end result. ` +
            `If you are binding $attrs to a non-root element and expecting ` +
            `class/style to fallthrough on root, you will need to now manually bind ` +
            `them on root via :class="$attrs.class".`,
        link: `https://v3.vuejs.org/guide/migration/attrs-includes-class-style.html`
    },
    ["OPTIONS_DATA_FN" /* OPTIONS_DATA_FN */]: {
        message: `The "data" option can no longer be a plain object. ` +
            `Always use a function.`,
        link: `https://v3.vuejs.org/guide/migration/data-option.html`
    },
    ["OPTIONS_DATA_MERGE" /* OPTIONS_DATA_MERGE */]: {
        message: (key) => `Detected conflicting key "${key}" when merging data option values. ` +
            `In Vue 3, data keys are merged shallowly and will override one another.`,
        link: `https://v3.vuejs.org/guide/migration/data-option.html#mixin-merge-behavior-change`
    },
    ["OPTIONS_BEFORE_DESTROY" /* OPTIONS_BEFORE_DESTROY */]: {
        message: `\`beforeDestroy\` has been renamed to \`beforeUnmount\`.`
    },
    ["OPTIONS_DESTROYED" /* OPTIONS_DESTROYED */]: {
        message: `\`destroyed\` has been renamed to \`unmounted\`.`
    },
    ["WATCH_ARRAY" /* WATCH_ARRAY */]: {
        message: `"watch" option or vm.$watch on an array value will no longer ` +
            `trigger on array mutation unless the "deep" option is specified. ` +
            `If current usage is intended, you can disable the compat behavior and ` +
            `suppress this warning with:` +
            `\n\n  configureCompat({ ${"WATCH_ARRAY" /* WATCH_ARRAY */}: false })\n`,
        link: `https://v3.vuejs.org/guide/migration/watch.html`
    },
    ["PROPS_DEFAULT_THIS" /* PROPS_DEFAULT_THIS */]: {
        message: (key) => `props default value function no longer has access to "this". The compat ` +
            `build only offers access to this.$options.` +
            `(found in prop "${key}")`,
        link: `https://v3.vuejs.org/guide/migration/props-default-this.html`
    },
    ["CUSTOM_DIR" /* CUSTOM_DIR */]: {
        message: (legacyHook, newHook) => `Custom directive hook "${legacyHook}" has been removed. ` +
            `Use "${newHook}" instead.`,
        link: `https://v3.vuejs.org/guide/migration/custom-directives.html`
    },
    ["V_FOR_REF" /* V_FOR_REF */]: {
        message: `Ref usage on v-for no longer creates array ref values in Vue 3. ` +
            `Consider using function refs or refactor to avoid ref usage altogether.`,
        link: `https://v3.vuejs.org/guide/migration/array-refs.html`
    },
    ["V_ON_KEYCODE_MODIFIER" /* V_ON_KEYCODE_MODIFIER */]: {
        message: `Using keyCode as v-on modifier is no longer supported. ` +
            `Use kebab-case key name modifiers instead.`,
        link: `https://v3.vuejs.org/guide/migration/keycode-modifiers.html`
    },
    ["ATTR_FALSE_VALUE" /* ATTR_FALSE_VALUE */]: {
        message: (name) => `Attribute "${name}" with v-bind value \`false\` will render ` +
            `${name}="false" instead of removing it in Vue 3. To remove the attribute, ` +
            `use \`null\` or \`undefined\` instead. If the usage is intended, ` +
            `you can disable the compat behavior and suppress this warning with:` +
            `\n\n  configureCompat({ ${"ATTR_FALSE_VALUE" /* ATTR_FALSE_VALUE */}: false })\n`,
        link: `https://v3.vuejs.org/guide/migration/attribute-coercion.html`
    },
    ["ATTR_ENUMERATED_COERCION" /* ATTR_ENUMERATED_COERCION */]: {
        message: (name, value, coerced) => `Enumerated attribute "${name}" with v-bind value \`${value}\` will ` +
            `${value === null ? `be removed` : `render the value as-is`} instead of coercing the value to "${coerced}" in Vue 3. ` +
            `Always use explicit "true" or "false" values for enumerated attributes. ` +
            `If the usage is intended, ` +
            `you can disable the compat behavior and suppress this warning with:` +
            `\n\n  configureCompat({ ${"ATTR_ENUMERATED_COERCION" /* ATTR_ENUMERATED_COERCION */}: false })\n`,
        link: `https://v3.vuejs.org/guide/migration/attribute-coercion.html`
    },
    ["TRANSITION_CLASSES" /* TRANSITION_CLASSES */]: {
        message: `` // this feature cannot be runtime-detected
    },
    ["TRANSITION_GROUP_ROOT" /* TRANSITION_GROUP_ROOT */]: {
        message: `<TransitionGroup> no longer renders a root <span> element by ` +
            `default if no "tag" prop is specified. If you do not rely on the span ` +
            `for styling, you can disable the compat behavior and suppress this ` +
            `warning with:` +
            `\n\n  configureCompat({ ${"TRANSITION_GROUP_ROOT" /* TRANSITION_GROUP_ROOT */}: false })\n`,
        link: `https://v3.vuejs.org/guide/migration/transition-group.html`
    },
    ["COMPONENT_ASYNC" /* COMPONENT_ASYNC */]: {
        message: (comp) => {
            const name = getComponentName(comp);
            return (`Async component${name ? ` <${name}>` : `s`} should be explicitly created via \`defineAsyncComponent()\` ` +
                `in Vue 3. Plain functions will be treated as functional components in ` +
                `non-compat build. If you have already migrated all async component ` +
                `usage and intend to use plain functions for functional components, ` +
                `you can disable the compat behavior and suppress this ` +
                `warning with:` +
                `\n\n  configureCompat({ ${"COMPONENT_ASYNC" /* COMPONENT_ASYNC */}: false })\n`);
        },
        link: `https://v3.vuejs.org/guide/migration/async-components.html`
    },
    ["COMPONENT_FUNCTIONAL" /* COMPONENT_FUNCTIONAL */]: {
        message: (comp) => {
            const name = getComponentName(comp);
            return (`Functional component${name ? ` <${name}>` : `s`} should be defined as a plain function in Vue 3. The "functional" ` +
                `option has been removed. NOTE: Before migrating to use plain ` +
                `functions for functional components, first make sure that all async ` +
                `components usage have been migrated and its compat behavior has ` +
                `been disabled.`);
        },
        link: `https://v3.vuejs.org/guide/migration/functional-components.html`
    },
    ["COMPONENT_V_MODEL" /* COMPONENT_V_MODEL */]: {
        message: (comp) => {
            const configMsg = `opt-in to ` +
                `Vue 3 behavior on a per-component basis with \`compatConfig: { ${"COMPONENT_V_MODEL" /* COMPONENT_V_MODEL */}: false }\`.`;
            if (comp.props &&
                ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(comp.props)
                    ? comp.props.includes('modelValue')
                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(comp.props, 'modelValue'))) {
                return (`Component delcares "modelValue" prop, which is Vue 3 usage, but ` +
                    `is running under Vue 2 compat v-model behavior. You can ${configMsg}`);
            }
            return (`v-model usage on component has changed in Vue 3. Component that expects ` +
                `to work with v-model should now use the "modelValue" prop and emit the ` +
                `"update:modelValue" event. You can update the usage and then ${configMsg}`);
        },
        link: `https://v3.vuejs.org/guide/migration/v-model.html`
    },
    ["RENDER_FUNCTION" /* RENDER_FUNCTION */]: {
        message: `Vue 3's render function API has changed. ` +
            `You can opt-in to the new API with:` +
            `\n\n  configureCompat({ ${"RENDER_FUNCTION" /* RENDER_FUNCTION */}: false })\n` +
            `\n  (This can also be done per-component via the "compatConfig" option.)`,
        link: `https://v3.vuejs.org/guide/migration/render-function-api.html`
    },
    ["FILTERS" /* FILTERS */]: {
        message: `filters have been removed in Vue 3. ` +
            `The "|" symbol will be treated as native JavaScript bitwise OR operator. ` +
            `Use method calls or computed properties instead.`,
        link: `https://v3.vuejs.org/guide/migration/filters.html`
    },
    ["PRIVATE_APIS" /* PRIVATE_APIS */]: {
        message: name => `"${name}" is a Vue 2 private API that no longer exists in Vue 3. ` +
            `If you are seeing this warning only due to a dependency, you can ` +
            `suppress this warning via { PRIVATE_APIS: 'supress-warning' }.`
    }
};
const instanceWarned = Object.create(null);
const warnCount = Object.create(null);
function warnDeprecation(key, instance, ...args) {
    if (false) {}
    instance = instance || getCurrentInstance();
    // check user config
    const config = getCompatConfigForKey(key, instance);
    if (config === 'suppress-warning') {
        return;
    }
    const dupKey = key + args.join('');
    let compId = instance && formatComponentName(instance, instance.type);
    if (compId === 'Anonymous' && instance) {
        compId = instance.uid;
    }
    // skip if the same warning is emitted for the same component type
    const componentDupKey = dupKey + compId;
    if (componentDupKey in instanceWarned) {
        return;
    }
    instanceWarned[componentDupKey] = true;
    // same warning, but different component. skip the long message and just
    // log the key and count.
    if (dupKey in warnCount) {
        warn(`(deprecation ${key}) (${++warnCount[dupKey] + 1})`);
        return;
    }
    warnCount[dupKey] = 0;
    const { message, link } = deprecationData[key];
    warn(`(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`);
    if (!isCompatEnabled(key, instance, true)) {
        console.error(`^ The above deprecation's compat behavior is disabled and will likely ` +
            `lead to runtime errors.`);
    }
}
const globalCompatConfig = {
    MODE: 2
};
function getCompatConfigForKey(key, instance) {
    const instanceConfig = instance && instance.type.compatConfig;
    if (instanceConfig && key in instanceConfig) {
        return instanceConfig[key];
    }
    return globalCompatConfig[key];
}
function isCompatEnabled(key, instance, enableForBuiltIn = false) {
    // skip compat for built-in components
    if (!enableForBuiltIn && instance && instance.type.__isBuiltIn) {
        return false;
    }
    const rawMode = getCompatConfigForKey('MODE', instance) || 2;
    const val = getCompatConfigForKey(key, instance);
    const mode = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(rawMode)
        ? rawMode(instance && instance.type)
        : rawMode;
    if (mode === 2) {
        return val !== false;
    }
    else {
        return val === true || val === 'suppress-warning';
    }
}

function emit(instance, event, ...rawArgs) {
    const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    if ((true)) {
        const { emitsOptions, propsOptions: [propsOptions] } = instance;
        if (emitsOptions) {
            if (!(event in emitsOptions) &&
                !(false )) {
                if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event) in propsOptions)) {
                    warn(`Component emitted event "${event}" but it is neither declared in ` +
                        `the emits option nor as an "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)}" prop.`);
                }
            }
            else {
                const validator = emitsOptions[event];
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {
                    const isValid = validator(...rawArgs);
                    if (!isValid) {
                        warn(`Invalid event arguments: event validation failed for event "${event}".`);
                    }
                }
            }
        }
    }
    let args = rawArgs;
    const isModelListener = event.startsWith('update:');
    // for v-model update:xxx events, apply modifiers on args
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        if (trim) {
            args = rawArgs.map(a => a.trim());
        }
        else if (number) {
            args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber);
        }
    }
    if (true) {
        devtoolsComponentEmit(instance, event, args);
    }
    if ((true)) {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {
            warn(`Event "${lowerCaseEvent}" is emitted in component ` +
                `${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". ` +
                `Note that HTML attributes are case-insensitive and you cannot use ` +
                `v-on to listen to camelCase events when using in-DOM templates. ` +
                `You should probably use "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)}" instead of "${event}".`);
        }
    }
    let handlerName;
    let handler = props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event))] ||
        // also try camelCase event handler (#2249)
        props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event)))];
    // for v-model update:xxx events, also trigger kebab-case equivalent
    // for props passed via kebab-case
    if (!handler && isModelListener) {
        handler = props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)))];
    }
    if (handler) {
        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) {
            instance.emitted = {};
        }
        else if (instance.emitted[handlerName]) {
            return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== undefined) {
        return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    // apply mixin/extends props
    let hasExtends = false;
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        const extendEmits = (raw) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);
            if (normalizedFromExtend) {
                hasExtends = true;
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);
            }
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
            extendEmits(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
        }
    }
    if (!raw && !hasExtends) {
        cache.set(comp, null);
        return null;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        raw.forEach(key => (normalized[key] = null));
    }
    else {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);
    }
    cache.set(comp, normalized);
    return normalized;
}
// Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.
function isEmitListener(options, key) {
    if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        return false;
    }
    key = key.slice(2).replace(/Once$/, '');
    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) ||
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) ||
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key));
}

/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */
let currentRenderingInstance = null;
let currentScopeId = null;
/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */
function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = (instance && instance.type.__scopeId) || null;
    return prev;
}
/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 */
function pushScopeId(id) {
    currentScopeId = id;
}
/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * @private
 */
function popScopeId() {
    currentScopeId = null;
}
/**
 * Only for backwards compat
 * @private
 */
const withScopeId = (_id) => withCtx;
/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 */
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only
) {
    if (!ctx)
        return fn;
    // already normalized
    if (fn._n) {
        return fn;
    }
    const renderFnWithContext = (...args) => {
        // If a user calls a compiled slot inside a template expression (#1745), it
        // can mess up block tracking, so by default we disable block tracking and
        // force bail out when invoking a compiled slot (indicated by the ._d flag).
        // This isn't necessary if rendering a compiled `<slot>`, so we flip the
        // ._d flag off when invoking the wrapped fn inside `renderSlot`.
        if (renderFnWithContext._d) {
            setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        const res = fn(...args);
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
            setBlockTracking(1);
        }
        if (true) {
            devtoolsComponentUpdated(ctx);
        }
        return res;
    };
    // mark normalized to avoid duplicated wrapping
    renderFnWithContext._n = true;
    // mark this as compiled by default
    // this is used in vnode.ts -> normalizeChildren() to set the slot
    // rendering flag.
    renderFnWithContext._c = true;
    // disable block tracking by default
    renderFnWithContext._d = true;
    return renderFnWithContext;
}

/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
    let result;
    const prev = setCurrentRenderingInstance(instance);
    if ((true)) {
        accessedAttrs = false;
    }
    try {
        let fallthroughAttrs;
        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
            // withProxy is a proxy with a different `has` trap only for
            // runtime-compiled render functions using `with` block.
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
        }
        else {
            // functional
            const render = Component;
            // in dev, mark attrs accessed if optional props (attrs === props)
            if (( true) && attrs === props) {
                markAttrsAccessed();
            }
            result = normalizeVNode(render.length > 1
                ? render(props, ( true)
                    ? {
                        get attrs() {
                            markAttrsAccessed();
                            return attrs;
                        },
                        slots,
                        emit
                    }
                    : 0)
                : render(props, null /* we know it doesn't need it */));
            fallthroughAttrs = Component.props
                ? attrs
                : getFunctionalFallthrough(attrs);
        }
        // attr merging
        // in dev mode, comments are preserved, and it's possible for a template
        // to have comments along side the root element which makes it a fragment
        let root = result;
        let setRoot = undefined;
        if (( true) &&
            result.patchFlag > 0 &&
            result.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
            ;
            [root, setRoot] = getChildRoot(result);
        }
        if (fallthroughAttrs && inheritAttrs !== false) {
            const keys = Object.keys(fallthroughAttrs);
            const { shapeFlag } = root;
            if (keys.length) {
                if (shapeFlag & 1 /* ELEMENT */ ||
                    shapeFlag & 6 /* COMPONENT */) {
                    if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {
                        // If a v-model listener (onUpdate:xxx) has a corresponding declared
                        // prop, it indicates this component expects to handle v-model and
                        // it should not fallthrough.
                        // related: #1543, #1643, #1989
                        fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                    }
                    root = cloneVNode(root, fallthroughAttrs);
                }
                else if (( true) && !accessedAttrs && root.type !== Comment$1) {
                    const allAttrs = Object.keys(attrs);
                    const eventAttrs = [];
                    const extraAttrs = [];
                    for (let i = 0, l = allAttrs.length; i < l; i++) {
                        const key = allAttrs[i];
                        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                            // ignore v-model handlers when they fail to fallthrough
                            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
                                // remove `on`, lowercase first letter to reflect event casing
                                // accurately
                                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                            }
                        }
                        else {
                            extraAttrs.push(key);
                        }
                    }
                    if (extraAttrs.length) {
                        warn(`Extraneous non-props attributes (` +
                            `${extraAttrs.join(', ')}) ` +
                            `were passed to component but could not be automatically inherited ` +
                            `because component renders fragment or text root nodes.`);
                    }
                    if (eventAttrs.length) {
                        warn(`Extraneous non-emits event listeners (` +
                            `${eventAttrs.join(', ')}) ` +
                            `were passed to component but could not be automatically inherited ` +
                            `because component renders fragment or text root nodes. ` +
                            `If the listener is intended to be a component custom event listener only, ` +
                            `declare it using the "emits" option.`);
                    }
                }
            }
        }
        if (false) {}
        // inherit directives
        if (vnode.dirs) {
            if (( true) && !isElementRoot(root)) {
                warn(`Runtime directive used on component with non-element root node. ` +
                    `The directives will not function as intended.`);
            }
            root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
        }
        // inherit transition data
        if (vnode.transition) {
            if (( true) && !isElementRoot(root)) {
                warn(`Component inside <Transition> renders non-element root node ` +
                    `that cannot be animated.`);
            }
            root.transition = vnode.transition;
        }
        if (( true) && setRoot) {
            setRoot(root);
        }
        else {
            result = root;
        }
    }
    catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1 /* RENDER_FUNCTION */);
        result = createVNode(Comment$1);
    }
    setCurrentRenderingInstance(prev);
    return result;
}
/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */
const getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) {
        return [vnode, undefined];
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) {
                dynamicChildren[dynamicIndex] = updatedRoot;
            }
            else if (updatedRoot.patchFlag > 0) {
                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
            }
        }
    };
    return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isVNode(child)) {
            // ignore user comment
            if (child.type !== Comment$1 || child.children === 'v-if') {
                if (singleRoot) {
                    // has more than 1 non-comment child, return now
                    return;
                }
                else {
                    singleRoot = child;
                }
            }
        }
        else {
            return;
        }
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
        if (key === 'class' || key === 'style' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
            (res || (res = {}))[key] = attrs[key];
        }
    }
    return res;
};
const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
        }
    }
    return res;
};
const isElementRoot = (vnode) => {
    return (vnode.shapeFlag & 6 /* COMPONENT */ ||
        vnode.shapeFlag & 1 /* ELEMENT */ ||
        vnode.type === Comment$1 // potential v-if branch switch
    );
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    // Parent component's render function was hot-updated. Since this may have
    // caused the child component's slots content to have changed, we need to
    // force the child to update as well.
    if (( true) && (prevChildren || nextChildren) && isHmrUpdating) {
        return true;
    }
    // force child update for runtime directive or transition on component vnode.
    if (nextVNode.dirs || nextVNode.transition) {
        return true;
    }
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {
            // slot content that references values that might have changed,
            // e.g. in a v-for
            return true;
        }
        if (patchFlag & 16 /* FULL_PROPS */) {
            if (!prevProps) {
                return !!nextProps;
            }
            // presence of this flag indicates props are always non-null
            return hasPropsChanged(prevProps, nextProps, emits);
        }
        else if (patchFlag & 8 /* PROPS */) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] &&
                    !isEmitListener(emits, key)) {
                    return true;
                }
            }
        }
    }
    else {
        // this path is only taken by manually written render functions
        // so presence of any children leads to a forced update
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
                return true;
            }
        }
        if (prevProps === nextProps) {
            return false;
        }
        if (!prevProps) {
            return !!nextProps;
        }
        if (!nextProps) {
            return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] &&
            !isEmitListener(emitsOptions, key)) {
            return true;
        }
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el // HostNode
) {
    while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}

const isSuspense = (type) => type.__isSuspense;
// Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.
const SuspenseImpl = {
    name: 'Suspense',
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, 
    // platform-specific impl passed from renderer
    rendererInternals) {
        if (n1 == null) {
            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
        }
        else {
            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
        }
    },
    hydrate: hydrateSuspense,
    create: createSuspenseBoundary,
    normalize: normalizeSuspenseChildren
};
// Force-casted public typing for h and TSX props inference
const Suspense = (SuspenseImpl
    );
function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(eventListener)) {
        eventListener();
    }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement('div');
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));
    // start mounting the content subtree in an off-dom container
    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
    // now check if we have encountered any async deps
    if (suspense.deps > 0) {
        // has async
        // invoke @fallback event
        triggerEvent(vnode, 'onPending');
        triggerEvent(vnode, 'onFallback');
        // mount the fallback tree
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
    }
    else {
        // Suspense has no async deps. Just resolve.
        suspense.resolve();
    }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = (n2.suspense = n1.suspense);
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            // same root type but content may have changed.
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
                suspense.resolve();
            }
            else if (isInFallback) {
                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, newFallback);
            }
        }
        else {
            // toggled before pending tree is resolved
            suspense.pendingId++;
            if (isHydrating) {
                // if toggled before hydration is finished, the current DOM tree is
                // no longer valid. set it as the active branch so it will be unmounted
                // when resolved
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            }
            else {
                unmount(pendingBranch, parentComponent, suspense);
            }
            // increment pending ID. this is used to invalidate async callbacks
            // reset suspense state
            suspense.deps = 0;
            // discard effects from pending branch
            suspense.effects.length = 0;
            // discard previous container
            suspense.hiddenContainer = createElement('div');
            if (isInFallback) {
                // already in fallback state
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    isSVG, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            }
            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                // toggled "back" to current active branch
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                // force resolve
                suspense.resolve(true);
            }
            else {
                // switched to a 3rd branch
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
            }
        }
    }
    else {
        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            // root did not change, just normal patch
            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            setActiveBranch(suspense, newBranch);
        }
        else {
            // root node toggled
            // invoke @pending event
            triggerEvent(n2, 'onPending');
            // mount pending branch in off-dom container
            suspense.pendingBranch = newBranch;
            suspense.pendingId++;
            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
                // incoming branch has no async deps, resolve now.
                suspense.resolve();
            }
            else {
                const { timeout, pendingId } = suspense;
                if (timeout > 0) {
                    setTimeout(() => {
                        if (suspense.pendingId === pendingId) {
                            suspense.fallback(newFallback);
                        }
                    }, timeout);
                }
                else if (timeout === 0) {
                    suspense.fallback(newFallback);
                }
            }
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    /* istanbul ignore if */
    if ( true && !hasWarned) {
        hasWarned = true;
        // @ts-ignore `console.info` cannot be null error
        console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
    const timeout = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props && vnode.props.timeout);
    const suspense = {
        vnode,
        parent,
        parentComponent,
        isSVG,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        pendingId: 0,
        timeout: typeof timeout === 'number' ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: true,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve(resume = false) {
            if ((true)) {
                if (!resume && !suspense.pendingBranch) {
                    throw new Error(`suspense.resolve() is called without a pending branch.`);
                }
                if (suspense.isUnmounted) {
                    throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
                }
            }
            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;
            if (suspense.isHydrating) {
                suspense.isHydrating = false;
            }
            else if (!resume) {
                const delayEnter = activeBranch &&
                    pendingBranch.transition &&
                    pendingBranch.transition.mode === 'out-in';
                if (delayEnter) {
                    activeBranch.transition.afterLeave = () => {
                        if (pendingId === suspense.pendingId) {
                            move(pendingBranch, container, anchor, 0 /* ENTER */);
                        }
                    };
                }
                // this is initial anchor on mount
                let { anchor } = suspense;
                // unmount current active tree
                if (activeBranch) {
                    // if the fallback tree was mounted, it may have been moved
                    // as part of a parent suspense. get the latest anchor for insertion
                    anchor = next(activeBranch);
                    unmount(activeBranch, parentComponent, suspense, true);
                }
                if (!delayEnter) {
                    // move content from off-dom container to actual container
                    move(pendingBranch, container, anchor, 0 /* ENTER */);
                }
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            // flush buffered effects
            // check if there is a pending parent suspense
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while (parent) {
                if (parent.pendingBranch) {
                    // found a pending parent suspense, merge buffered post jobs
                    // into that parent
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            // no pending parent suspense, flush all jobs
            if (!hasUnresolvedAncestor) {
                queuePostFlushCb(effects);
            }
            suspense.effects = [];
            // invoke @resolve event
            triggerEvent(vnode, 'onResolve');
        },
        fallback(fallbackVNode) {
            if (!suspense.pendingBranch) {
                return;
            }
            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;
            // invoke @fallback event
            triggerEvent(vnode, 'onFallback');
            const anchor = next(activeBranch);
            const mountFallback = () => {
                if (!suspense.isInFallback) {
                    return;
                }
                // mount the fallback tree
                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';
            if (delayEnter) {
                activeBranch.transition.afterLeave = mountFallback;
            }
            suspense.isInFallback = true;
            // unmount current active branch
            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
            true // shouldRemove
            );
            if (!delayEnter) {
                mountFallback();
            }
        },
        move(container, anchor, type) {
            suspense.activeBranch &&
                move(suspense.activeBranch, container, anchor, type);
            suspense.container = container;
        },
        next() {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep(instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) {
                suspense.deps++;
            }
            const hydratedEl = instance.vnode.el;
            instance
                .asyncDep.catch(err => {
                handleError(err, instance, 0 /* SETUP_FUNCTION */);
            })
                .then(asyncSetupResult => {
                // retry when the setup() promise resolves.
                // component may have been unmounted before resolve.
                if (instance.isUnmounted ||
                    suspense.isUnmounted ||
                    suspense.pendingId !== instance.suspenseId) {
                    return;
                }
                // retry from this component
                instance.asyncResolved = true;
                const { vnode } = instance;
                if ((true)) {
                    pushWarningContext(vnode);
                }
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) {
                    // vnode may have been replaced if an update happened before the
                    // async dep is resolved.
                    vnode.el = hydratedEl;
                }
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode, 
                // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), 
                // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                if (placeholder) {
                    remove(placeholder);
                }
                updateHOCHostEl(instance, vnode.el);
                if ((true)) {
                    popWarningContext();
                }
                // only decrease deps count if suspense is not already resolved
                if (isInPendingSuspense && --suspense.deps === 0) {
                    suspense.resolve();
                }
            });
        },
        unmount(parentSuspense, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) {
                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
            }
            if (suspense.pendingBranch) {
                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
            }
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    /* eslint-disable no-restricted-globals */
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));
    // there are two possible scenarios for server-rendered suspense:
    // - success: ssr content should be fully resolved
    // - failure: ssr content should be the fallback branch.
    // however, on the client we don't really know if it has failed or not
    // attempt to hydrate the DOM assuming it has succeeded, but we still
    // need to construct a suspense boundary first
    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) {
        suspense.resolve();
    }
    return result;
    /* eslint-enable no-restricted-globals */
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32 /* SLOTS_CHILDREN */;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren
        ? normalizeSuspenseSlot(children.fallback)
        : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
    let block;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
        const isCompiledSlot = s._c;
        if (isCompiledSlot) {
            // disableTracking: false
            // allow block tracking for compiled slots
            // (see ./componentRenderContext.ts)
            s._d = false;
            openBlock();
        }
        s = s();
        if (isCompiledSlot) {
            s._d = true;
            block = currentBlock;
            closeBlock();
        }
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {
        const singleChild = filterSingleRoot(s);
        if (( true) && !singleChild) {
            warn(`<Suspense> slots expect a single root node.`);
        }
        s = singleChild;
    }
    s = normalizeVNode(s);
    if (block) {
        s.dynamicChildren = block.filter(c => c !== s);
    }
    return s;
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
            suspense.effects.push(...fn);
        }
        else {
            suspense.effects.push(fn);
        }
    }
    else {
        queuePostFlushCb(fn);
    }
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    const el = (vnode.el = branch.el);
    // in case suspense is the root node of a component,
    // recursively update the HOC el
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}

function provide(key, value) {
    if (!currentInstance) {
        if ((true)) {
            warn(`provide() can only be used inside setup().`);
        }
    }
    else {
        let provides = currentInstance.provides;
        // by default an instance inherits its parent's provides object
        // but when it needs to provide values of its own, it creates its
        // own provides object using parent provides object as prototype.
        // this way in `inject` we can simply look up injections from direct
        // parent and let the prototype chain do the work.
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
        }
        // TS doesn't allow symbol as index type
        provides[key] = value;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    const instance = currentInstance || currentRenderingInstance;
    if (instance) {
        // #2400
        // to support `app.use` plugins,
        // fallback to appContext's `provides` if the intance is at root
        const provides = instance.parent == null
            ? instance.vnode.appContext && instance.vnode.appContext.provides
            : instance.parent.provides;
        if (provides && key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)
                ? defaultValue.call(instance.proxy)
                : defaultValue;
        }
        else if ((true)) {
            warn(`injection "${String(key)}" not found.`);
        }
    }
    else if ((true)) {
        warn(`inject() can only be used inside setup() or functional components.`);
    }
}

// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
// initial value for watchers to trigger on undefined initial values
const INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {
        warn(`\`watch(fn, options?)\` signature has been moved to a separate API. ` +
            `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
            `supports \`watch(source, cb, options?) signature.`);
    }
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ, instance = currentInstance) {
    if (( true) && !cb) {
        if (immediate !== undefined) {
            warn(`watch() "immediate" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
        if (deep !== undefined) {
            warn(`watch() "deep" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
    }
    const warnInvalidSource = (s) => {
        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +
            `a reactive object, or an array of these types.`);
    };
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(source)) {
        getter = () => source.value;
        forceTrigger = !!source._shallow;
    }
    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source)) {
        getter = () => source;
        deep = true;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)) {
        isMultiSource = true;
        forceTrigger = source.some(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive);
        getter = () => source.map(s => {
            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)) {
                return s.value;
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s)) {
                return traverse(s);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);
            }
            else {
                ( true) && warnInvalidSource(s);
            }
        });
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
        if (cb) {
            // getter with cb
            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);
        }
        else {
            // no cb -> simple effect
            getter = () => {
                if (instance && instance.isUnmounted) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);
            };
        }
    }
    else {
        getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
        ( true) && warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onInvalidate = (fn) => {
        cleanup = runner.options.onStop = () => {
            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
        };
    };
    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    const job = () => {
        if (!runner.active) {
            return;
        }
        if (cb) {
            // watch(source, cb)
            const newValue = runner();
            if (deep ||
                forceTrigger ||
                (isMultiSource
                    ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(v, oldValue[i]))
                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(newValue, oldValue)) ||
                (false  )) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onInvalidate
                ]);
                oldValue = newValue;
            }
        }
        else {
            // watchEffect
            runner();
        }
    };
    // important: mark the job as a watcher callback so that scheduler knows
    // it is allowed to self-trigger (#1727)
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === 'sync') {
        scheduler = job; // the scheduler function gets called directly
    }
    else if (flush === 'post') {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    }
    else {
        // default: 'pre'
        scheduler = () => {
            if (!instance || instance.isMounted) {
                queuePreFlushCb(job);
            }
            else {
                // with 'pre' option, the first call must happen before
                // the component is mounted so it is called synchronously.
                job();
            }
        };
    }
    const runner = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect)(getter, {
        lazy: true,
        onTrack,
        onTrigger,
        scheduler
    });
    recordInstanceBoundEffect(runner, instance);
    // initial run
    if (cb) {
        if (immediate) {
            job();
        }
        else {
            oldValue = runner();
        }
    }
    else if (flush === 'post') {
        queuePostRenderEffect(runner, instance && instance.suspense);
    }
    else {
        runner();
    }
    return () => {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(runner);
        if (instance) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(instance.effects, runner);
        }
    };
}
// this.$watch
function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)
        ? source.includes('.')
            ? createPathGetter(publicThis, source)
            : () => publicThis[source]
        : source.bind(publicThis, publicThis);
    let cb;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
        cb = value;
    }
    else {
        cb = value.handler;
        options = value;
    }
    return doWatch(getter, cb.bind(publicThis), options, this);
}
function createPathGetter(ctx, path) {
    const segments = path.split('.');
    return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
        }
        return cur;
    };
}
function traverse(value, seen = new Set()) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) || value["__v_skip" /* SKIP */]) {
        return value;
    }
    seen = seen || new Set();
    if (seen.has(value)) {
        return value;
    }
    seen.add(value);
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
        traverse(value.value, seen);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(value)) {
        value.forEach((v) => {
            traverse(v, seen);
        });
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(value)) {
        for (const key in value) {
            traverse(value[key], seen);
        }
    }
    return value;
}

function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: new Map()
    };
    onMounted(() => {
        state.isMounted = true;
    });
    onBeforeUnmount(() => {
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
                return;
            }
            // warn multiple elements
            if (( true) && children.length > 1) {
                warn('<transition> can only be used on a single element or component. Use ' +
                    '<transition-group> for lists.');
            }
            // there's no need to track reactivity for these props so use the raw
            // props for a bit better perf
            const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
            const { mode } = rawProps;
            // check mode
            if (( true) && mode && !['in-out', 'out-in', 'default'].includes(mode)) {
                warn(`invalid <transition> mode: ${mode}`);
            }
            // at this point children has a guaranteed length of 1.
            const child = children[0];
            if (state.isLeaving) {
                return emptyPlaceholder(child);
            }
            // in the case of <transition><keep-alive/></transition>, we need to
            // compare the type of the kept-alive children.
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
                return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
                const key = getTransitionKey();
                if (prevTransitionKey === undefined) {
                    prevTransitionKey = key;
                }
                else if (key !== prevTransitionKey) {
                    prevTransitionKey = key;
                    transitionKeyChanged = true;
                }
            }
            // handle mode
            if (oldInnerChild &&
                oldInnerChild.type !== Comment$1 &&
                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                // update old tree's hooks in case of dynamic transition
                setTransitionHooks(oldInnerChild, leavingHooks);
                // switching between different views
                if (mode === 'out-in') {
                    state.isLeaving = true;
                    // return placeholder node and queue update when leave finishes
                    leavingHooks.afterLeave = () => {
                        state.isLeaving = false;
                        instance.update();
                    };
                    return emptyPlaceholder(child);
                }
                else if (mode === 'in-out' && innerChild.type !== Comment$1) {
                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                        // early removal callback
                        el._leaveCb = () => {
                            earlyRemove();
                            el._leaveCb = undefined;
                            delete enterHooks.delayedLeave;
                        };
                        enterHooks.delayedLeave = delayedLeave;
                    };
                }
            }
            return child;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
// The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.
function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args) => {
        hook &&
            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) {
                    hook = onBeforeAppear || onBeforeEnter;
                }
                else {
                    return;
                }
            }
            // for same element (v-show)
            if (el._leaveCb) {
                el._leaveCb(true /* cancelled */);
            }
            // for toggled element with same key (v-if)
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode &&
                isSameVNodeType(vnode, leavingVNode) &&
                leavingVNode.el._leaveCb) {
                // force early removal (not cancelled)
                leavingVNode.el._leaveCb();
            }
            callHook(hook, [el]);
        },
        enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                }
                else {
                    return;
                }
            }
            let called = false;
            const done = (el._enterCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                if (cancelled) {
                    callHook(cancelHook, [el]);
                }
                else {
                    callHook(afterHook, [el]);
                }
                if (hooks.delayedLeave) {
                    hooks.delayedLeave();
                }
                el._enterCb = undefined;
            });
            if (hook) {
                hook(el, done);
                if (hook.length <= 1) {
                    done();
                }
            }
            else {
                done();
            }
        },
        leave(el, remove) {
            const key = String(vnode.key);
            if (el._enterCb) {
                el._enterCb(true /* cancelled */);
            }
            if (state.isUnmounting) {
                return remove();
            }
            callHook(onBeforeLeave, [el]);
            let called = false;
            const done = (el._leaveCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                remove();
                if (cancelled) {
                    callHook(onLeaveCancelled, [el]);
                }
                else {
                    callHook(onAfterLeave, [el]);
                }
                el._leaveCb = undefined;
                if (leavingVNodesCache[key] === vnode) {
                    delete leavingVNodesCache[key];
                }
            });
            leavingVNodesCache[key] = vnode;
            if (onLeave) {
                onLeave(el, done);
                if (onLeave.length <= 1) {
                    done();
                }
            }
            else {
                done();
            }
        },
        clone(vnode) {
            return resolveTransitionHooks(vnode, props, state, instance);
        }
    };
    return hooks;
}
// the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode)
        ? vnode.children
            ? vnode.children[0]
            : undefined
        : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
    }
    else if (vnode.shapeFlag & 128 /* SUSPENSE */) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    }
    else {
        vnode.transition = hooks;
    }
}
function getTransitionRawChildren(children, keepComment = false) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        // handle fragment children case, e.g. v-for
        if (child.type === Fragment) {
            if (child.patchFlag & 128 /* KEYED_FRAGMENT */)
                keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
        }
        // comment placeholders should be skipped, e.g. v-if
        else if (keepComment || child.type !== Comment$1) {
            ret.push(child);
        }
    }
    // #1126 if a transition children list contains multiple sub fragments, these
    // fragments will be merged into a flat children array. Since each v-for
    // fragment may contain different static bindings inside, we need to de-op
    // these children to force full diffs to ensure correct behavior.
    if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
            ret[i].patchFlag = -2 /* BAIL */;
        }
    }
    return ret;
}

// implementation, close to no-op
function defineComponent(options) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? { setup: options, name: options.name } : options;
}

const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
function defineAsyncComponent(source) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
        source = { loader: source };
    }
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = () => {
        let thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest = loader()
                .catch(err => {
                err = err instanceof Error ? err : new Error(String(err));
                if (userOnError) {
                    return new Promise((resolve, reject) => {
                        const userRetry = () => resolve(retry());
                        const userFail = () => reject(err);
                        userOnError(err, userRetry, userFail, retries + 1);
                    });
                }
                else {
                    throw err;
                }
            })
                .then((comp) => {
                if (thisRequest !== pendingRequest && pendingRequest) {
                    return pendingRequest;
                }
                if (( true) && !comp) {
                    warn(`Async component loader resolved to undefined. ` +
                        `If you are using retry(), make sure to return its return value.`);
                }
                // interop module default
                if (comp &&
                    (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                    comp = comp.default;
                }
                if (( true) && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
                    throw new Error(`Invalid async component load result: ${comp}`);
                }
                resolvedComp = comp;
                return comp;
            })));
    };
    return defineComponent({
        name: 'AsyncComponentWrapper',
        __asyncLoader: load,
        get __asyncResolved() {
            return resolvedComp;
        },
        setup() {
            const instance = currentInstance;
            // already resolved
            if (resolvedComp) {
                return () => createInnerComp(resolvedComp, instance);
            }
            const onError = (err) => {
                pendingRequest = null;
                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);
            };
            // suspense-controlled or SSR.
            if ((suspensible && instance.suspense) ||
                (false )) {
                return load()
                    .then(comp => {
                    return () => createInnerComp(comp, instance);
                })
                    .catch(err => {
                    onError(err);
                    return () => errorComponent
                        ? createVNode(errorComponent, {
                            error: err
                        })
                        : null;
                });
            }
            const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
            const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
            const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);
            if (delay) {
                setTimeout(() => {
                    delayed.value = false;
                }, delay);
            }
            if (timeout != null) {
                setTimeout(() => {
                    if (!loaded.value && !error.value) {
                        const err = new Error(`Async component timed out after ${timeout}ms.`);
                        onError(err);
                        error.value = err;
                    }
                }, timeout);
            }
            load()
                .then(() => {
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) {
                    // parent is keep-alive, force update so the loaded component's
                    // name is taken into account
                    queueJob(instance.parent.update);
                }
            })
                .catch(err => {
                onError(err);
                error.value = err;
            });
            return () => {
                if (loaded.value && resolvedComp) {
                    return createInnerComp(resolvedComp, instance);
                }
                else if (error.value && errorComponent) {
                    return createVNode(errorComponent, {
                        error: error.value
                    });
                }
                else if (loadingComponent && !delayed.value) {
                    return createVNode(loadingComponent);
                }
            };
        }
    });
}
function createInnerComp(comp, { vnode: { ref, props, children } }) {
    const vnode = createVNode(comp, props, children);
    // ensure inner component inherits the async wrapper's ref owner
    vnode.ref = ref;
    return vnode;
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        // KeepAlive communicates with the instantiated renderer via the
        // ctx where the renderer passes in its internals,
        // and the KeepAlive instance exposes activate/deactivate implementations.
        // The whole point of this is to avoid importing KeepAlive directly in the
        // renderer to facilitate tree-shaking.
        const sharedContext = instance.ctx;
        // if the internal renderer is not registered, it indicates that this is server-side rendering,
        // for KeepAlive, we just need to render its children
        if (!sharedContext.renderer) {
            return slots.default;
        }
        const cache = new Map();
        const keys = new Set();
        let current = null;
        if (true) {
            instance.__v_cache = cache;
        }
        const parentSuspense = instance.suspense;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement('div');
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
            const instance = vnode.component;
            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);
            // in case props have changed
            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(() => {
                instance.isDeactivated = false;
                if (instance.a) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.a);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
            }, parentSuspense);
            if (true) {
                // Update components tree
                devtoolsComponentAdded(instance);
            }
        };
        sharedContext.deactivate = (vnode) => {
            const instance = vnode.component;
            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);
            queuePostRenderEffect(() => {
                if (instance.da) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.da);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
                instance.isDeactivated = true;
            }, parentSuspense);
            if (true) {
                // Update components tree
                devtoolsComponentAdded(instance);
            }
        };
        function unmount(vnode) {
            // reset the shapeFlag so it can be properly unmounted
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key) => {
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) {
                    pruneCacheEntry(key);
                }
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || cached.type !== current.type) {
                unmount(cached);
            }
            else if (current) {
                // current active instance should no longer be kept-alive.
                // we can't unmount it now but it might be later, so reset its flag now.
                resetShapeFlag(current);
            }
            cache.delete(key);
            keys.delete(key);
        }
        // prune cache on include/exclude prop change
        watch(() => [props.include, props.exclude], ([include, exclude]) => {
            include && pruneCache(name => matches(include, name));
            exclude && pruneCache(name => !matches(exclude, name));
        }, 
        // prune post-render after `current` has been updated
        { flush: 'post', deep: true });
        // cache sub tree after render
        let pendingCacheKey = null;
        const cacheSubtree = () => {
            // fix #1621, the pendingCacheKey could be 0
            if (pendingCacheKey != null) {
                cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(() => {
            cache.forEach(cached => {
                const { subTree, suspense } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type) {
                    // current instance will be unmounted as part of keep-alive's unmount
                    resetShapeFlag(vnode);
                    // but invoke its deactivated hook here
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return () => {
            pendingCacheKey = null;
            if (!slots.default) {
                return null;
            }
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                if ((true)) {
                    warn(`KeepAlive should contain exactly one component child.`);
                }
                current = null;
                return children;
            }
            else if (!isVNode(rawVNode) ||
                (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&
                    !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            // for async components, name check should be based in its loaded
            // inner component if available
            const name = getComponentName(isAsyncWrapper(vnode)
                ? vnode.type.__asyncResolved || {}
                : comp);
            const { include, exclude, max } = props;
            if ((include && (!name || !matches(include, name))) ||
                (exclude && name && matches(exclude, name))) {
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            // clone vnode if it's reused because we are going to mutate it
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {
                    rawVNode.ssContent = vnode;
                }
            }
            // #1513 it's possible for the returned vnode to be cloned due to attr
            // fallthrough or scopeId, so the vnode here may not be the final vnode
            // that is mounted. Instead of caching it directly, we store the pending
            // key and cache `instance.subTree` (the normalized vnode) in
            // beforeMount/beforeUpdate hooks.
            pendingCacheKey = key;
            if (cachedVNode) {
                // copy over mounted state
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) {
                    // recursively update transition hooks on subTree
                    setTransitionHooks(vnode, vnode.transition);
                }
                // avoid vnode being mounted as fresh
                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;
                // make this key the freshest
                keys.delete(key);
                keys.add(key);
            }
            else {
                keys.add(key);
                // prune oldest entry
                if (max && keys.size > parseInt(max, 10)) {
                    pruneCacheEntry(keys.values().next().value);
                }
            }
            // avoid vnode being unmounted
            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
            current = vnode;
            return rawVNode;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {
        return pattern.some((p) => matches(p, name));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {
        return pattern.split(',').indexOf(name) > -1;
    }
    else if (pattern.test) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    // cache the deactivate branch check wrapper for injected hooks so the same
    // hook can be properly deduped by the scheduler. "__wdc" stands for "with
    // deactivation check".
    const wrappedHook = hook.__wdc ||
        (hook.__wdc = () => {
            // only fire the hook if the target instance is NOT in a deactivated branch.
            let current = target;
            while (current) {
                if (current.isDeactivated) {
                    return;
                }
                current = current.parent;
            }
            hook();
        });
    injectHook(type, wrappedHook, target);
    // In addition to registering it on the target instance, we walk up the parent
    // chain and register it on all ancestor instances that are keep-alive roots.
    // This avoids the need to walk the entire component tree when invoking these
    // hooks, and more importantly, avoids the need to track child components in
    // arrays.
    if (target) {
        let current = target.parent;
        while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
                injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    // injectHook wraps the original for error handling, so make sure to remove
    // the wrapped version.
    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);
    onUnmounted(() => {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    let shapeFlag = vnode.shapeFlag;
    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
        shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
    }
    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
        shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;
    }
    vnode.shapeFlag = shapeFlag;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        // cache the error handling wrapper for injected hooks so the same hook
        // can be properly deduped by the scheduler. "__weh" stands for "with error
        // handling".
        const wrappedHook = hook.__weh ||
            (hook.__weh = (...args) => {
                if (target.isUnmounted) {
                    return;
                }
                // disable tracking inside all lifecycle hooks
                // since they can potentially be called inside effects.
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
                // Set currentInstance during hook invocation.
                // This assumes the hook does not synchronously trigger other hooks, which
                // can only be false when the user does something really funky.
                setCurrentInstance(target);
                const res = callWithAsyncErrorHandling(hook, target, type, args);
                setCurrentInstance(null);
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
                return res;
            });
        if (prepend) {
            hooks.unshift(wrappedHook);
        }
        else {
            hooks.push(wrappedHook);
        }
        return wrappedHook;
    }
    else if ((true)) {
        const apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ''));
        warn(`${apiName} is called when there is no active component instance to be ` +
            `associated with. ` +
            `Lifecycle injection APIs can only be used during execution of setup().` +
            (` If you are using async setup(), make sure to register lifecycle ` +
                    `hooks before the first await statement.`
                ));
    }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => 
// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
(!isInSSRComponentSetup || lifecycle === "sp" /* SERVER_PREFETCH */) &&
    injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);
const onMounted = createHook("m" /* MOUNTED */);
const onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);
const onUpdated = createHook("u" /* UPDATED */);
const onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);
const onUnmounted = createHook("um" /* UNMOUNTED */);
const onServerPrefetch = createHook("sp" /* SERVER_PREFETCH */);
const onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);
const onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec" /* ERROR_CAPTURED */, hook, target);
}

function createDuplicateChecker() {
    const cache = Object.create(null);
    return (type, key) => {
        if (cache[key]) {
            warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
        }
        else {
            cache[key] = type;
        }
    };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    // do not cache property access on public proxy during state initialization
    shouldCacheAccess = false;
    // call beforeCreate first before accessing other options since
    // the hook may mutate resolved options (#2791)
    if (options.beforeCreate) {
        callHook(options.beforeCreate, instance, "bc" /* BEFORE_CREATE */);
    }
    const { 
    // state
    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, 
    // lifecycle
    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, 
    // public API
    expose, inheritAttrs, 
    // assets
    components, directives, filters } = options;
    const checkDuplicateProperties = ( true) ? createDuplicateChecker() : 0;
    if ((true)) {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) {
            for (const key in propsOptions) {
                checkDuplicateProperties("Props" /* PROPS */, key);
            }
        }
    }
    // options initialization order (to be consistent with Vue 2):
    // - props (already done outside of this function)
    // - inject
    // - methods
    // - data (deferred since it relies on `this` access)
    // - computed
    // - watch (deferred since it relies on `this` access)
    if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
        for (const key in methods) {
            const methodHandler = methods[key];
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {
                // In dev mode, we use the `createRenderContext` function to define methods to the proxy target,
                // and those are read-only but reconfigurable, so it needs to be redefined here
                if ((true)) {
                    Object.defineProperty(ctx, key, {
                        value: methodHandler.bind(publicThis),
                        configurable: true,
                        enumerable: true,
                        writable: true
                    });
                }
                else {}
                if ((true)) {
                    checkDuplicateProperties("Methods" /* METHODS */, key);
                }
            }
            else if ((true)) {
                warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +
                    `Did you reference the function correctly?`);
            }
        }
    }
    if (dataOptions) {
        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {
            warn(`The data option must be a function. ` +
                `Plain object usage is no longer supported.`);
        }
        const data = dataOptions.call(publicThis, publicThis);
        if (( true) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {
            warn(`data() returned a Promise - note data() cannot be async; If you ` +
                `intend to perform data fetching before component renders, use ` +
                `async setup() + <Suspense>.`);
        }
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {
            ( true) && warn(`data() should return an object.`);
        }
        else {
            instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);
            if ((true)) {
                for (const key in data) {
                    checkDuplicateProperties("Data" /* DATA */, key);
                    // expose data on ctx during dev
                    if (key[0] !== '$' && key[0] !== '_') {
                        Object.defineProperty(ctx, key, {
                            configurable: true,
                            enumerable: true,
                            get: () => data[key],
                            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
                        });
                    }
                }
            }
        }
    }
    // state initialization complete at this point - start caching access
    shouldCacheAccess = true;
    if (computedOptions) {
        for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)
                ? opt.bind(publicThis, publicThis)
                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get)
                    ? opt.get.bind(publicThis, publicThis)
                    : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            if (( true) && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
                warn(`Computed property "${key}" has no getter.`);
            }
            const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set)
                ? opt.set.bind(publicThis)
                : ( true)
                    ? () => {
                        warn(`Write operation failed: computed property "${key}" is readonly.`);
                    }
                    : 0;
            const c = computed({
                get,
                set
            });
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => c.value,
                set: v => (c.value = v)
            });
            if ((true)) {
                checkDuplicateProperties("Computed" /* COMPUTED */, key);
            }
        }
    }
    if (watchOptions) {
        for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
        }
    }
    if (provideOptions) {
        const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions)
            ? provideOptions.call(publicThis)
            : provideOptions;
        Reflect.ownKeys(provides).forEach(key => {
            provide(key, provides[key]);
        });
    }
    if (created) {
        callHook(created, instance, "c" /* CREATED */);
    }
    function registerLifecycleHook(register, hook) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
            hook.forEach(_hook => register(_hook.bind(publicThis)));
        }
        else if (hook) {
            register(hook.bind(publicThis));
        }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach(key => {
                Object.defineProperty(exposed, key, {
                    get: () => publicThis[key],
                    set: val => (publicThis[key] = val)
                });
            });
        }
        else if (!instance.exposed) {
            instance.exposed = {};
        }
    }
    // options that are handled when creating the instance but also need to be
    // applied from mixins
    if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
        instance.render = render;
    }
    if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
    }
    // asset options.
    if (components)
        instance.components = components;
    if (directives)
        instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
        const opt = injectOptions[key];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {
            if ('default' in opt) {
                ctx[key] = inject(opt.from || key, opt.default, true /* treat default function as factory */);
            }
            else {
                ctx[key] = inject(opt.from || key);
            }
        }
        else {
            ctx[key] = inject(opt);
        }
        if ((true)) {
            checkDuplicateProperties("Inject" /* INJECT */, key);
        }
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)
        ? hook.map(h => h.bind(instance.proxy))
        : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes('.')
        ? createPathGetter(publicThis, key)
        : () => publicThis[key];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {
        const handler = ctx[raw];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
            watch(getter, handler);
        }
        else if ((true)) {
            warn(`Invalid watch handler specified by key "${raw}"`, handler);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {
        watch(getter, raw.bind(publicThis));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
            raw.forEach(r => createWatcher(r, ctx, publicThis, key));
        }
        else {
            const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler)
                ? raw.handler.bind(publicThis)
                : ctx[raw.handler];
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
                watch(getter, handler, raw);
            }
            else if ((true)) {
                warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
            }
        }
    }
    else if ((true)) {
        warn(`Invalid watch option: "${key}"`, raw);
    }
}
/**
 * Resolve merged options and cache it on the component.
 * This is done only once per-component since the merging does not involve
 * instances.
 */
function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
        resolved = cached;
    }
    else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
            resolved = base;
        }
    }
    else {
        resolved = {};
        if (globalMixins.length) {
            globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));
        }
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    cache.set(base, resolved);
    return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
        mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
        mixins.forEach((m) => mergeOptions(to, m, strats, true));
    }
    for (const key in from) {
        if (asMixin && key === 'expose') {
            ( true) &&
                warn(`"expose" option is ignored when declared in mixins or extends. ` +
                    `It should only be declared in the base component itself.`);
        }
        else {
            const strat = internalOptionMergeStrats[key] || (strats && strats[key]);
            to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
    }
    return to;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeObjectOptions,
    emits: mergeObjectOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    destroyed: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
function mergeDataFn(to, from) {
    if (!from) {
        return to;
    }
    if (!to) {
        return from;
    }
    return function mergedDataFn() {
        return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend))((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from);
    };
}
function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
            res[raw[i]] = raw[i];
        }
        return res;
    }
    return raw;
}
function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
    return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
    if (!to)
        return from;
    if (!from)
        return to;
    const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to);
    for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
}

function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison
isSSR = false) {
    const props = {};
    const attrs = {};
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(attrs, InternalObjectKey, 1);
    instance.propsDefaults = Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    // ensure all declared prop keys are present
    for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
            props[key] = undefined;
        }
    }
    // validation
    if ((true)) {
        validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
        // stateful
        instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);
    }
    else {
        if (!instance.type.props) {
            // functional w/ optional props, props === attrs
            instance.props = attrs;
        }
        else {
            // functional w/ declared props
            instance.props = props;
        }
    }
    instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(( true) &&
        (instance.type.__hmrId ||
            (instance.parent && instance.parent.type.__hmrId))) &&
        (optimized || patchFlag > 0) &&
        !(patchFlag & 16 /* FULL_PROPS */)) {
        if (patchFlag & 8 /* PROPS */) {
            // Compiler-generated props & no keys change, just set the updated
            // the props.
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
                let key = propsToUpdate[i];
                // PROPS flag guarantees rawProps to be non-null
                const value = rawProps[key];
                if (options) {
                    // attr / props separation was done on init and will be consistent
                    // in this code path, so just check if attrs have it.
                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {
                        if (value !== attrs[key]) {
                            attrs[key] = value;
                            hasAttrsChanged = true;
                        }
                    }
                    else {
                        const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);
                    }
                }
                else {
                    if (value !== attrs[key]) {
                        attrs[key] = value;
                        hasAttrsChanged = true;
                    }
                }
            }
        }
    }
    else {
        // full props update.
        if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
        }
        // in case of dynamic props, check if we need to delete keys from
        // the props object
        let kebabKey;
        for (const key in rawCurrentProps) {
            if (!rawProps ||
                // for camelCase
                (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) &&
                    // it's possible the original props was passed in as kebab-case
                    // and converted to camelCase (#955)
                    ((kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey)))) {
                if (options) {
                    if (rawPrevProps &&
                        // for camelCase
                        (rawPrevProps[key] !== undefined ||
                            // for kebab-case
                            rawPrevProps[kebabKey] !== undefined)) {
                        props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);
                    }
                }
                else {
                    delete props[key];
                }
            }
        }
        // in the case of functional component w/o props declaration, props and
        // attrs point to the same object so it should already have been updated.
        if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
                if (!rawProps || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key)) {
                    delete attrs[key];
                    hasAttrsChanged = true;
                }
            }
        }
    }
    // trigger updates for $attrs in case it's used in component slots
    if (hasAttrsChanged) {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, "set" /* SET */, '$attrs');
    }
    if ((true)) {
        validateProps(rawProps || {}, props, instance);
    }
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
        for (let key in rawProps) {
            // key, ref are reserved and never passed down
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
                continue;
            }
            const value = rawProps[key];
            // prop option names are camelized during normalization, so to support
            // kebab -> camel conversion here we need to camelize the key.
            let camelKey;
            if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key)))) {
                if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                    props[camelKey] = value;
                }
                else {
                    (rawCastValues || (rawCastValues = {}))[camelKey] = value;
                }
            }
            else if (!isEmitListener(instance.emitsOptions, key)) {
                if (value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                }
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
        const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, key));
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, 'default');
        // default values
        if (hasDefault && value === undefined) {
            const defaultValue = opt.default;
            if (opt.type !== Function && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {
                const { propsDefaults } = instance;
                if (key in propsDefaults) {
                    value = propsDefaults[key];
                }
                else {
                    setCurrentInstance(instance);
                    value = propsDefaults[key] = defaultValue.call(null, props);
                    setCurrentInstance(null);
                }
            }
            else {
                value = defaultValue;
            }
        }
        // boolean casting
        if (opt[0 /* shouldCast */]) {
            if (isAbsent && !hasDefault) {
                value = false;
            }
            else if (opt[1 /* shouldCastTrue */] &&
                (value === '' || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {
                value = true;
            }
        }
    }
    return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
        return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    // apply mixin/extends props
    let hasExtends = false;
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        const extendProps = (raw) => {
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw, appContext, true);
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);
            if (keys)
                needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
            extendProps(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendProps);
        }
    }
    if (!raw && !hasExtends) {
        cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);
        return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
        for (let i = 0; i < raw.length; i++) {
            if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {
                warn(`props must be strings when using array syntax.`, raw[i]);
            }
            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);
            if (validatePropName(normalizedKey)) {
                normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
            }
        }
    }
    else if (raw) {
        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
            warn(`invalid props options`, raw);
        }
        for (const key in raw) {
            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = (normalized[normalizedKey] =
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? { type: opt } : opt);
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */] =
                        stringIndex < 0 || booleanIndex < stringIndex;
                    // if the prop needs boolean casting or default value
                    if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, 'default')) {
                        needCastKeys.push(normalizedKey);
                    }
                }
            }
        }
    }
    const res = [normalized, needCastKeys];
    cache.set(comp, res);
    return res;
}
function validatePropName(key) {
    if (key[0] !== '$') {
        return true;
    }
    else if ((true)) {
        warn(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
}
// use function string name to check type constructors
// so that it works across vms / iframes.
function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expectedTypes)) {
        return expectedTypes.findIndex(t => isSameType(t, type));
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
}
/**
 * dev only
 */
function validateProps(rawProps, props, instance) {
    const resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const options = instance.propsOptions[0];
    for (const key in options) {
        let opt = options[key];
        if (opt == null)
            continue;
        validateProp(key, resolvedValues[key], opt, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)));
    }
}
/**
 * dev only
 */
function validateProp(name, value, prop, isAbsent) {
    const { type, required, validator } = prop;
    // required!
    if (required && isAbsent) {
        warn('Missing required prop: "' + name + '"');
        return;
    }
    // missing but optional
    if (value == null && !prop.required) {
        return;
    }
    // type check
    if (type != null && type !== true) {
        let isValid = false;
        const types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];
        const expectedTypes = [];
        // value is valid as long as one of the specified types match
        for (let i = 0; i < types.length && !isValid; i++) {
            const { valid, expectedType } = assertType(value, types[i]);
            expectedTypes.push(expectedType || '');
            isValid = valid;
        }
        if (!isValid) {
            warn(getInvalidTypeMessage(name, value, expectedTypes));
            return;
        }
    }
    // custom validator
    if (validator && !validator(value)) {
        warn('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
}
const isSimpleType = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('String,Number,Boolean,Function,Symbol,BigInt');
/**
 * dev only
 */
function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);
    }
    else if (expectedType === 'Array') {
        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);
    }
    else {
        valid = value instanceof type;
    }
    return {
        valid,
        expectedType
    };
}
/**
 * dev only
 */
function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}".` +
        ` Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(', ')}`;
    const expectedType = expectedTypes[0];
    const receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        !isBoolean(expectedType, receivedType)) {
        message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += `with value ${receivedValue}.`;
    }
    return message;
}
/**
 * dev only
 */
function styleValue(value, type) {
    if (type === 'String') {
        return `"${value}"`;
    }
    else if (type === 'Number') {
        return `${Number(value)}`;
    }
    else {
        return `${value}`;
    }
}
/**
 * dev only
 */
function isExplicable(type) {
    const explicitTypes = ['string', 'number', 'boolean'];
    return explicitTypes.some(elem => type.toLowerCase() === elem);
}
/**
 * dev only
 */
function isBoolean(...args) {
    return args.some(elem => elem.toLowerCase() === 'boolean');
}

const isInternalKey = (key) => key[0] === '_' || key === '$stable';
const normalizeSlotValue = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)
    ? value.map(normalizeVNode)
    : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
    const normalized = withCtx((props) => {
        if (( true) && currentInstance) {
            warn(`Slot "${key}" invoked outside of the render function: ` +
                `this will not track dependencies used in the slot. ` +
                `Invoke the slot function inside the render function instead.`);
        }
        return normalizeSlotValue(rawSlot(props));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
        if (isInternalKey(key))
            continue;
        const value = rawSlots[key];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
        }
        else if (value != null) {
            if (true) {
                warn(`Non-function value encountered for slot "${key}". ` +
                    `Prefer function slots for better performance.`);
            }
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children) => {
    if (( true) &&
        !isKeepAlive(instance.vnode) &&
        !(false )) {
        warn(`Non-function value encountered for default slot. ` +
            `Prefer function slots for better performance.`);
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // users can get the shallow readonly version of the slots object through `this.$slots`,
            // we should avoid the proxy object polluting the slots of the internal instance
            instance.slots = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(children);
            // make compiler marker non-enumerable
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(children, '_', type);
        }
        else {
            normalizeObjectSlots(children, (instance.slots = {}));
        }
    }
    else {
        instance.slots = {};
        if (children) {
            normalizeVNodeSlots(instance, children);
        }
    }
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // compiled slots.
            if (( true) && isHmrUpdating) {
                // Parent was HMR updated so slot content may have changed.
                // force update slots and mark instance for hmr as well
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
            }
            else if (optimized && type === 1 /* STABLE */) {
                // compiled AND stable.
                // no need to update, and skip stale slots removal.
                needDeletionCheck = false;
            }
            else {
                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
                // normalization.
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
                // #2893
                // when rendering the optimized slots by manually written render function,
                // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
                // i.e. let the `renderSlot` create the bailed Fragment
                if (!optimized && type === 1 /* STABLE */) {
                    delete slots._;
                }
            }
        }
        else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    }
    else if (children) {
        // non slot object children (direct value) passed to a component
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
    }
    // delete stale slots
    if (needDeletionCheck) {
        for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                delete slots[key];
            }
        }
    }
};

/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/
const isBuiltInDirective = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text');
function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
        warn('Do not use built-in directive ids as custom directive id: ' + name);
    }
}
/**
 * Adds directives to a VNode.
 */
function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        ( true) && warn(`withDirectives can only be used inside render functions.`);
        return vnode;
    }
    const instance = internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ] = directives[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {
            dir = {
                mounted: dir,
                updated: dir
            };
        }
        if (dir.deep) {
            traverse(value);
        }
        bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
        });
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
            // disable tracking inside all lifecycle hooks
            // since they can potentially be called inside effects.
            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        }
    }
}

function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: undefined,
            warnHandler: undefined,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap()
    };
}
let uid = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {
            ( true) && warn(`root props passed to app.mount() must be an object.`);
            rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = new Set();
        let isMounted = false;
        const app = (context.app = {
            _uid: uid++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
                return context.config;
            },
            set config(v) {
                if ((true)) {
                    warn(`app.config cannot be replaced. Modify individual options instead.`);
                }
            },
            use(plugin, ...options) {
                if (installedPlugins.has(plugin)) {
                    ( true) && warn(`Plugin has already been applied to target app.`);
                }
                else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                }
                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                }
                else if ((true)) {
                    warn(`A plugin must either be a function or an object with an "install" ` +
                        `function.`);
                }
                return app;
            },
            mixin(mixin) {
                if (true) {
                    if (!context.mixins.includes(mixin)) {
                        context.mixins.push(mixin);
                    }
                    else if ((true)) {
                        warn('Mixin has already been applied to target app' +
                            (mixin.name ? `: ${mixin.name}` : ''));
                    }
                }
                else {}
                return app;
            },
            component(name, component) {
                if ((true)) {
                    validateComponentName(name, context.config);
                }
                if (!component) {
                    return context.components[name];
                }
                if (( true) && context.components[name]) {
                    warn(`Component "${name}" has already been registered in target app.`);
                }
                context.components[name] = component;
                return app;
            },
            directive(name, directive) {
                if ((true)) {
                    validateDirectiveName(name);
                }
                if (!directive) {
                    return context.directives[name];
                }
                if (( true) && context.directives[name]) {
                    warn(`Directive "${name}" has already been registered in target app.`);
                }
                context.directives[name] = directive;
                return app;
            },
            mount(rootContainer, isHydrate, isSVG) {
                if (!isMounted) {
                    const vnode = createVNode(rootComponent, rootProps);
                    // store app context on the root VNode.
                    // this will be set on the root instance on initial mount.
                    vnode.appContext = context;
                    // HMR root reload
                    if ((true)) {
                        context.reload = () => {
                            render(cloneVNode(vnode), rootContainer, isSVG);
                        };
                    }
                    if (isHydrate && hydrate) {
                        hydrate(vnode, rootContainer);
                    }
                    else {
                        render(vnode, rootContainer, isSVG);
                    }
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    if (true) {
                        app._instance = vnode.component;
                        devtoolsInitApp(app, version);
                    }
                    return vnode.component.proxy;
                }
                else if ((true)) {
                    warn(`App has already been mounted.\n` +
                        `If you want to remount the same app, move your app creation logic ` +
                        `into a factory function and create fresh app instances for each ` +
                        `mount - e.g. \`const createMyApp = () => createApp(App)\``);
                }
            },
            unmount() {
                if (isMounted) {
                    render(null, app._container);
                    if (true) {
                        app._instance = null;
                        devtoolsUnmountApp(app);
                    }
                    delete app._container.__vue_app__;
                }
                else if ((true)) {
                    warn(`Cannot unmount an app that is not mounted.`);
                }
            },
            provide(key, value) {
                if (( true) && key in context.provides) {
                    warn(`App already provides property with key "${String(key)}". ` +
                        `It will be overwritten with the new value.`);
                }
                // TypeScript doesn't allow symbols as index type
                // https://github.com/Microsoft/TypeScript/issues/24587
                context.provides[key] = value;
                return app;
            }
        });
        return app;
    };
}

let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
const isComment = (node) => node.nodeType === 8 /* COMMENT */;
// Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container) => {
        if (!container.hasChildNodes()) {
            ( true) &&
                warn(`Attempting to hydrate existing markup but container is empty. ` +
                    `Performing full mount instead.`);
            patch(null, vnode, container);
            flushPostFlushCbs();
            return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        if (hasMismatch && !false) {
            // this error should show up in production
            console.error(`Hydration completed but contains mismatches.`);
        }
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
        const isFragmentStart = isComment(node) && node.data === '[';
        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
        const { type, ref, shapeFlag } = vnode;
        const domType = node.nodeType;
        vnode.el = node;
        let nextNode = null;
        switch (type) {
            case Text:
                if (domType !== 3 /* TEXT */) {
                    nextNode = onMismatch();
                }
                else {
                    if (node.data !== vnode.children) {
                        hasMismatch = true;
                        ( true) &&
                            warn(`Hydration text mismatch:` +
                                `\n- Client: ${JSON.stringify(node.data)}` +
                                `\n- Server: ${JSON.stringify(vnode.children)}`);
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment$1:
                if (domType !== 8 /* COMMENT */ || isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = nextSibling(node);
                }
                break;
            case Static:
                if (domType !== 1 /* ELEMENT */) {
                    nextNode = onMismatch();
                }
                else {
                    // determine anchor, adopt content
                    nextNode = node;
                    // if the static vnode has its content stripped during build,
                    // adopt it from the server-rendered HTML.
                    const needToAdoptContent = !vnode.children.length;
                    for (let i = 0; i < vnode.staticCount; i++) {
                        if (needToAdoptContent)
                            vnode.children += nextNode.outerHTML;
                        if (i === vnode.staticCount - 1) {
                            vnode.anchor = nextNode;
                        }
                        nextNode = nextSibling(nextNode);
                    }
                    return nextNode;
                }
                break;
            case Fragment:
                if (!isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                }
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    if (domType !== 1 /* ELEMENT */ ||
                        vnode.type.toLowerCase() !==
                            node.tagName.toLowerCase()) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                    }
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    // when setting up the render effect, if the initial vnode already
                    // has .el set, the component will perform hydration instead of mount
                    // on its sub-tree.
                    vnode.slotScopeIds = slotScopeIds;
                    const container = parentNode(node);
                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    // component may be async, so in the case of fragments we cannot rely
                    // on component's rendered output to determine the end of the fragment
                    // instead, we do a lookahead to find the end anchor node.
                    nextNode = isFragmentStart
                        ? locateClosingAsyncAnchor(node)
                        : nextSibling(node);
                    // #3787
                    // if component is async, it may get moved / unmounted before its
                    // inner component is loaded, so we need to give it a placeholder
                    // vnode that matches its adopted DOM.
                    if (isAsyncWrapper(vnode)) {
                        let subTree;
                        if (isFragmentStart) {
                            subTree = createVNode(Fragment);
                            subTree.anchor = nextNode
                                ? nextNode.previousSibling
                                : container.lastChild;
                        }
                        else {
                            subTree =
                                node.nodeType === 3 ? createTextVNode('') : createVNode('div');
                        }
                        subTree.el = node;
                        vnode.component.subTree = subTree;
                    }
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    if (domType !== 8 /* COMMENT */) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                    }
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                }
                else if ((true)) {
                    warn('Invalid HostVNode type:', type, `(${typeof type})`);
                }
        }
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode);
        }
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const { type, props, patchFlag, shapeFlag, dirs } = vnode;
        // #4006 for form elements with non-string v-model value bindings
        // e.g. <option :value="obj">, <input type="checkbox" :true-value="1">
        const forcePatchValue = (type === 'input' && dirs) || type === 'option';
        // skip props & children if this is hoisted static nodes
        if (forcePatchValue || patchFlag !== -1 /* HOISTED */) {
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                if (forcePatchValue ||
                    !optimized ||
                    (patchFlag & 16 /* FULL_PROPS */ ||
                        patchFlag & 32 /* HYDRATE_EVENTS */)) {
                    for (const key in props) {
                        if ((forcePatchValue && key.endsWith('value')) ||
                            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))) {
                            patchProp(el, key, null, props[key]);
                        }
                    }
                }
                else if (props.onClick) {
                    // Fast path for click listeners (which is most often) to avoid
                    // iterating through props.
                    patchProp(el, 'onClick', null, props.onClick);
                }
            }
            // vnode / directive hooks
            let vnodeHooks;
            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
            }
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
                queueEffectWithSuspense(() => {
                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
                }, parentSuspense);
            }
            // children
            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&
                // skip if element has innerHTML / textContent
                !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                let hasWarned = false;
                while (next) {
                    hasMismatch = true;
                    if (( true) && !hasWarned) {
                        warn(`Hydration children mismatch in <${vnode.type}>: ` +
                            `server rendered element contains more child nodes than client vdom.`);
                        hasWarned = true;
                    }
                    // The SSRed DOM contains more nodes than it should. Remove them.
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            }
            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    ( true) &&
                        warn(`Hydration text content mismatch in <${vnode.type}>:\n` +
                            `- Client: ${el.textContent}\n` +
                            `- Server: ${vnode.children}`);
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned = false;
        for (let i = 0; i < l; i++) {
            const vnode = optimized
                ? children[i]
                : (children[i] = normalizeVNode(children[i]));
            if (node) {
                node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
            else if (vnode.type === Text && !vnode.children) {
                continue;
            }
            else {
                hasMismatch = true;
                if (( true) && !hasWarned) {
                    warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +
                        `server rendered element contains fewer child nodes than client vdom.`);
                    hasWarned = true;
                }
                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
        }
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === ']') {
            return nextSibling((vnode.anchor = next));
        }
        else {
            // fragment didn't hydrate successfully, since we didn't get a end anchor
            // back. This should have led to node/children mismatch warnings.
            hasMismatch = true;
            // since the anchor is missing, we need to create one and insert it
            insert((vnode.anchor = createComment(`]`)), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
        hasMismatch = true;
        ( true) &&
            warn(`Hydration node mismatch:\n- Client vnode:`, vnode.type, `\n- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */
                ? `(text)`
                : isComment(node) && node.data === '['
                    ? `(start of fragment)`
                    : ``);
        vnode.el = null;
        if (isFragment) {
            // remove excessive fragment nodes
            const end = locateClosingAsyncAnchor(node);
            while (true) {
                const next = nextSibling(node);
                if (next && next !== end) {
                    remove(next);
                }
                else {
                    break;
                }
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        return next;
    };
    const locateClosingAsyncAnchor = (node) => {
        let match = 0;
        while (node) {
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === '[')
                    match++;
                if (node.data === ']') {
                    if (match === 0) {
                        return nextSibling(node);
                    }
                    else {
                        match--;
                    }
                }
            }
        }
        return node;
    };
    return [hydrate, hydrateNode];
}

let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        perf.mark(`vue-${type}-${instance.uid}`);
    }
    if (true) {
        devtoolsPerfStart(instance, type, supported ? perf.now() : Date.now());
    }
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
    if (true) {
        devtoolsPerfEnd(instance, type, supported ? perf.now() : Date.now());
    }
}
function isSupported() {
    if (supported !== undefined) {
        return supported;
    }
    /* eslint-disable no-restricted-globals */
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    }
    else {
        supported = false;
    }
    /* eslint-enable no-restricted-globals */
    return supported;
}

/**
 * This is only called in esm-bundler builds.
 * It is called when a renderer is created, in `baseCreateRenderer` so that
 * importing runtime-core is side-effects free.
 *
 * istanbul-ignore-next
 */
function initFeatureFlags() {
    let needWarn = false;
    if (false) {}
    if (false) {}
    if (( true) && needWarn) {
        console.warn(`You are running the esm-bundler build of Vue. It is recommended to ` +
            `configure your bundler to explicitly replace feature flag globals ` +
            `with boolean literals to get proper tree-shaking in the final bundle. ` +
            `See http://link.vuejs.org/feature-flags for more details.`);
    }
}

const prodEffectOptions = {
    scheduler: queueJob,
    // #1801, #2043 component render effects should allow recursive updates
    allowRecurse: true
};
function createDevEffectOptions(instance) {
    return {
        scheduler: queueJob,
        allowRecurse: true,
        onTrack: instance.rtc ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e) : void 0,
        onTrigger: instance.rtg ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e) : void 0
    };
}
const queuePostRenderEffect = queueEffectWithSuspense
    ;
const setRef = (rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) => {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {
        rawRef.forEach((r, i) => setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
        // when mounting async components, nothing needs to be done,
        // because the template ref is forwarded to inner component
        return;
    }
    const refValue = vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */
        ? getExposeProxy(vnode.component) || vnode.component.proxy
        : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref } = rawRef;
    if (( true) && !owner) {
        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +
            `A vnode with ref must be created inside the render function.`);
        return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? (owner.refs = {}) : owner.refs;
    const setupState = owner.setupState;
    // dynamic ref changed. unset old ref
    if (oldRef != null && oldRef !== ref) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {
            refs[oldRef] = null;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, oldRef)) {
                setupState[oldRef] = null;
            }
        }
        else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {
            oldRef.value = null;
        }
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref)) {
        const doSet = () => {
            {
                refs[ref] = value;
            }
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {
                setupState[ref] = value;
            }
        };
        // #1789: for non-null values, set them after render
        // null values means this is unmount and it should not overwrite another
        // ref with the same key
        if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
        }
        else {
            doSet();
        }
    }
    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref)) {
        const doSet = () => {
            ref.value = value;
        };
        if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
        }
        else {
            doSet();
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {
        callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);
    }
    else if ((true)) {
        warn('Invalid template ref type:', value, `(${typeof value})`);
    }
};
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */
function createRenderer(options) {
    return baseCreateRenderer(options);
}
// Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
// implementation
function baseCreateRenderer(options, createHydrationFns) {
    // compile-time feature flags check
    {
        initFeatureFlags();
    }
    if (true) {
        const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
        target.__VUE__ = true;
        setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);
    }
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, forcePatchProp: hostForcePatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
    // Note: functions inside this closure should use `const xxx = () => {}`
    // style in order to prevent being inlined by minifiers.
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = ( true) && isHmrUpdating ? false : !!n2.dynamicChildren) => {
        // patching & not same type, unmount old tree
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2 /* BAIL */) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch (type) {
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment$1:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) {
                    mountStaticNode(n2, container, anchor, isSVG);
                }
                else if ((true)) {
                    patchStaticNode(n1, n2, container, isSVG);
                }
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                }
                else if ((true)) {
                    warn('Invalid VNode type:', type, `(${typeof type})`);
                }
        }
        // set ref
        if (ref != null && parentComponent) {
            setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
    };
    const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
        }
        else {
            const el = (n2.el = n1.el);
            if (n2.children !== n1.children) {
                hostSetText(el, n2.children);
            }
        }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);
        }
        else {
            // there's no support for dynamic comments
            n2.el = n1.el;
        }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    };
    /**
     * Dev / HMR only
     */
    const patchStaticNode = (n1, n2, container, isSVG) => {
        // static nodes are only patched during dev for HMR
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            // remove existing
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        }
        else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        isSVG = isSVG || n2.type === 'svg';
        if (n1 == null) {
            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        else {
            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
        if (false /* HOISTED */) {}
        else {
            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
            // mount children first, since some props may rely on child content
            // being already rendered, e.g. `<select value>`
            if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                hostSetElementText(el, vnode.children);
            }
            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                for (const key in props) {
                    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
                if ((vnodeHook = props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parentComponent, vnode);
                }
            }
            // scopeId
            setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        }
        if (true) {
            Object.defineProperty(el, '__vnode', {
                value: vnode,
                enumerable: false
            });
            Object.defineProperty(el, '__vueParentComponent', {
                value: parentComponent,
                enumerable: false
            });
        }
        if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
        }
        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
        // #1689 For inside suspense + suspense resolved case, just call it
        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&
            transition &&
            !transition.persisted;
        if (needCallTransitionHooks) {
            transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) ||
            needCallTransitionHooks ||
            dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                needCallTransitionHooks && transition.enter(el);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
            }, parentSuspense);
        }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
            hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
            for (let i = 0; i < slotScopeIds.length; i++) {
                hostSetScopeId(el, slotScopeIds[i]);
            }
        }
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (( true) &&
                subTree.patchFlag > 0 &&
                subTree.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
                subTree =
                    filterSingleRoot(subTree.children) || subTree;
            }
            if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
            const child = (children[i] = optimized
                ? cloneIfMounted(children[i])
                : normalizeVNode(children[i]));
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const el = (n2.el = n1.el);
        let { patchFlag, dynamicChildren, dirs } = n2;
        // #1426 take the old vnode's patch flag into account since user may clone a
        // compiler-generated vnode, which de-opts to FULL_PROPS
        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;
        const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        let vnodeHook;
        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
        }
        if (( true) && isHmrUpdating) {
            // HMR updated, force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        if (patchFlag > 0) {
            // the presence of a patchFlag means this element's render code was
            // generated by the compiler and can take the fast path.
            // in this path old node and new node are guaranteed to have the same shape
            // (i.e. at the exact same position in the source template)
            if (patchFlag & 16 /* FULL_PROPS */) {
                // element props contain dynamic keys, full diff needed
                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            }
            else {
                // class
                // this flag is matched when the element has dynamic class bindings.
                if (patchFlag & 2 /* CLASS */) {
                    if (oldProps.class !== newProps.class) {
                        hostPatchProp(el, 'class', null, newProps.class, isSVG);
                    }
                }
                // style
                // this flag is matched when the element has dynamic style bindings
                if (patchFlag & 4 /* STYLE */) {
                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
                }
                // props
                // This flag is matched when the element has dynamic prop/attr bindings
                // other than class and style. The keys of dynamic prop/attrs are saved for
                // faster iteration.
                // Note dynamic keys like :[foo]="bar" will cause this optimization to
                // bail out and go through a full diff because we need to unset the old key
                if (patchFlag & 8 /* PROPS */) {
                    // if the flag is present then dynamicProps must be non-null
                    const propsToUpdate = n2.dynamicProps;
                    for (let i = 0; i < propsToUpdate.length; i++) {
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        if (next !== prev ||
                            (hostForcePatchProp && hostForcePatchProp(el, key))) {
                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                        }
                    }
                }
            }
            // text
            // This flag is matched when the element has only dynamic text children.
            if (patchFlag & 1 /* TEXT */) {
                if (n1.children !== n2.children) {
                    hostSetElementText(el, n2.children);
                }
            }
        }
        else if (!optimized && dynamicChildren == null) {
            // unoptimized, full diff
            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        }
        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
            if (( true) && parentComponent && parentComponent.type.__hmrId) {
                traverseStaticChildren(n1, n2);
            }
        }
        else if (!optimized) {
            // full diff
            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
            }, parentSuspense);
        }
    };
    // The fast path for blocks.
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            // Determine the container (parent element) for the patch.
            const container = 
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el &&
                // - In the case of a Fragment, we need to provide the actual parent
                // of the Fragment itself so it can move its children.
                (oldVNode.type === Fragment ||
                    // - In the case of different nodes, there is going to be a replacement
                    // which also requires the correct parent container
                    !isSameVNodeType(oldVNode, newVNode) ||
                    // - In the case of a component, it could contain anything.
                    oldVNode.shapeFlag & 6 /* COMPONENT */ ||
                    oldVNode.shapeFlag & 64 /* TELEPORT */)
                ? hostParentNode(oldVNode.el)
                : // In other cases, the parent container is not actually used so we
                    // just pass the block element here to avoid a DOM parentNode call.
                    fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
        if (oldProps !== newProps) {
            for (const key in newProps) {
                // empty string is not valid prop
                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))
                    continue;
                const next = newProps[key];
                const prev = oldProps[key];
                if (next !== prev ||
                    (hostForcePatchProp && hostForcePatchProp(el, key))) {
                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                }
            }
            if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
                for (const key in oldProps) {
                    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && !(key in newProps)) {
                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));
        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (dynamicChildren) {
            optimized = true;
        }
        // check if this is a slot fragment with :slotted scope ids
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
        }
        if (( true) && isHmrUpdating) {
            // HMR updated, force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            // a fragment can only have array children
            // since they are either generated by the compiler, or implicitly created
            // from arrays.
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        else {
            if (patchFlag > 0 &&
                patchFlag & 64 /* STABLE_FRAGMENT */ &&
                dynamicChildren &&
                // #2715 the previous fragment could've been a BAILed one as a result
                // of renderSlot() with no valid children
                n1.dynamicChildren) {
                // a stable fragment (template root or <template v-for>) doesn't need to
                // patch children order, but it may contain dynamicChildren.
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
                if (( true) && parentComponent && parentComponent.type.__hmrId) {
                    traverseStaticChildren(n1, n2);
                }
                else if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null ||
                    (parentComponent && n2 === parentComponent.subTree)) {
                    traverseStaticChildren(n1, n2, true /* shallow */);
                }
            }
            else {
                // keyed / unkeyed, or manual fragments.
                // for keyed & unkeyed, since they are compiler generated from v-for,
                // each child is guaranteed to be a block so the fragment will never
                // have dynamicChildren.
                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
        }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            }
            else {
                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
            }
        }
        else {
            updateComponent(n1, n2, optimized);
        }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));
        if (( true) && instance.type.__hmrId) {
            registerHMR(instance);
        }
        if ((true)) {
            pushWarningContext(initialVNode);
            startMeasure(instance, `mount`);
        }
        // inject renderer internals for keepAlive
        if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
        }
        // resolve props and slots for setup context
        {
            if ((true)) {
                startMeasure(instance, `init`);
            }
            setupComponent(instance);
            if ((true)) {
                endMeasure(instance, `init`);
            }
        }
        // setup() is async. This component relies on async logic to be resolved
        // before proceeding
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            // Give it a placeholder if this is not hydration
            // TODO handle self-defined fallback
            if (!initialVNode.el) {
                const placeholder = (instance.subTree = createVNode(Comment$1));
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        if ((true)) {
            popWarningContext();
            endMeasure(instance, `mount`);
        }
    };
    const updateComponent = (n1, n2, optimized) => {
        const instance = (n2.component = n1.component);
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep &&
                !instance.asyncResolved) {
                // async & still pending - just update props and slots
                // since the component's reactive effect for render isn't set-up yet
                if ((true)) {
                    pushWarningContext(n2);
                }
                updateComponentPreRender(instance, n2, optimized);
                if ((true)) {
                    popWarningContext();
                }
                return;
            }
            else {
                // normal update
                instance.next = n2;
                // in case the child component is also queued, remove it to avoid
                // double updating the same child component in the same flush.
                invalidateJob(instance.update);
                // instance.update is the reactive effect runner.
                instance.update();
            }
        }
        else {
            // no update needed. just copy over properties
            n2.component = n1.component;
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
        // create reactive effect for rendering
        instance.update = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect)(function componentEffect() {
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, parent } = instance;
                // beforeMount hook
                if (bm) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);
                }
                // onVnodeBeforeMount
                if ((vnodeHook = props && props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parent, initialVNode);
                }
                if (el && hydrateNode) {
                    // vnode has adopted host node - perform hydration instead of mount.
                    const hydrateSubTree = () => {
                        if ((true)) {
                            startMeasure(instance, `render`);
                        }
                        instance.subTree = renderComponentRoot(instance);
                        if ((true)) {
                            endMeasure(instance, `render`);
                        }
                        if ((true)) {
                            startMeasure(instance, `hydrate`);
                        }
                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                        if ((true)) {
                            endMeasure(instance, `hydrate`);
                        }
                    };
                    if (isAsyncWrapper(initialVNode)) {
                        initialVNode.type.__asyncLoader().then(
                        // note: we are moving the render call into an async callback,
                        // which means it won't track dependencies - but it's ok because
                        // a server-rendered async wrapper is already in resolved state
                        // and it will never need to change.
                        () => !instance.isUnmounted && hydrateSubTree());
                    }
                    else {
                        hydrateSubTree();
                    }
                }
                else {
                    if ((true)) {
                        startMeasure(instance, `render`);
                    }
                    const subTree = (instance.subTree = renderComponentRoot(instance));
                    if ((true)) {
                        endMeasure(instance, `render`);
                    }
                    if ((true)) {
                        startMeasure(instance, `patch`);
                    }
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    if ((true)) {
                        endMeasure(instance, `patch`);
                    }
                    initialVNode.el = subTree.el;
                }
                // mounted hook
                if (m) {
                    queuePostRenderEffect(m, parentSuspense);
                }
                // onVnodeMounted
                if ((vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                }
                // activated hook for keep-alive roots.
                // #1742 activated hook must be accessed after first render
                // since the hook may be injected by a child keep-alive
                if (initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
                    instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                }
                instance.isMounted = true;
                if (true) {
                    devtoolsComponentAdded(instance);
                }
                // #2458: deference mount-only object parameters to prevent memleaks
                initialVNode = container = anchor = null;
            }
            else {
                // updateComponent
                // This is triggered by mutation of component's own state (next: null)
                // OR parent calling processComponent (next: VNode)
                let { next, bu, u, parent, vnode } = instance;
                let originNext = next;
                let vnodeHook;
                if ((true)) {
                    pushWarningContext(next || instance.vnode);
                }
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                }
                else {
                    next = vnode;
                }
                // beforeUpdate hook
                if (bu) {
                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);
                }
                // onVnodeBeforeUpdate
                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
                    invokeVNodeHook(vnodeHook, parent, next, vnode);
                }
                // render
                if ((true)) {
                    startMeasure(instance, `render`);
                }
                const nextTree = renderComponentRoot(instance);
                if ((true)) {
                    endMeasure(instance, `render`);
                }
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                if ((true)) {
                    startMeasure(instance, `patch`);
                }
                patch(prevTree, nextTree, 
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), 
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                if ((true)) {
                    endMeasure(instance, `patch`);
                }
                next.el = nextTree.el;
                if (originNext === null) {
                    // self-triggered update. In case of HOC, update parent component
                    // vnode el. HOC is indicated by parent instance's subTree pointing
                    // to child component's vnode
                    updateHOCHostEl(instance, nextTree.el);
                }
                // updated hook
                if (u) {
                    queuePostRenderEffect(u, parentSuspense);
                }
                // onVnodeUpdated
                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                }
                if (true) {
                    devtoolsComponentUpdated(instance);
                }
                if ((true)) {
                    popWarningContext();
                }
            }
        }, ( true) ? createDevEffectOptions(instance) : 0);
        if ((true)) {
            // @ts-ignore
            instance.update.ownerInstance = instance;
        }
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        // props update may have triggered pre-flush watchers.
        // flush them before the render update.
        flushPreFlushCbs(undefined, instance.update);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        // fast path
        if (patchFlag > 0) {
            if (patchFlag & 128 /* KEYED_FRAGMENT */) {
                // this could be either fully-keyed or mixed (some keyed some not)
                // presence of patchFlag means children are guaranteed to be arrays
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
                // unkeyed
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
        }
        // children has 3 possibilities: text, array or no children.
        if (shapeFlag & 8 /* TEXT_CHILDREN */) {
            // text children fast path
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
                hostSetElementText(container, c2);
            }
        }
        else {
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                // prev children was array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    // two arrays, cannot assume anything, do full diff
                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else {
                    // no new children, just unmount old
                    unmountChildren(c1, parentComponent, parentSuspense, true);
                }
            }
            else {
                // prev children was text OR null
                // new children is array OR null
                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
                    hostSetElementText(container, '');
                }
                // mount new if array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
            }
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
        c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
            const nextChild = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        if (oldLength > newLength) {
            // remove old
            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        }
        else {
            // mount new
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
        }
    };
    // can be all-keyed or mixed
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1; // prev ending index
        let e2 = l2 - 1; // next ending index
        // 1. sync from start
        // (a b) c
        // (a b) d e
        while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
            else {
                break;
            }
            i++;
        }
        // 2. sync from end
        // a (b c)
        // d e (b c)
        while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = (c2[e2] = optimized
                ? cloneIfMounted(c2[e2])
                : normalizeVNode(c2[e2]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
            else {
                break;
            }
            e1--;
            e2--;
        }
        // 3. common sequence + mount
        // (a b)
        // (a b) c
        // i = 2, e1 = 1, e2 = 2
        // (a b)
        // c (a b)
        // i = 0, e1 = -1, e2 = 0
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while (i <= e2) {
                    patch(null, (c2[i] = optimized
                        ? cloneIfMounted(c2[i])
                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    i++;
                }
            }
        }
        // 4. common sequence + unmount
        // (a b) c
        // (a b)
        // i = 2, e1 = 2, e2 = 1
        // a (b c)
        // (b c)
        // i = 0, e1 = 0, e2 = -1
        else if (i > e2) {
            while (i <= e1) {
                unmount(c1[i], parentComponent, parentSuspense, true);
                i++;
            }
        }
        // 5. unknown sequence
        // [i ... e1 + 1]: a b [c d e] f g
        // [i ... e2 + 1]: a b [e d c h] f g
        // i = 2, e1 = 4, e2 = 5
        else {
            const s1 = i; // prev starting index
            const s2 = i; // next starting index
            // 5.1 build key:index map for newChildren
            const keyToNewIndexMap = new Map();
            for (i = s2; i <= e2; i++) {
                const nextChild = (c2[i] = optimized
                    ? cloneIfMounted(c2[i])
                    : normalizeVNode(c2[i]));
                if (nextChild.key != null) {
                    if (( true) && keyToNewIndexMap.has(nextChild.key)) {
                        warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                    }
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            // 5.2 loop through old children left to be patched and try to patch
            // matching nodes & remove nodes that are no longer present
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            // used to track whether any node has moved
            let maxNewIndexSoFar = 0;
            // works as Map<newIndex, oldIndex>
            // Note that oldIndex is offset by +1
            // and oldIndex = 0 is a special value indicating the new node has
            // no corresponding old node.
            // used for determining longest stable subsequence
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++)
                newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    // all new children have been patched so this can only be a removal
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) {
                    newIndex = keyToNewIndexMap.get(prevChild.key);
                }
                else {
                    // key-less node, try to locate a key-less node of the same type
                    for (j = s2; j <= e2; j++) {
                        if (newIndexToOldIndexMap[j - s2] === 0 &&
                            isSameVNodeType(prevChild, c2[j])) {
                            newIndex = j;
                            break;
                        }
                    }
                }
                if (newIndex === undefined) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                }
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) {
                        maxNewIndexSoFar = newIndex;
                    }
                    else {
                        moved = true;
                    }
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    patched++;
                }
            }
            // 5.3 move and mount
            // generate longest stable subsequence only when nodes have moved
            const increasingNewIndexSequence = moved
                ? getSequence(newIndexToOldIndexMap)
                : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            // looping backwards so that we can use last patched node as anchor
            for (i = toBePatched - 1; i >= 0; i--) {
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) {
                    // mount new
                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (moved) {
                    // move if:
                    // There is no stable subsequence (e.g. a reverse)
                    // OR current node is not among the stable sequence
                    if (j < 0 || i !== increasingNewIndexSequence[j]) {
                        move(nextChild, container, anchor, 2 /* REORDER */);
                    }
                    else {
                        j--;
                    }
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6 /* COMPONENT */) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128 /* SUSPENSE */) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64 /* TELEPORT */) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        // single nodes
        const needTransition = moveType !== 2 /* REORDER */ &&
            shapeFlag & 1 /* ELEMENT */ &&
            transition;
        if (needTransition) {
            if (moveType === 0 /* ENTER */) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            }
            else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove = () => hostInsert(el, container, anchor);
                const performLeave = () => {
                    leave(el, () => {
                        remove();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) {
                    delayLeave(el, remove, performLeave);
                }
                else {
                    performLeave();
                }
            }
        }
        else {
            hostInsert(el, container, anchor);
        }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        // unset ref
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;
        let vnodeHook;
        if ((vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6 /* COMPONENT */) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
        }
        else {
            if (shapeFlag & 128 /* SUSPENSE */) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
            }
            if (shapeFlag & 64 /* TELEPORT */) {
                vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
            }
            else if (dynamicChildren &&
                // #1153: fast path should not be taken for non-stable (v-for) fragments
                (type !== Fragment ||
                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {
                // fast path for block nodes: only need to unmount dynamic children.
                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            }
            else if ((type === Fragment &&
                (patchFlag & 128 /* KEYED_FRAGMENT */ ||
                    patchFlag & 256 /* UNKEYED_FRAGMENT */)) ||
                (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {
                unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
                remove(vnode);
            }
        }
        if ((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                shouldInvokeDirs &&
                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
            }, parentSuspense);
        }
    };
    const remove = vnode => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
            removeFragment(el, anchor);
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
                transition.afterLeave();
            }
        };
        if (vnode.shapeFlag & 1 /* ELEMENT */ &&
            transition &&
            !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
                delayLeave(vnode.el, performRemove, performLeave);
            }
            else {
                performLeave();
            }
        }
        else {
            performRemove();
        }
    };
    const removeFragment = (cur, end) => {
        // For fragments, directly remove all contained DOM nodes.
        // (fragment child nodes cannot have transition)
        let next;
        while (cur !== end) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
        if (( true) && instance.type.__hmrId) {
            unregisterHMR(instance);
        }
        const { bum, effects, update, subTree, um } = instance;
        // beforeUnmount hook
        if (bum) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);
        }
        if (effects) {
            for (let i = 0; i < effects.length; i++) {
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(effects[i]);
            }
        }
        // update may be null if a component is unmounted before its async
        // setup has resolved.
        if (update) {
            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(update);
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        // unmounted hook
        if (um) {
            queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
            instance.isUnmounted = true;
        }, parentSuspense);
        // A component with async dep inside a pending suspense is unmounted before
        // its async dep resolves. This should remove the dep from the suspense, and
        // cause the suspense to resolve immediately if that was the last dep.
        if (parentSuspense &&
            parentSuspense.pendingBranch &&
            !parentSuspense.isUnmounted &&
            instance.asyncDep &&
            !instance.asyncResolved &&
            instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
                parentSuspense.resolve();
            }
        }
        if (true) {
            devtoolsComponentRemoved(instance);
        }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
    };
    const getNextHostNode = vnode => {
        if (vnode.shapeFlag & 6 /* COMPONENT */) {
            return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128 /* SUSPENSE */) {
            return vnode.suspense.next();
        }
        return hostNextSibling((vnode.anchor || vnode.el));
    };
    const render = (vnode, container, isSVG) => {
        if (vnode == null) {
            if (container._vnode) {
                unmount(container._vnode, null, null, true);
            }
        }
        else {
            patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        }
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(internals);
    }
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [
        vnode,
        prevVNode
    ]);
}
/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always moved so that need inherit el form previous nodes
 * to ensure correct moved position.
 */
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
            // this is only called in the optimized path so array children are
            // guaranteed to be vnodes
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {
                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {
                    c2 = ch2[i] = cloneIfMounted(ch2[i]);
                    c2.el = c1.el;
                }
                if (!shallow)
                    traverseStaticChildren(c1, c2);
            }
            // also inherit for comment nodes, but not placeholders (e.g. v-if which
            // would have received .el during block patch)
            if (( true) && c2.type === Comment$1 && !c2.el) {
                c2.el = c1.el;
            }
        }
    }
}
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function getSequence(arr) {
    const p = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
                c = ((u + v) / 2) | 0;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
        result[u] = v;
        v = p[v];
    }
    return result;
}

const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');
const isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;
const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {
        if (!select) {
            ( true) &&
                warn(`Current renderer does not support string target for Teleports. ` +
                    `(missing querySelector renderer option)`);
            return null;
        }
        else {
            const target = select(targetSelector);
            if (!target) {
                ( true) &&
                    warn(`Failed to locate Teleport target with selector "${targetSelector}". ` +
                        `Note the target element must exist before the component is mounted - ` +
                        `i.e. the target cannot be rendered by the component itself, and ` +
                        `ideally should be outside of the entire Vue component tree.`);
            }
            return target;
        }
    }
    else {
        if (( true) && !targetSelector && !isTeleportDisabled(props)) {
            warn(`Invalid Teleport target: ${targetSelector}`);
        }
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        // #3302
        // HMR updated, force full diff
        if (( true) && isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            // insert anchors in the main view
            const placeholder = (n2.el = ( true)
                ? createComment('teleport start')
                : 0);
            const mainAnchor = (n2.anchor = ( true)
                ? createComment('teleport end')
                : 0);
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = (n2.target = resolveTarget(n2.props, querySelector));
            const targetAnchor = (n2.targetAnchor = createText(''));
            if (target) {
                insert(targetAnchor, target);
                // #2652 we could be teleporting from a non-SVG tree into an SVG tree
                isSVG = isSVG || isTargetSVG(target);
            }
            else if (( true) && !disabled) {
                warn('Invalid Teleport target on mount:', target, `(${typeof target})`);
            }
            const mount = (container, anchor) => {
                // Teleport *always* has Array children. This is enforced in both the
                // compiler and vnode children normalization.
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
            };
            if (disabled) {
                mount(container, mainAnchor);
            }
            else if (target) {
                mount(target, targetAnchor);
            }
        }
        else {
            // update content
            n2.el = n1.el;
            const mainAnchor = (n2.anchor = n1.anchor);
            const target = (n2.target = n1.target);
            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
                // fast path when the teleport happens to be a block root
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
                // even in block tree mode we need to make sure all root-level nodes
                // in the teleport inherit previous DOM references so that they can
                // be moved in future patches.
                traverseStaticChildren(n1, n2, true);
            }
            else if (!optimized) {
                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            }
            if (disabled) {
                if (!wasDisabled) {
                    // enabled -> disabled
                    // move into main container
                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);
                }
            }
            else {
                // target changed
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));
                    if (nextTarget) {
                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);
                    }
                    else if ((true)) {
                        warn('Invalid Teleport target on update:', target, `(${typeof target})`);
                    }
                }
                else if (wasDisabled) {
                    // disabled -> enabled
                    // move into teleport target
                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);
                }
            }
        }
    },
    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
            hostRemove(targetAnchor);
        }
        // an unmounted teleport should always remove its children if not disabled
        if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
                }
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {
    // move target anchor if this is a target change.
    if (moveType === 0 /* TARGET_CHANGE */) {
        insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2 /* REORDER */;
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(el, container, parentAnchor);
    }
    // if this is a re-order and teleport is enabled (content is in target)
    // do not move children. So the opposite is: only move children if this
    // is not a reorder, or the teleport is disabled
    if (!isReorder || isTeleportDisabled(props)) {
        // Teleport has either Array children or no children.
        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, parentAnchor, 2 /* REORDER */);
            }
        }
    }
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(anchor, container, parentAnchor);
    }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = (vnode.target = resolveTarget(vnode.props, querySelector));
    if (target) {
        // if multiple teleports rendered to the same target element, we need to
        // pick up from where the last teleport finished instead of the first node
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetAnchor = targetNode;
            }
            else {
                vnode.anchor = nextSibling(node);
                vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
            target._lpa =
                vnode.targetAnchor && nextSibling(vnode.targetAnchor);
        }
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
// Force-casted public typing for h and TSX props inference
const Teleport = TeleportImpl;

const COMPONENTS = 'components';
const DIRECTIVES = 'directives';
/**
 * @private
 */
function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
/**
 * @private
 */
function resolveDynamicComponent(component) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
    }
    else {
        // invalid types will fallthrough to createVNode and raise warning
        return (component || NULL_DYNAMIC_COMPONENT);
    }
}
/**
 * @private
 */
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
// implementation
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        // explicit self name has highest priority
        if (type === COMPONENTS) {
            const selfName = getComponentName(Component);
            if (selfName &&
                (selfName === name ||
                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) ||
                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {
                return Component;
            }
        }
        const res = 
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) ||
            // global registration
            resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) {
            // fallback to implicit self-reference
            return Component;
        }
        if (( true) && warnMissing && !res) {
            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}`);
        }
        return res;
    }
    else if ((true)) {
        warn(`resolve${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1))} ` +
            `can only be used in render() or setup().`);
    }
}
function resolve(registry, name) {
    return (registry &&
        (registry[name] ||
            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] ||
            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]));
}

const Fragment = Symbol(( true) ? 'Fragment' : 0);
const Text = Symbol(( true) ? 'Text' : 0);
const Comment$1 = Symbol(( true) ? 'Comment' : 0);
const Static = Symbol(( true) ? 'Static' : 0);
// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
const blockStack = [];
let currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */
function openBlock(disableTracking = false) {
    blockStack.push((currentBlock = disableTracking ? null : []));
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
let isBlockTreeEnabled = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */
function setBlockTracking(value) {
    isBlockTreeEnabled += value;
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */
function createBlock(type, props, children, patchFlag, dynamicProps) {
    const vnode = createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */);
    // save current block children on the block vnode
    vnode.dynamicChildren =
        isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null;
    // close block
    closeBlock();
    // a block is always going to be patched, so track it as a child of its
    // parent block
    if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
    }
    return vnode;
}
function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (( true) &&
        n2.shapeFlag & 6 /* COMPONENT */ &&
        hmrDirtyComponents.has(n2.type)) {
        // HMR only: if the component has been hot-updated, force a reload.
        return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(...(vnodeArgsTransformer
        ? vnodeArgsTransformer(args, currentRenderingInstance)
        : args));
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref }) => {
    return (ref != null
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)
            ? { i: currentRenderingInstance, r: ref }
            : ref
        : null);
};
const createVNode = (( true)
    ? createVNodeWithArgsTransform
    : 0);
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (( true) && !type) {
            warn(`Invalid vnode type when creating vnode: ${type}.`);
        }
        type = Comment$1;
    }
    if (isVNode(type)) {
        // createVNode receiving an existing vnode. This happens in cases like
        // <component :is="vnode"/>
        // #2078 make sure to merge refs during the clone instead of overwriting it
        const cloned = cloneVNode(type, props, true /* mergeRef: true */);
        if (children) {
            normalizeChildren(cloned, children);
        }
        return cloned;
    }
    // class component normalization.
    if (isClassComponent(type)) {
        type = type.__vccOpts;
    }
    // class & style normalization.
    if (props) {
        // for reactive or proxy objects, we need to clone it to enable mutation.
        if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || InternalObjectKey in props) {
            props = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props);
        }
        let { class: klass, style } = props;
        if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {
            props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);
        }
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {
            // reactive state objects need to be cloned since they are likely to be
            // mutated
            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {
                style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);
            }
            props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);
        }
    }
    // encode the vnode type information into a bitmap
    const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type)
        ? 1 /* ELEMENT */
        : isSuspense(type)
            ? 128 /* SUSPENSE */
            : isTeleport(type)
                ? 64 /* TELEPORT */
                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type)
                    ? 4 /* STATEFUL_COMPONENT */
                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type)
                        ? 2 /* FUNCTIONAL_COMPONENT */
                        : 0;
    if (( true) && shapeFlag & 4 /* STATEFUL_COMPONENT */ && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {
        type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);
        warn(`Vue received a Component which was made a reactive object. This can ` +
            `lead to unnecessary performance overhead, and should be avoided by ` +
            `marking the component with \`markRaw\` or using \`shallowRef\` ` +
            `instead of \`ref\`.`, `\nComponent that was made reactive: `, type);
    }
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children: null,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null
    };
    // validate key
    if (( true) && vnode.key !== vnode.key) {
        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    normalizeChildren(vnode, children);
    // normalize suspense children
    if (shapeFlag & 128 /* SUSPENSE */) {
        type.normalize(vnode);
    }
    if (isBlockTreeEnabled > 0 &&
        // avoid a block node from tracking itself
        !isBlockNode &&
        // has current parent block
        currentBlock &&
        // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&
        // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        patchFlag !== 32 /* HYDRATE_EVENTS */) {
        currentBlock.push(vnode);
    }
    return vnode;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
    // This is intentionally NOT using spread or extend to avoid the runtime
    // key enumeration cost.
    const { props, ref, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref
            ? // #2078 in the case of <component :is="vnode" ref="extra"/>
                // if the vnode itself already has a ref, cloneVNode will need to merge
                // the refs so the single vnode can be set on multiple refs
                mergeRef && ref
                    ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref)
                        ? ref.concat(normalizeRef(extraProps))
                        : [ref, normalizeRef(extraProps)]
                    : normalizeRef(extraProps)
            : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: ( true) && patchFlag === -1 /* HOISTED */ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)
            ? children.map(deepCloneVNode)
            : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: perserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment
            ? patchFlag === -1 // hoisted node
                ? 16 /* FULL_PROPS */
                : patchFlag | 16 /* FULL_PROPS */
            : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor
    };
    return cloned;
}
/**
 * Dev only, for HMR of hoisted vnodes reused in v-for
 * https://github.com/vitejs/vite/issues/2022
 */
function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {
        cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
}
/**
 * @private
 */
function createTextVNode(text = ' ', flag = 0) {
    return createVNode(Text, null, text, flag);
}
/**
 * @private
 */
function createStaticVNode(content, numberOfNodes) {
    // A static vnode can contain multiple stringified elements, and the number
    // of elements is necessary for hydration.
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
/**
 * @private
 */
function createCommentVNode(text = '', 
// when used as the v-else branch, the comment node must be created as a
// block to ensure correct updates.
asBlock = false) {
    return asBlock
        ? (openBlock(), createBlock(Comment$1, null, text))
        : createVNode(Comment$1, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === 'boolean') {
        // empty placeholder
        return createVNode(Comment$1);
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {
        // fragment
        return createVNode(Fragment, null, 
        // #3666, avoid reference pollution when reusing vnode
        child.slice());
    }
    else if (typeof child === 'object') {
        // already vnode, this should be the most common since compiled templates
        // always produce all-vnode children arrays
        return cloneIfMounted(child);
    }
    else {
        // strings and numbers
        return createVNode(Text, null, String(child));
    }
}
// optimized normalization for template-compiled render fns
function cloneIfMounted(child) {
    return child.el === null ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
        children = null;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {
        type = 16 /* ARRAY_CHILDREN */;
    }
    else if (typeof children === 'object') {
        if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {
            // Normalize slot to plain children for plain element and Teleport
            const slot = children.default;
            if (slot) {
                // _c marker is added by withCtx() indicating this is a compiled slot
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        }
        else {
            type = 32 /* SLOTS_CHILDREN */;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) {
                children._ctx = currentRenderingInstance;
            }
            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {
                // a child component receives forwarded slots from the parent.
                // its slot type is determined by its parent's slot type.
                if (currentRenderingInstance.slots._ === 1 /* STABLE */) {
                    children._ = 1 /* STABLE */;
                }
                else {
                    children._ = 2 /* DYNAMIC */;
                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                }
            }
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32 /* SLOTS_CHILDREN */;
    }
    else {
        children = String(children);
        // force teleport children to array so it can be moved around
        if (shapeFlag & 64 /* TELEPORT */) {
            type = 16 /* ARRAY_CHILDREN */;
            children = [createTextVNode(children)];
        }
        else {
            type = 8 /* TEXT_CHILDREN */;
        }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, args[0]);
    for (let i = 1; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
            if (key === 'class') {
                if (ret.class !== toMerge.class) {
                    ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);
                }
            }
            else if (key === 'style') {
                ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (existing !== incoming) {
                    ret[key] = existing
                        ? [].concat(existing, incoming)
                        : incoming;
                }
            }
            else if (key !== '') {
                ret[key] = toMerge[key];
            }
        }
    }
    return ret;
}

/**
 * Actual implementation
 */
function renderList(source, renderItem) {
    let ret;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
            ret[i] = renderItem(source[i], i);
        }
    }
    else if (typeof source === 'number') {
        if (( true) && !Number.isInteger(source)) {
            warn(`The v-for range expect an integer value but got ${source}.`);
            return [];
        }
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i);
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {
        if (source[Symbol.iterator]) {
            ret = Array.from(source, renderItem);
        }
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for (let i = 0, l = keys.length; i < l; i++) {
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i);
            }
        }
    }
    else {
        ret = [];
    }
    return ret;
}

/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */
function createSlots(slots, dynamicSlots) {
    for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        // array of dynamic slot generated by <template v-for="..." #[...]>
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {
            for (let j = 0; j < slot.length; j++) {
                slots[slot[j].name] = slot[j].fn;
            }
        }
        else if (slot) {
            // conditional single slot generated by <template v-if="..." #foo>
            slots[slot.name] = slot.fn;
        }
    }
    return slots;
}

/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */
function renderSlot(slots, name, props = {}, 
// this is not a user-facing function, so the fallback is always generated by
// the compiler and guaranteed to be a function returning an array
fallback, noSlotted) {
    let slot = slots[name];
    if (( true) && slot && slot.length > 1) {
        warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` +
            `function. You need to mark this component with $dynamic-slots in the ` +
            `parent template.`);
        slot = () => [];
    }
    // a compiled slot disables block tracking by default to avoid manual
    // invocation interfering with template-based block tracking, but in
    // `renderSlot` we can be sure that it's template-based so we can force
    // enable it.
    if (slot && slot._c) {
        slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */
        ? 64 /* STABLE_FRAGMENT */
        : -2 /* BAIL */);
    if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + '-s'];
    }
    if (slot && slot._c) {
        slot._d = true;
    }
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some(child => {
        if (!isVNode(child))
            return true;
        if (child.type === Comment$1)
            return false;
        if (child.type === Fragment &&
            !ensureValidVNode(child.children))
            return false;
        return true;
    })
        ? vnodes
        : null;
}

/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */
function toHandlers(obj) {
    const ret = {};
    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        warn(`v-on with no argument expects an object value.`);
        return ret;
    }
    for (const key in obj) {
        ret[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];
    }
    return ret;
}

/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */
const getPublicInstance = (i) => {
    if (!i)
        return null;
    if (isStatefulComponent(i))
        return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), {
    $: i => i,
    $el: i => i.vnode.el,
    $data: i => i.data,
    $props: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0),
    $attrs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0),
    $slots: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0),
    $refs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0),
    $parent: i => getPublicInstance(i.parent),
    $root: i => getPublicInstance(i.root),
    $emit: i => i.emit,
    $options: i => ( true ? resolveMergedOptions(i) : 0),
    $forceUpdate: i => () => queueJob(i.update),
    $nextTick: i => nextTick.bind(i.proxy),
    $watch: i => ( true ? instanceWatch.bind(i) : 0)
});
const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        // for internal formatters to know that this is a Vue instance
        if (( true) && key === '__isVue') {
            return true;
        }
        // prioritize <script setup> bindings during dev.
        // this allows even properties that start with _ or $ to be used - so that
        // it aligns with the production behavior where the render fn is inlined and
        // indeed has access to all declared variables.
        if (( true) &&
            setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
            setupState.__isScriptSetup &&
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
            return setupState[key];
        }
        // data / props / ctx
        // This getter gets called for every property access on the render context
        // during render and is a major hotspot. The most expensive part of this
        // is the multiple hasOwn() calls. It's much faster to do a simple property
        // access on a plain object, so we use an accessCache object (with null
        // prototype) to memoize what access type a key corresponds to.
        let normalizedProps;
        if (key[0] !== '$') {
            const n = accessCache[key];
            if (n !== undefined) {
                switch (n) {
                    case 0 /* SETUP */:
                        return setupState[key];
                    case 1 /* DATA */:
                        return data[key];
                    case 3 /* CONTEXT */:
                        return ctx[key];
                    case 2 /* PROPS */:
                        return props[key];
                    // default: just fallthrough
                }
            }
            else if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
                accessCache[key] = 0 /* SETUP */;
                return setupState[key];
            }
            else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
                accessCache[key] = 1 /* DATA */;
                return data[key];
            }
            else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) &&
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) {
                accessCache[key] = 2 /* PROPS */;
                return props[key];
            }
            else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
                accessCache[key] = 3 /* CONTEXT */;
                return ctx[key];
            }
            else if ( false || shouldCacheAccess) {
                accessCache[key] = 4 /* OTHER */;
            }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        // public $xxx properties
        if (publicGetter) {
            if (key === '$attrs') {
                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get" /* GET */, key);
                ( true) && markAttrsAccessed();
            }
            return publicGetter(instance);
        }
        else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) &&
            (cssModule = cssModule[key])) {
            return cssModule;
        }
        else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
            // user may set custom properties to `this` that start with `$`
            accessCache[key] = 3 /* CONTEXT */;
            return ctx[key];
        }
        else if (
        // global properties
        ((globalProperties = appContext.config.globalProperties),
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key))) {
            {
                return globalProperties[key];
            }
        }
        else if (( true) &&
            currentRenderingInstance &&
            (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) ||
                // #1091 avoid internal isRef/isVNode checks on component instance leading
                // to infinite warning loop
                key.indexOf('__v') !== 0)) {
            if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ &&
                (key[0] === '$' || key[0] === '_') &&
                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +
                    `character ("$" or "_") and is not proxied on the render context.`);
            }
            else if (instance === currentRenderingInstance) {
                warn(`Property ${JSON.stringify(key)} was accessed during render ` +
                    `but is not defined on instance.`);
            }
        }
    },
    set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
            setupState[key] = value;
        }
        else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
            data[key] = value;
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {
            ( true) &&
                warn(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
            return false;
        }
        if (key[0] === '$' && key.slice(1) in instance) {
            ( true) &&
                warn(`Attempting to mutate public property "${key}". ` +
                    `Properties starting with $ are reserved and readonly.`, instance);
            return false;
        }
        else {
            if (( true) && key in instance.appContext.config.globalProperties) {
                Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    value
                });
            }
            else {
                ctx[key] = value;
            }
        }
        return true;
    },
    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return (accessCache[key] !== undefined ||
            (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) ||
            (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) ||
            ((normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) ||
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key));
    }
};
if (true) {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +
            `The keys will be empty in production mode to avoid performance overhead.`);
        return Reflect.ownKeys(target);
    };
}
const RuntimeCompiledPublicInstanceProxyHandlers = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {
    get(target, key) {
        // fast path for unscopables when using `with` block
        if (key === Symbol.unscopables) {
            return;
        }
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_, key) {
        const has = key[0] !== '_' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyWhitelisted)(key);
        if (( true) && !has && PublicInstanceProxyHandlers.has(_, key)) {
            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
        }
        return has;
    }
});
// In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.
function createRenderContext(instance) {
    const target = {};
    // expose internal instance for proxy handlers
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: () => instance
    });
    // expose public properties
    Object.keys(publicPropertiesMap).forEach(key => {
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
        });
    });
    return target;
}
// dev only
function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) {
        Object.keys(propsOptions).forEach(key => {
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => instance.props[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
            });
        });
    }
}
// dev only
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach(key => {
        if (!setupState.__isScriptSetup && (key[0] === '$' || key[0] === '_')) {
            warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` +
                `which are reserved prefixes for Vue internals.`);
            return;
        }
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => setupState[key],
            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
        });
    });
}

const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    // inherit parent app context - or - if root, adopt from root vnode
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid$1++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        next: null,
        subTree: null,
        update: null,
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        effects: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resovled assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        emitted: null,
        // props default value
        propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    if ((true)) {
        instance.ctx = createRenderContext(instance);
    }
    else {}
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
    currentInstance = instance;
};
const isBuiltInTag = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('slot,component');
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO;
    if (isBuiltInTag(name) || appIsNativeTag(name)) {
        warn('Do not use built-in or reserved HTML elements as component id: ' + name);
    }
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful
        ? setupStatefulComponent(instance, isSSR)
        : undefined;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    if ((true)) {
        if (Component.name) {
            validateComponentName(Component.name, instance.appContext.config);
        }
        if (Component.components) {
            const names = Object.keys(Component.components);
            for (let i = 0; i < names.length; i++) {
                validateComponentName(names[i], instance.appContext.config);
            }
        }
        if (Component.directives) {
            const names = Object.keys(Component.directives);
            for (let i = 0; i < names.length; i++) {
                validateDirectiveName(names[i]);
            }
        }
        if (Component.compilerOptions && isRuntimeOnly()) {
            warn(`"compilerOptions" is only supported when using a build of Vue that ` +
                `includes the runtime compiler. Since you are using a runtime-only ` +
                `build, the options should be passed via your build tool config instead.`);
        }
    }
    // 0. create render proxy property access cache
    instance.accessCache = Object.create(null);
    // 1. create public instance / render proxy
    // also mark it raw so it's never observed
    instance.proxy = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    if ((true)) {
        exposePropsOnRenderContext(instance);
    }
    // 2. call setup()
    const { setup } = Component;
    if (setup) {
        const setupContext = (instance.setupContext =
            setup.length > 1 ? createSetupContext(instance) : null);
        currentInstance = instance;
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0, setupContext]);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        currentInstance = null;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult)) {
            const unsetInstance = () => {
                currentInstance = null;
            };
            setupResult.then(unsetInstance, unsetInstance);
            if (isSSR) {
                // return the promise so server-renderer can wait on it
                return setupResult
                    .then((resolvedResult) => {
                    handleSetupResult(instance, resolvedResult, isSSR);
                })
                    .catch(e => {
                    handleError(e, instance, 0 /* SETUP_FUNCTION */);
                });
            }
            else {
                // async setup returned Promise.
                // bail here and wait for re-entry.
                instance.asyncDep = setupResult;
            }
        }
        else {
            handleSetupResult(instance, setupResult, isSSR);
        }
    }
    else {
        finishComponentSetup(instance, isSSR);
    }
}
function handleSetupResult(instance, setupResult, isSSR) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {
        // setup returned an inline render function
        {
            instance.render = setupResult;
        }
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {
        if (( true) && isVNode(setupResult)) {
            warn(`setup() should not return VNodes directly - ` +
                `return a render function instead.`);
        }
        // setup returned bindings.
        // assuming a render function compiled from template is present.
        if (true) {
            instance.devtoolsRawSetupState = setupResult;
        }
        instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);
        if ((true)) {
            exposeSetupStateOnRenderContext(instance);
        }
    }
    else if (( true) && setupResult !== undefined) {
        warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
    }
    finishComponentSetup(instance, isSSR);
}
let compile;
// dev only
const isRuntimeOnly = () => !compile;
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */
function registerRuntimeCompiler(_compile) {
    compile = _compile;
}
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    // template / render function normalization
    if (!instance.render) {
        // could be set from setup()
        if (compile && !Component.render) {
            const template = Component.template;
            if (template) {
                if ((true)) {
                    startMeasure(instance, `compile`);
                }
                const { isCustomElement, compilerOptions } = instance.appContext.config;
                const { delimiters, compilerOptions: componentCompilerOptions } = Component;
                const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
                    isCustomElement,
                    delimiters
                }, compilerOptions), componentCompilerOptions);
                Component.render = compile(template, finalCompilerOptions);
                if ((true)) {
                    endMeasure(instance, `compile`);
                }
            }
        }
        instance.render = (Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP);
        // for runtime-compiled render functions using `with` blocks, the render
        // proxy used needs a different `has` handler which is more performant and
        // also only allows a whitelist of globals to fallthrough.
        if (instance.render._rc) {
            instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
        }
    }
    // support for 2.x options
    if (true) {
        currentInstance = instance;
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        applyOptions(instance);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        currentInstance = null;
    }
    // warn missing template/render
    // the runtime compilation of template in SSR is done by server-render
    if (( true) && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {
        /* istanbul ignore if */
        if (!compile && Component.template) {
            warn(`Component provided template option but ` +
                `runtime compilation is not supported in this build of Vue.` +
                (` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
                    ) /* should not happen */);
        }
        else {
            warn(`Component is missing template or render function.`);
        }
    }
}
const attrDevProxyHandlers = {
    get: (target, key) => {
        markAttrsAccessed();
        return target[key];
    },
    set: () => {
        warn(`setupContext.attrs is readonly.`);
        return false;
    },
    deleteProperty: () => {
        warn(`setupContext.attrs is readonly.`);
        return false;
    }
};
function createSetupContext(instance) {
    const expose = exposed => {
        if (( true) && instance.exposed) {
            warn(`expose() should be called only once per setup().`);
        }
        instance.exposed = exposed || {};
    };
    if ((true)) {
        let attrs;
        // We use getters in dev in case libs like test-utils overwrite instance
        // properties (overwrites should not be done in prod)
        return Object.freeze({
            get attrs() {
                return (attrs || (attrs = new Proxy(instance.attrs, attrDevProxyHandlers)));
            },
            get slots() {
                return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.slots);
            },
            get emit() {
                return (event, ...args) => instance.emit(event, ...args);
            },
            expose
        });
    }
    else {}
}
function getExposeProxy(instance) {
    if (instance.exposed) {
        return (instance.exposeProxy ||
            (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(instance.exposed)), {
                get(target, key) {
                    if (key in target) {
                        return target[key];
                    }
                    else if (key in publicPropertiesMap) {
                        return publicPropertiesMap[key](instance);
                    }
                }
            })));
    }
}
// record effects created during a component's setup() so that they can be
// stopped when the component unmounts
function recordInstanceBoundEffect(effect, instance = currentInstance) {
    if (instance) {
        (instance.effects || (instance.effects = [])).push(effect);
    }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
function getComponentName(Component) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component)
        ? Component.displayName || Component.name
        : Component.name;
}
/* istanbul ignore next */
function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
            name = match[1];
        }
    }
    if (!name && instance && instance.parent) {
        // try to infer the name based on reverse resolution
        const inferFromRegistry = (registry) => {
            for (const key in registry) {
                if (registry[key] === Component) {
                    return key;
                }
            }
        };
        name =
            inferFromRegistry(instance.components ||
                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && '__vccOpts' in value;
}

function computed(getterOrOptions) {
    const c = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions);
    recordInstanceBoundEffect(c.effect);
    return c;
}

( true)
    ? Object.freeze({})
    : 0;
( true) ? Object.freeze([]) : 0;
const isFunction = (val) => typeof val === 'function';
const isObject = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};

// dev only
const warnRuntimeUsage = (method) => warn(`${method}() is a compiler-hint helper that is only usable inside ` +
    `<script setup> of a single file component. Its arguments should be ` +
    `compiled away and passing it at runtime has no effect.`);
// implementation
function defineProps() {
    if ((true)) {
        warnRuntimeUsage(`defineProps`);
    }
    return null;
}
// implementation
function defineEmits() {
    if ((true)) {
        warnRuntimeUsage(`defineEmits`);
    }
    return null;
}
/**
 * @deprecated use `defineEmits` instead.
 */
const defineEmit = defineEmits;
/**
 * Vue `<script setup>` compiler macro for declaring a component's exposed
 * instance properties when it is accessed by a parent component via template
 * refs.
 *
 * `<script setup>` components are closed by default - i.e. varaibles inside
 * the `<script setup>` scope is not exposed to parent unless explicitly exposed
 * via `defineExpose`.
 *
 * This is only usable inside `<script setup>`, is compiled away in the
 * output and should **not** be actually called at runtime.
 */
function defineExpose(exposed) {
    if ((true)) {
        warnRuntimeUsage(`defineExpose`);
    }
}
/**
 * Vue `<script setup>` compiler macro for providing props default values when
 * using type-based `defineProps` decalration.
 *
 * Example usage:
 * ```ts
 * withDefaults(defineProps<{
 *   size?: number
 *   labels?: string[]
 * }>(), {
 *   size: 3,
 *   labels: () => ['default label']
 * })
 * ```
 *
 * This is only usable inside `<script setup>`, is compiled away in the output
 * and should **not** be actually called at runtime.
 */
function withDefaults(props, defaults) {
    if ((true)) {
        warnRuntimeUsage(`withDefaults`);
    }
    return null;
}
/**
 * @deprecated use `useSlots` and `useAttrs` instead.
 */
function useContext() {
    if ((true)) {
        warn(`\`useContext()\` has been deprecated and will be removed in the ` +
            `next minor release. Use \`useSlots()\` and \`useAttrs()\` instead.`);
    }
    return getContext();
}
function useSlots() {
    return getContext().slots;
}
function useAttrs() {
    return getContext().attrs;
}
function getContext() {
    const i = getCurrentInstance();
    if (( true) && !i) {
        warn(`useContext() called without active instance.`);
    }
    return i.setupContext || (i.setupContext = createSetupContext(i));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */
function mergeDefaults(
// the base props is compiler-generated and guaranteed to be in this shape.
props, defaults) {
    for (const key in defaults) {
        const val = props[key];
        if (val) {
            val.default = defaults[key];
        }
        else if (val === null) {
            props[key] = { default: defaults[key] };
        }
        else if ((true)) {
            warn(`props default key "${key}" has no corresponding declaration.`);
        }
    }
    return props;
}
/**
 * `<script setup>` helper for persisting the current instance context over
 * async/await flows.
 *
 * `@vue/compiler-sfc` converts the following:
 *
 * ```ts
 * const x = await foo()
 * ```
 *
 * into:
 *
 * ```ts
 * let __temp, __restore
 * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)
 * ```
 * @internal
 */
function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    let awaitable = getAwaitable();
    setCurrentInstance(null);
    if (isPromise(awaitable)) {
        awaitable = awaitable.catch(e => {
            setCurrentInstance(ctx);
            throw e;
        });
    }
    return [awaitable, () => setCurrentInstance(ctx)];
}

// Actual implementation
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {
            // single vnode without props
            if (isVNode(propsOrChildren)) {
                return createVNode(type, null, [propsOrChildren]);
            }
            // props without children
            return createVNode(type, propsOrChildren);
        }
        else {
            // omit props
            return createVNode(type, null, propsOrChildren);
        }
    }
    else {
        if (l > 3) {
            children = Array.prototype.slice.call(arguments, 2);
        }
        else if (l === 3 && isVNode(children)) {
            children = [children];
        }
        return createVNode(type, propsOrChildren, children);
    }
}

const ssrContextKey = Symbol(( true) ? `ssrContext` : 0);
const useSSRContext = () => {
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
            warn(`Server rendering context not provided. Make sure to only call ` +
                `useSSRContext() conditionally in the server build.`);
        }
        return ctx;
    }
};

function initCustomFormatter() {
    /* eslint-disable no-restricted-globals */
    if ( false || typeof window === 'undefined') {
        return;
    }
    const vueStyle = { style: 'color:#3ba776' };
    const numberStyle = { style: 'color:#0b1bc9' };
    const stringStyle = { style: 'color:#b62e24' };
    const keywordStyle = { style: 'color:#9d288c' };
    // custom formatter for Chrome
    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
    const formatter = {
        header(obj) {
            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
                return null;
            }
            if (obj.__isVue) {
                return ['div', vueStyle, `VueInstance`];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, genRefFlag(obj)],
                    '<',
                    formatValue(obj.value),
                    `>`
                ];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, 'Reactive'],
                    '<',
                    formatValue(obj),
                    `>${(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? ` (readonly)` : ``}`
                ];
            }
            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, 'Readonly'],
                    '<',
                    formatValue(obj),
                    '>'
                ];
            }
            return null;
        },
        hasBody(obj) {
            return obj && obj.__isVue;
        },
        body(obj) {
            if (obj && obj.__isVue) {
                return [
                    'div',
                    {},
                    ...formatInstance(obj.$)
                ];
            }
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) {
            blocks.push(createInstanceBlock('props', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));
        }
        if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
            blocks.push(createInstanceBlock('setup', instance.setupState));
        }
        if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
            blocks.push(createInstanceBlock('data', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));
        }
        const computed = extractKeys(instance, 'computed');
        if (computed) {
            blocks.push(createInstanceBlock('computed', computed));
        }
        const injected = extractKeys(instance, 'inject');
        if (injected) {
            blocks.push(createInstanceBlock('injected', injected));
        }
        blocks.push([
            'div',
            {},
            [
                'span',
                {
                    style: keywordStyle.style + ';opacity:0.66'
                },
                '$ (internal): '
            ],
            ['object', { object: instance }]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);
        if (!Object.keys(target).length) {
            return ['span', {}];
        }
        return [
            'div',
            { style: 'line-height:1.25em;margin-bottom:0.6em' },
            [
                'div',
                {
                    style: 'color:#476582'
                },
                type
            ],
            [
                'div',
                {
                    style: 'padding-left:1.25em'
                },
                ...Object.keys(target).map(key => {
                    return [
                        'div',
                        {},
                        ['span', keywordStyle, key + ': '],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v, asRaw = true) {
        if (typeof v === 'number') {
            return ['span', numberStyle, v];
        }
        else if (typeof v === 'string') {
            return ['span', stringStyle, JSON.stringify(v)];
        }
        else if (typeof v === 'boolean') {
            return ['span', keywordStyle, v];
        }
        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {
            return ['object', { object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v }];
        }
        else {
            return ['span', stringStyle, String(v)];
        }
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {
            return;
        }
        const extracted = {};
        for (const key in instance.ctx) {
            if (isKeyOfType(Comp, key, type)) {
                extracted[key] = instance.ctx[key];
            }
        }
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if (((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key)) ||
            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts)) {
            return true;
        }
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
            return true;
        }
        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {
            return true;
        }
    }
    function genRefFlag(v) {
        if (v._shallow) {
            return `ShallowRef`;
        }
        if (v.effect) {
            return `ComputedRef`;
        }
        return `Ref`;
    }
    if (window.devtoolsFormatters) {
        window.devtoolsFormatters.push(formatter);
    }
    else {
        window.devtoolsFormatters = [formatter];
    }
}

// Core API ------------------------------------------------------------------
const version = "3.1.5";
/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */
const ssrUtils = (null);
/**
 * @internal only exposed in compat builds
 */
const resolveFilter = null;
/**
 * @internal only exposed in compat builds.
 */
const compatUtils = (null);




/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineEmit": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmit),
/* harmony export */   "defineEmits": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useContext),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "Transition": () => (/* binding */ Transition),
/* harmony export */   "TransitionGroup": () => (/* binding */ TransitionGroup),
/* harmony export */   "createApp": () => (/* binding */ createApp),
/* harmony export */   "createSSRApp": () => (/* binding */ createSSRApp),
/* harmony export */   "hydrate": () => (/* binding */ hydrate),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "useCssModule": () => (/* binding */ useCssModule),
/* harmony export */   "useCssVars": () => (/* binding */ useCssVars),
/* harmony export */   "vModelCheckbox": () => (/* binding */ vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* binding */ vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* binding */ vModelRadio),
/* harmony export */   "vModelSelect": () => (/* binding */ vModelSelect),
/* harmony export */   "vModelText": () => (/* binding */ vModelText),
/* harmony export */   "vShow": () => (/* binding */ vShow),
/* harmony export */   "withKeys": () => (/* binding */ withKeys),
/* harmony export */   "withModifiers": () => (/* binding */ withModifiers)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");




const svgNS = 'http://www.w3.org/2000/svg';
const doc = (typeof document !== 'undefined' ? document : null);
const staticTemplateCache = new Map();
const nodeOps = {
    insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
    },
    remove: child => {
        const parent = child.parentNode;
        if (parent) {
            parent.removeChild(child);
        }
    },
    createElement: (tag, isSVG, is, props) => {
        const el = isSVG
            ? doc.createElementNS(svgNS, tag)
            : doc.createElement(tag, is ? { is } : undefined);
        if (tag === 'select' && props && props.multiple != null) {
            el.setAttribute('multiple', props.multiple);
        }
        return el;
    },
    createText: text => doc.createTextNode(text),
    createComment: text => doc.createComment(text),
    setText: (node, text) => {
        node.nodeValue = text;
    },
    setElementText: (el, text) => {
        el.textContent = text;
    },
    parentNode: node => node.parentNode,
    nextSibling: node => node.nextSibling,
    querySelector: selector => doc.querySelector(selector),
    setScopeId(el, id) {
        el.setAttribute(id, '');
    },
    cloneNode(el) {
        const cloned = el.cloneNode(true);
        // #3072
        // - in `patchDOMProp`, we store the actual value in the `el._value` property.
        // - normally, elements using `:value` bindings will not be hoisted, but if
        //   the bound value is a constant, e.g. `:value="true"` - they do get
        //   hoisted.
        // - in production, hoisted nodes are cloned when subsequent inserts, but
        //   cloneNode() does not copy the custom property we attached.
        // - This may need to account for other custom DOM properties we attach to
        //   elements in addition to `_value` in the future.
        if (`_value` in el) {
            cloned._value = el._value;
        }
        return cloned;
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, isSVG) {
        // <parent> before | first ... last | anchor </parent>
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        let template = staticTemplateCache.get(content);
        if (!template) {
            const t = doc.createElement('template');
            t.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            template = t.content;
            if (isSVG) {
                // remove outer svg wrapper
                const wrapper = template.firstChild;
                while (wrapper.firstChild) {
                    template.appendChild(wrapper.firstChild);
                }
                template.removeChild(wrapper);
            }
            staticTemplateCache.set(content, template);
        }
        parent.insertBefore(template.cloneNode(true), anchor);
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};

// compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]
function patchClass(el, value, isSVG) {
    // directly setting className should be faster than setAttribute in theory
    // if this is an element during a transition, take the temporary transition
    // classes into account.
    const transitionClasses = el._vtc;
    if (transitionClasses) {
        value = (value
            ? [value, ...transitionClasses]
            : [...transitionClasses]).join(' ');
    }
    if (value == null) {
        el.removeAttribute('class');
    }
    else if (isSVG) {
        el.setAttribute('class', value);
    }
    else {
        el.className = value;
    }
}

function patchStyle(el, prev, next) {
    const style = el.style;
    if (!next) {
        el.removeAttribute('style');
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next)) {
        if (prev !== next) {
            const current = style.display;
            style.cssText = next;
            // indicates that the `display` of the element is controlled by `v-show`,
            // so we always keep the current `display` value regardless of the `style` value,
            // thus handing over control to `v-show`.
            if ('_vod' in el) {
                style.display = current;
            }
        }
    }
    else {
        for (const key in next) {
            setStyle(style, key, next[key]);
        }
        if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {
            for (const key in prev) {
                if (next[key] == null) {
                    setStyle(style, key, '');
                }
            }
        }
    }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {
        val.forEach(v => setStyle(style, name, v));
    }
    else {
        if (name.startsWith('--')) {
            // custom property definition
            style.setProperty(name, val);
        }
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
                // !important
                style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed), val.replace(importantRE, ''), 'important');
            }
            else {
                style[prefixed] = val;
            }
        }
    }
}
const prefixes = ['Webkit', 'Moz', 'ms'];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
        return cached;
    }
    let name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(rawName);
    if (name !== 'filter' && name in style) {
        return (prefixCache[rawName] = name);
    }
    name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);
    for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
            return (prefixCache[rawName] = prefixed);
        }
    }
    return rawName;
}

const xlinkNS = 'http://www.w3.org/1999/xlink';
function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith('xlink:')) {
        if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        }
        else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    }
    else {
        // note we are only checking boolean attributes that don't have a
        // corresponding dom prop of the same name here.
        const isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key);
        if (value == null || (isBoolean && value === false)) {
            el.removeAttribute(key);
        }
        else {
            el.setAttribute(key, isBoolean ? '' : value);
        }
    }
}

// __UNSAFE__
// functions. The user is responsible for using them with only trusted content.
function patchDOMProp(el, key, value, 
// the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === 'innerHTML' || key === 'textContent') {
        if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? '' : value;
        return;
    }
    if (key === 'value' && el.tagName !== 'PROGRESS') {
        // store value as _value as well since
        // non-string values will be stringified.
        el._value = value;
        const newValue = value == null ? '' : value;
        if (el.value !== newValue) {
            el.value = newValue;
        }
        if (value == null) {
            el.removeAttribute(key);
        }
        return;
    }
    if (value === '' || value == null) {
        const type = typeof el[key];
        if (value === '' && type === 'boolean') {
            // e.g. <select multiple> compiles to { multiple: '' }
            el[key] = true;
            return;
        }
        else if (value == null && type === 'string') {
            // e.g. <div :id="null">
            el[key] = '';
            el.removeAttribute(key);
            return;
        }
        else if (type === 'number') {
            // e.g. <img :width="null">
            // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error
            try {
                el[key] = 0;
            }
            catch (_a) { }
            el.removeAttribute(key);
            return;
        }
    }
    // some properties perform value validation and throw
    try {
        el[key] = value;
    }
    catch (e) {
        if ((true)) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` +
                `value ${value} is invalid.`, e);
        }
    }
}

// Async edge case fix requires storing an event listener's attach timestamp.
let _getNow = Date.now;
let skipTimestampCheck = false;
if (typeof window !== 'undefined') {
    // Determine what event timestamp the browser is using. Annoyingly, the
    // timestamp can either be hi-res (relative to page load) or low-res
    // (relative to UNIX epoch), so in order to compare time we have to use the
    // same timestamp type when saving the flush timestamp.
    if (_getNow() > document.createEvent('Event').timeStamp) {
        // if the low-res timestamp which is bigger than the event timestamp
        // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
        // and we need to use the hi-res version for event listeners as well.
        _getNow = () => performance.now();
    }
    // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
    // and does not fire microtasks in between event propagation, so safe to exclude.
    const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
    skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
}
// To avoid the overhead of repeatedly calling performance.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.
let cachedNow = 0;
const p = Promise.resolve();
const reset = () => {
    cachedNow = 0;
};
const getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    // vei = vue event invokers
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
        // patch
        existingInvoker.value = nextValue;
    }
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            // add
            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));
            addEventListener(el, name, invoker, options);
        }
        else if (existingInvoker) {
            // remove
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = undefined;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while ((m = name.match(optionsModifierRE))) {
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    return [(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2)), options];
}
function createInvoker(initialValue, instance) {
    const invoker = (e) => {
        // async edge case #6566: inner click event triggers patch, event handler
        // attached to outer element during patch, and triggered again. This
        // happens because browsers fire microtask ticks between event propagation.
        // the solution is simple: we save the timestamp when a handler is attached,
        // and the handler would only fire if the event passed to it was fired
        // AFTER it was attached.
        const timeStamp = e.timeStamp || _getNow();
        if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);
        }
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e, value) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map(fn => (e) => !e._stopped && fn(e));
    }
    else {
        return value;
    }
}

const nativeOnRE = /^on[a-z]/;
const forcePatchProp = (_, key) => key === 'value';
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    switch (key) {
        // special
        case 'class':
            patchClass(el, nextValue, isSVG);
            break;
        case 'style':
            patchStyle(el, prevValue, nextValue);
            break;
        default:
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                // ignore v-model listeners
                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
                    patchEvent(el, key, prevValue, nextValue, parentComponent);
                }
            }
            else if (shouldSetAsProp(el, key, nextValue, isSVG)) {
                patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
            }
            else {
                // special case for <input v-model type="checkbox"> with
                // :true-value & :false-value
                // store value as dom properties since non-string values will be
                // stringified.
                if (key === 'true-value') {
                    el._trueValue = nextValue;
                }
                else if (key === 'false-value') {
                    el._falseValue = nextValue;
                }
                patchAttr(el, key, nextValue, isSVG);
            }
            break;
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        // most keys must be set as attribute on svg elements to work
        // ...except innerHTML
        if (key === 'innerHTML') {
            return true;
        }
        // or native onclick with function values
        if (key in el && nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
            return true;
        }
        return false;
    }
    // spellcheck and draggable are numerated attrs, however their
    // corresponding DOM properties are actually booleans - this leads to
    // setting it with a string "false" value leading it to be coerced to
    // `true`, so we need to always treat them as attributes.
    // Note that `contentEditable` doesn't have this problem: its DOM
    // property is also enumerated string values.
    if (key === 'spellcheck' || key === 'draggable') {
        return false;
    }
    // #1787, #2840 form property on form elements is readonly and must be set as
    // attribute.
    if (key === 'form') {
        return false;
    }
    // #1526 <input list> must be set as attribute
    if (key === 'list' && el.tagName === 'INPUT') {
        return false;
    }
    // #2766 <textarea type> must be set as attribute
    if (key === 'type' && el.tagName === 'TEXTAREA') {
        return false;
    }
    // native onclick with string value, must be set as attribute
    if (nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
        return false;
    }
    return key in el;
}

function useCssModule(name = '$style') {
    /* istanbul ignore else */
    {
        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        if (!instance) {
            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssModule must be called inside setup()`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS modules injected.`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            ( true) &&
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS module named "${name}".`);
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
        }
        return mod;
    }
}

/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */
function useCssVars(getter) {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    /* istanbul ignore next */
    if (!instance) {
        ( true) &&
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssVars is called without current active component instance.`);
        return;
    }
    const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect)(setVars, { flush: 'post' }));
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(setVars);
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128 /* SUSPENSE */) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
            suspense.effects.push(() => {
                setVarsOnVNode(suspense.activeBranch, vars);
            });
        }
    }
    // drill down HOCs until it's a non-component vnode
    while (vnode.component) {
        vnode = vnode.component.subTree;
    }
    if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {
        setVarsOnNode(vnode.el, vars);
    }
    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
        vnode.children.forEach(c => setVarsOnVNode(c, vars));
    }
    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static) {
        let { el, anchor } = vnode;
        while (el) {
            setVarsOnNode(el, vars);
            if (el === anchor)
                break;
            el = el.nextSibling;
        }
    }
}
function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
        const style = el.style;
        for (const key in vars) {
            style.setProperty(`--${key}`, vars[key]);
        }
    }
}

const TRANSITION = 'transition';
const ANIMATION = 'animation';
// DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.
const Transition = (props, { slots }) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = 'Transition';
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = (Transition.props = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition.props, DOMTransitionPropsValidators));
/**
 * #3227 Incoming hooks may be merged into arrays when wrapping Transition
 * with custom HOCs.
 */
const callHook = (hook, args = []) => {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
        hook.forEach(h => h(...args));
    }
    else if (hook) {
        hook(...args);
    }
};
/**
 * Check if a hook expects a callback (2nd arg), which means the user
 * intends to explicitly control the end of the transition.
 */
const hasExplicitCallback = (hook) => {
    return hook
        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)
            ? hook.some(h => h.length > 1)
            : hook.length > 1
        : false;
};
function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
        }
    }
    if (rawProps.css === false) {
        return baseProps;
    }
    const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done) => {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear) => {
        return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve = () => finishEnter(el, isAppear, done);
            callHook(hook, [el, resolve]);
            nextFrame(() => {
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) {
                    whenTransitionEnds(el, type, enterDuration, resolve);
                }
            });
        };
    };
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {
        onBeforeEnter(el) {
            callHook(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
            callHook(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
            const resolve = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            // force reflow so *-leave-from classes immediately take effect (#2593)
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(onLeave)) {
                    whenTransitionEnds(el, type, leaveDuration, resolve);
                }
            });
            callHook(onLeave, [el, resolve]);
        },
        onEnterCancelled(el) {
            finishEnter(el, false);
            callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
            finishEnter(el, true);
            callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
            finishLeave(el);
            callHook(onLeaveCancelled, [el]);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) {
        return null;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
    }
    else {
        const n = NumberOf(duration);
        return [n, n];
    }
}
function NumberOf(val) {
    const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);
    if ((true))
        validateDuration(res);
    return res;
}
function validateDuration(val) {
    if (typeof val !== 'number') {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is not a valid number - ` +
            `got ${JSON.stringify(val)}.`);
    }
    else if (isNaN(val)) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<transition> explicit duration is NaN - ` +
            'the duration expression might be incorrect.');
    }
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.add(c));
    (el._vtc ||
        (el._vtc = new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
            el._vtc = undefined;
        }
    }
}
function nextFrame(cb) {
    requestAnimationFrame(() => {
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = (el._endId = ++endId);
    const resolveIfNotStale = () => {
        if (id === el._endId) {
            resolve();
        }
    };
    if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
        return resolve();
    }
    const endEvent = type + 'end';
    let ended = 0;
    const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
            end();
        }
    };
    setTimeout(() => {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    const getStyleProperties = (key) => (styles[key] || '').split(', ');
    const transitionDelays = getStyleProperties(TRANSITION + 'Delay');
    const transitionDurations = getStyleProperties(TRANSITION + 'Duration');
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(ANIMATION + 'Delay');
    const animationDurations = getStyleProperties(ANIMATION + 'Duration');
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type =
            timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    const hasTransform = type === TRANSITION &&
        /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
// synchronously force layout to put elements into a certain state
function forceReflow() {
    return document.body.offsetHeight;
}

const positionMap = new WeakMap();
const newPositionMap = new WeakMap();
const TransitionGroupImpl = {
    name: 'TransitionGroup',
    props: /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup(props, { slots }) {
        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();
        let prevChildren;
        let children;
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {
            // children is guaranteed to exist after initial render
            if (!prevChildren.length) {
                return;
            }
            const moveClass = props.moveClass || `${props.name || 'v'}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
                return;
            }
            // we divide the work into three loops to avoid mixing DOM reads and writes
            // in each iteration - which helps prevent layout thrashing.
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            // force reflow to put everything in position
            forceReflow();
            movedChildren.forEach(c => {
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = '';
                const cb = (el._moveCb = (e) => {
                    if (e && e.target !== el) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener('transitionend', cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                });
                el.addEventListener('transitionend', cb);
            });
        });
        return () => {
            const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toRaw)(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;
            prevChildren = children;
            children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child.key != null) {
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                }
                else if ((true)) {
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<TransitionGroup> children must be keyed.`);
                }
            }
            if (prevChildren) {
                for (let i = 0; i < prevChildren.length; i++) {
                    const child = prevChildren[i];
                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
                    positionMap.set(child, child.el.getBoundingClientRect());
                }
            }
            return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);
        };
    }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) {
        el._moveCb();
    }
    if (el._enterCb) {
        el._enterCb();
    }
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = '0s';
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    // Detect whether an element with the move class applied has
    // CSS transitions. Since the element may be inside an entering
    // transition at this very moment, we make a clone of it and remove
    // all other transition classes applied to ensure only the move class
    // is applied.
    const clone = el.cloneNode();
    if (el._vtc) {
        el._vtc.forEach(cls => {
            cls.split(/\s+/).forEach(c => c && clone.classList.remove(c));
        });
    }
    moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c));
    clone.style.display = 'none';
    const container = (root.nodeType === 1
        ? root
        : root.parentNode);
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}

const getModelAssigner = (vnode) => {
    const fn = vnode.props['onUpdate:modelValue'];
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        trigger(target, 'input');
    }
}
function trigger(el, type) {
    const e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
}
// We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used.
const vModelText = {
    created(el, { modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || el.type === 'number';
        addEventListener(el, lazy ? 'change' : 'input', e => {
            if (e.target.composing)
                return;
            let domValue = el.value;
            if (trim) {
                domValue = domValue.trim();
            }
            else if (castToNumber) {
                domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(domValue);
            }
            el._assign(domValue);
        });
        if (trim) {
            addEventListener(el, 'change', () => {
                el.value = el.value.trim();
            });
        }
        if (!lazy) {
            addEventListener(el, 'compositionstart', onCompositionStart);
            addEventListener(el, 'compositionend', onCompositionEnd);
            // Safari < 10.2 & UIWebView doesn't fire compositionend when
            // switching focus before confirming composition choice
            // this also fixes the issue where some browsers e.g. iOS Chrome
            // fires "change" instead of "input" on autocomplete.
            addEventListener(el, 'change', onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el, { value }) {
        el.value = value == null ? '' : value;
    },
    beforeUpdate(el, { value, modifiers: { trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        // avoid clearing unresolved text. #2302
        if (el.composing)
            return;
        if (document.activeElement === el) {
            if (trim && el.value.trim() === value) {
                return;
            }
            if ((number || el.type === 'number') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(el.value) === value) {
                return;
            }
        }
        const newValue = value == null ? '' : value;
        if (el.value !== newValue) {
            el.value = newValue;
        }
    }
};
const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created(el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {
                const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) {
                    assign(modelValue.concat(elementValue));
                }
                else if (!checked && found) {
                    const filtered = [...modelValue];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            }
            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) {
                    cloned.add(elementValue);
                }
                else {
                    cloned.delete(elementValue);
                }
                assign(cloned);
            }
            else {
                assign(getCheckboxValue(el, checked));
            }
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate(el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;
    }
    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
        el.checked = value.has(vnode.props.value);
    }
    else if (value !== oldValue) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));
    }
}
const vModelRadio = {
    created(el, { value }, vnode) {
        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            el._assign(getValue(el));
        });
    },
    beforeUpdate(el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) {
            el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
        }
    }
};
const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created(el, { value, modifiers: { number } }, vnode) {
        const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);
        addEventListener(el, 'change', () => {
            const selectedVal = Array.prototype.filter
                .call(el.options, (o) => o.selected)
                .map((o) => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(getValue(o)) : getValue(o));
            el._assign(el.multiple
                ? isSetModel
                    ? new Set(selectedVal)
                    : selectedVal
                : selectedVal[0]);
        });
        el._assign = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted(el, { value }) {
        setSelected(el, value);
    },
    beforeUpdate(el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
    },
    updated(el, { value }) {
        setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
        ( true) &&
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<select multiple v-model> expects an Array or Set value for its binding, ` +
                `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
        return;
    }
    for (let i = 0, l = el.options.length; i < l; i++) {
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
                option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;
            }
            else {
                option.selected = value.has(optionValue);
            }
        }
        else {
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {
                if (el.selectedIndex !== i)
                    el.selectedIndex = i;
                return;
            }
        }
    }
    if (!isMultiple && el.selectedIndex !== -1) {
        el.selectedIndex = -1;
    }
}
// retrieve raw value set via :value bindings
function getValue(el) {
    return '_value' in el ? el._value : el.value;
}
// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
function getCheckboxValue(el, checked) {
    const key = checked ? '_trueValue' : '_falseValue';
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'created');
    },
    mounted(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'mounted');
    },
    beforeUpdate(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
    },
    updated(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'updated');
    }
};
function callModelHook(el, binding, vnode, prevVNode, hook) {
    let modelToUse;
    switch (el.tagName) {
        case 'SELECT':
            modelToUse = vModelSelect;
            break;
        case 'TEXTAREA':
            modelToUse = vModelText;
            break;
        default:
            switch (vnode.props && vnode.props.type) {
                case 'checkbox':
                    modelToUse = vModelCheckbox;
                    break;
                case 'radio':
                    modelToUse = vModelRadio;
                    break;
                default:
                    modelToUse = vModelText;
            }
    }
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}

const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
const modifierGuards = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => 'button' in e && e.button !== 0,
    middle: e => 'button' in e && e.button !== 1,
    right: e => 'button' in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
};
/**
 * @private
 */
const withModifiers = (fn, modifiers) => {
    return (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers))
                return;
        }
        return fn(event, ...args);
    };
};
// Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.
const keyNames = {
    esc: 'escape',
    space: ' ',
    up: 'arrow-up',
    left: 'arrow-left',
    right: 'arrow-right',
    down: 'arrow-down',
    delete: 'backspace'
};
/**
 * @private
 */
const withKeys = (fn, modifiers) => {
    return (event) => {
        if (!('key' in event)) {
            return;
        }
        const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);
        if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
            return fn(event);
        }
    };
};

const vShow = {
    beforeMount(el, { value }, { transition }) {
        el._vod = el.style.display === 'none' ? '' : el.style.display;
        if (transition && value) {
            transition.beforeEnter(el);
        }
        else {
            setDisplay(el, value);
        }
    },
    mounted(el, { value }, { transition }) {
        if (transition && value) {
            transition.enter(el);
        }
    },
    updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
            return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            }
            else {
                transition.leave(el, () => {
                    setDisplay(el, false);
                });
            }
        }
        else {
            setDisplay(el, value);
        }
    },
    beforeUnmount(el, { value }) {
        setDisplay(el, value);
    }
};
function setDisplay(el, value) {
    el.style.display = value ? el._vod : 'none';
}

const rendererOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ patchProp, forcePatchProp }, nodeOps);
// lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return renderer || (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration
        ? renderer
        : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);
    enabledHydration = true;
    return renderer;
}
// use explicit type casts here to avoid import() calls in rolled-up d.ts
const render = ((...args) => {
    ensureRenderer().render(...args);
});
const hydrate = ((...args) => {
    ensureHydrationRenderer().hydrate(...args);
});
const createApp = ((...args) => {
    const app = ensureRenderer().createApp(...args);
    if ((true)) {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
            return;
        const component = app._component;
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {
            // __UNSAFE__
            // Reason: potential execution of JS expressions in in-DOM template.
            // The user must make sure the in-DOM template is trusted. If it's
            // rendered by the server, the template should not contain any user data.
            component.template = container.innerHTML;
        }
        // clear content before mounting
        container.innerHTML = '';
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
            container.removeAttribute('v-cloak');
            container.setAttribute('data-v-app', '');
        }
        return proxy;
    };
    return app;
});
const createSSRApp = ((...args) => {
    const app = ensureHydrationRenderer().createApp(...args);
    if ((true)) {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (container) {
            return mount(container, true, container instanceof SVGElement);
        }
    };
    return app;
});
function injectNativeTagCheck(app) {
    // Inject `isNativeTag`
    // this is used for component name validation (dev only)
    Object.defineProperty(app.config, 'isNativeTag', {
        value: (tag) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),
        writable: false
    });
}
// dev only
function injectCompilerOptionsCheck(app) {
    if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, 'isCustomElement', {
            get() {
                return isCustomElement;
            },
            set() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`The \`isCustomElement\` config option is deprecated. Use ` +
                    `\`compilerOptions.isCustomElement\` instead.`);
            }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using ` +
            `a build of Vue.js that includes the runtime compiler (aka "full build"). ` +
            `Since you are using the runtime-only build, \`compilerOptions\` ` +
            `must be passed to \`@vue/compiler-dom\` in the build setup instead.\n` +
            `- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.\n` +
            `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n` +
            `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
        Object.defineProperty(app.config, 'compilerOptions', {
            get() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
                return compilerOptions;
            },
            set() {
                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
            }
        });
    }
}
function normalizeContainer(container) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {
        const res = document.querySelector(container);
        if (( true) && !res) {
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed to mount app: mount target selector "${container}" returned null.`);
        }
        return res;
    }
    if (( true) &&
        container instanceof window.ShadowRoot &&
        container.mode === 'closed') {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    }
    return container;
}




/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY_ARR": () => (/* binding */ EMPTY_ARR),
/* harmony export */   "EMPTY_OBJ": () => (/* binding */ EMPTY_OBJ),
/* harmony export */   "NO": () => (/* binding */ NO),
/* harmony export */   "NOOP": () => (/* binding */ NOOP),
/* harmony export */   "PatchFlagNames": () => (/* binding */ PatchFlagNames),
/* harmony export */   "babelParserDefaultPlugins": () => (/* binding */ babelParserDefaultPlugins),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "def": () => (/* binding */ def),
/* harmony export */   "escapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "escapeHtmlComment": () => (/* binding */ escapeHtmlComment),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "generateCodeFrame": () => (/* binding */ generateCodeFrame),
/* harmony export */   "getGlobalThis": () => (/* binding */ getGlobalThis),
/* harmony export */   "hasChanged": () => (/* binding */ hasChanged),
/* harmony export */   "hasOwn": () => (/* binding */ hasOwn),
/* harmony export */   "hyphenate": () => (/* binding */ hyphenate),
/* harmony export */   "invokeArrayFns": () => (/* binding */ invokeArrayFns),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBooleanAttr": () => (/* binding */ isBooleanAttr),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isGloballyWhitelisted": () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   "isHTMLTag": () => (/* binding */ isHTMLTag),
/* harmony export */   "isIntegerKey": () => (/* binding */ isIntegerKey),
/* harmony export */   "isKnownAttr": () => (/* binding */ isKnownAttr),
/* harmony export */   "isMap": () => (/* binding */ isMap),
/* harmony export */   "isModelListener": () => (/* binding */ isModelListener),
/* harmony export */   "isNoUnitNumericStyleProp": () => (/* binding */ isNoUnitNumericStyleProp),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isOn": () => (/* binding */ isOn),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isReservedProp": () => (/* binding */ isReservedProp),
/* harmony export */   "isSSRSafeAttrName": () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   "isSVGTag": () => (/* binding */ isSVGTag),
/* harmony export */   "isSet": () => (/* binding */ isSet),
/* harmony export */   "isSpecialBooleanAttr": () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isSymbol": () => (/* binding */ isSymbol),
/* harmony export */   "isVoidTag": () => (/* binding */ isVoidTag),
/* harmony export */   "looseEqual": () => (/* binding */ looseEqual),
/* harmony export */   "looseIndexOf": () => (/* binding */ looseIndexOf),
/* harmony export */   "makeMap": () => (/* binding */ makeMap),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "objectToString": () => (/* binding */ objectToString),
/* harmony export */   "parseStringStyle": () => (/* binding */ parseStringStyle),
/* harmony export */   "propsToAttrMap": () => (/* binding */ propsToAttrMap),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "slotFlagsText": () => (/* binding */ slotFlagsText),
/* harmony export */   "stringifyStyle": () => (/* binding */ stringifyStyle),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toRawType": () => (/* binding */ toRawType),
/* harmony export */   "toTypeString": () => (/* binding */ toTypeString)
/* harmony export */ });
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

/**
 * dev only flag -> name mapping
 */
const PatchFlagNames = {
    [1 /* TEXT */]: `TEXT`,
    [2 /* CLASS */]: `CLASS`,
    [4 /* STYLE */]: `STYLE`,
    [8 /* PROPS */]: `PROPS`,
    [16 /* FULL_PROPS */]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [512 /* NEED_PATCH */]: `NEED_PATCH`,
    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
    [-1 /* HOISTED */]: `HOISTED`,
    [-2 /* BAIL */]: `BAIL`
};

/**
 * Dev only
 */
const slotFlagsText = {
    [1 /* STABLE */]: 'STABLE',
    [2 /* DYNAMIC */]: 'DYNAMIC',
    [3 /* FORWARDED */]: 'FORWARDED'
};

const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    // Split the content into individual lines but capture the newline sequence
    // that separated each line. This is important because the actual sequence is
    // needed to properly take into account the full line length for offset
    // comparison
    let lines = source.split(/(\r?\n)/);
    // Separate the lines and newline sequences into separate arrays for easier referencing
    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
    lines = lines.filter((_, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count +=
            lines[i].length +
                ((newlineSequences[i] && newlineSequences[i].length) || 0);
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;
                if (j === i) {
                    // push underline
                    const pad = start - (count - (lineLength + newLineSeqLength));
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + newLineSeqLength;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */
const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`);
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
    }
    return (attrValidationCache[name] = !isUnsafe);
}
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */
const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`);
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */
const isKnownAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`);

function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (isObject(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = '';
    if (!styles) {
        return ret;
    }
    for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) ||
            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {
            // only render valid values
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (isString(value)) {
        res = value;
    }
    else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
                res += normalized + ' ';
            }
        }
    }
    else if (isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = '&quot;';
                break;
            case 38: // &
                escaped = '&amp;';
                break;
            case 39: // '
                escaped = '&#39;';
                break;
            case 60: // <
                escaped = '&lt;';
                break;
            case 62: // >
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
    if (a.length !== b.length)
        return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
    }
    return equal;
}
function looseEqual(a, b) {
    if (a === b)
        return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        /* istanbul ignore if: this if will probably never be called */
        if (!aValidType || !bValidType) {
            return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
            return false;
        }
        for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if ((aHasKey && !bHasKey) ||
                (!aHasKey && bHasKey) ||
                !looseEqual(a[key], b[key])) {
                return false;
            }
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex(item => looseEqual(item, val));
}

/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */
const toDisplayString = (val) => {
    return val == null
        ? ''
        : isObject(val)
            ? JSON.stringify(val, replacer, 2)
            : String(val);
};
const replacer = (_key, val) => {
    if (isMap(val)) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (isSet(val)) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
    }
    return val;
};

/**
 * List of @babel/parser plugins that are used for template expression
 * transforms and SFC script transforms. By default we enable proposals slated
 * for ES2020. This will need to be updated as the spec moves forward.
 * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins
 */
const babelParserDefaultPlugins = [
    'bigInt',
    'optionalChaining',
    'nullishCoalescingOperator'
];
const EMPTY_OBJ = ( true)
    ? Object.freeze({})
    : 0;
const EMPTY_ARR = ( true) ? Object.freeze([]) : 0;
const NOOP = () => { };
/**
 * Always return false.
 */
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith('onUpdate:');
const extend = Object.assign;
const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === '[object Map]';
const isSet = (val) => toTypeString(val) === '[object Set]';
const isDate = (val) => val instanceof Date;
const isFunction = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === '[object Object]';
const isIntegerKey = (key) => isString(key) &&
    key !== 'NaN' &&
    key[0] !== '-' &&
    '' + parseInt(key, 10) === key;
const isReservedProp = /*#__PURE__*/ makeMap(
// the leading comma is intentional so empty string "" is also included
',key,ref,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */
const toHandlerKey = cacheStringFunction((str) => (str ? `on${capitalize(str)}` : ``));
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
    return (_globalThis ||
        (_globalThis =
            typeof globalThis !== 'undefined'
                ? globalThis
                : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                        ? window
                        : typeof __webpack_require__.g !== 'undefined'
                            ? __webpack_require__.g
                            : {}));
};




/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/js/components/AdminApp.vue?vue&type=script&lang=js":
/*!**************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/js/components/AdminApp.vue?vue&type=script&lang=js ***!
  \**************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  setup: function setup() {
    var payload = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)([]);
    var charts = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(yrl_wp_vue_plotly_charts_obj.charts);
    var sheets = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(yrl_wp_vue_plotly_charts_obj.sheets);
    console.log(yrl_wp_vue_plotly_charts_obj); // onMounted(async () => {
    //   const response = await fetch( `${yrl_wp_vue_plotly_charts_obj.wpRestUrl}${yrl_wp_vue_plotly_charts_obj.plugin}/v1/charts`, {
    //     method: 'GET',
    //     // body: body,
    //     headers: {'X-WP-Nonce': yrl_wp_vue_plotly_charts_obj.wpRestNonce }
    //   } )
    //   payload.value = await response.json()
    //   console.log(payload.value)
    // })

    return {
      charts: charts,
      sheets: sheets
    };
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/js/components/AdminApp.vue?vue&type=template&id=713a361e&scoped=true":
/*!******************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/js/components/AdminApp.vue?vue&type=template&id=713a361e&scoped=true ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");


var _withId = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.withScopeId)("data-v-713a361e");

(0,vue__WEBPACK_IMPORTED_MODULE_0__.pushScopeId)("data-v-713a361e");

var _hoisted_1 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("h1", null, "Intercative Wp Vue Plotly Charts", -1
/* HOISTED */
);

var _hoisted_2 = {
  id: "nav"
};

var _hoisted_3 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)("Chart Library");

var _hoisted_4 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)("Settings");

var _hoisted_5 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)("Support");

(0,vue__WEBPACK_IMPORTED_MODULE_0__.popScopeId)();

var render = /*#__PURE__*/_withId(function (_ctx, _cache, $props, $setup, $data, $options) {
  var _component_router_link = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("router-link");

  var _component_router_view = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("router-view");

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, [_hoisted_1, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($setup.charts) + " " + (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($setup.sheets), 1
  /* TEXT */
  ), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)("div", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_router_link, {
    to: "/wp-admin/admin.php?page=yrl_wp_vue_plotly_charts"
  }, {
    default: _withId(function () {
      return [_hoisted_3];
    }),
    _: 1
    /* STABLE */

  }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_router_link, {
    to: "/settings"
  }, {
    default: _withId(function () {
      return [_hoisted_4];
    }),
    _: 1
    /* STABLE */

  }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_router_link, {
    to: "/support"
  }, {
    default: _withId(function () {
      return [_hoisted_5];
    }),
    _: 1
    /* STABLE */

  })]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_router_view)], 64
  /* STABLE_FRAGMENT */
  );
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/views/ChartLibrary.vue?vue&type=template&id=0d5619b7":
/*!**************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/views/ChartLibrary.vue?vue&type=template&id=0d5619b7 ***!
  \**************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)("h1", null, "Chart Library");
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/views/Settings.vue?vue&type=template&id=53cc84dd":
/*!**********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/views/Settings.vue?vue&type=template&id=53cc84dd ***!
  \**********************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)("h1", null, "Settings Page");
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/views/Support.vue?vue&type=template&id=1fa75705":
/*!*********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/views/Support.vue?vue&type=template&id=1fa75705 ***!
  \*********************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");

function render(_ctx, _cache) {
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)("h1", null, " Support Page");
}

/***/ }),

/***/ "./src/router/index.js":
/*!*****************************!*\
  !*** ./src/router/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vue-router */ "./node_modules/vue-router/dist/vue-router.esm-bundler.js");
/* harmony import */ var _views_ChartLibrary_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../views/ChartLibrary.vue */ "./src/views/ChartLibrary.vue");
/* harmony import */ var _views_Settings_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../views/Settings.vue */ "./src/views/Settings.vue");
/* harmony import */ var _views_Support_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../views/Support.vue */ "./src/views/Support.vue");




var routes = [{
  path: "/wp-admin/admin.php?page=yrl_wp_vue_plotly_charts",
  name: "Chart Library",
  component: _views_ChartLibrary_vue__WEBPACK_IMPORTED_MODULE_0__.default,
  redirect: '/'
}, {
  path: "/settings",
  name: "Settings",
  component: _views_Settings_vue__WEBPACK_IMPORTED_MODULE_1__.default
}, {
  path: "/support",
  name: "Support",
  component: _views_Support_vue__WEBPACK_IMPORTED_MODULE_2__.default
}];
var router = (0,vue_router__WEBPACK_IMPORTED_MODULE_3__.createRouter)({
  history: (0,vue_router__WEBPACK_IMPORTED_MODULE_3__.createWebHistory)(),
  routes: routes
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (router);

/***/ }),

/***/ "./src/js/components/AdminApp.vue":
/*!****************************************!*\
  !*** ./src/js/components/AdminApp.vue ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AdminApp_vue_vue_type_template_id_713a361e_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AdminApp.vue?vue&type=template&id=713a361e&scoped=true */ "./src/js/components/AdminApp.vue?vue&type=template&id=713a361e&scoped=true");
/* harmony import */ var _AdminApp_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AdminApp.vue?vue&type=script&lang=js */ "./src/js/components/AdminApp.vue?vue&type=script&lang=js");



_AdminApp_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__.default.render = _AdminApp_vue_vue_type_template_id_713a361e_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render
_AdminApp_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__.default.__scopeId = "data-v-713a361e"
/* hot reload */
if (false) {}

_AdminApp_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__.default.__file = "src/js/components/AdminApp.vue"

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_AdminApp_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__.default);

/***/ }),

/***/ "./src/views/ChartLibrary.vue":
/*!************************************!*\
  !*** ./src/views/ChartLibrary.vue ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ChartLibrary_vue_vue_type_template_id_0d5619b7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ChartLibrary.vue?vue&type=template&id=0d5619b7 */ "./src/views/ChartLibrary.vue?vue&type=template&id=0d5619b7");

const script = {}
script.render = _ChartLibrary_vue_vue_type_template_id_0d5619b7__WEBPACK_IMPORTED_MODULE_0__.render
/* hot reload */
if (false) {}

script.__file = "src/views/ChartLibrary.vue"

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (script);

/***/ }),

/***/ "./src/views/Settings.vue":
/*!********************************!*\
  !*** ./src/views/Settings.vue ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Settings_vue_vue_type_template_id_53cc84dd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Settings.vue?vue&type=template&id=53cc84dd */ "./src/views/Settings.vue?vue&type=template&id=53cc84dd");

const script = {}
script.render = _Settings_vue_vue_type_template_id_53cc84dd__WEBPACK_IMPORTED_MODULE_0__.render
/* hot reload */
if (false) {}

script.__file = "src/views/Settings.vue"

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (script);

/***/ }),

/***/ "./src/views/Support.vue":
/*!*******************************!*\
  !*** ./src/views/Support.vue ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Support_vue_vue_type_template_id_1fa75705__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Support.vue?vue&type=template&id=1fa75705 */ "./src/views/Support.vue?vue&type=template&id=1fa75705");

const script = {}
script.render = _Support_vue_vue_type_template_id_1fa75705__WEBPACK_IMPORTED_MODULE_0__.render
/* hot reload */
if (false) {}

script.__file = "src/views/Support.vue"

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (script);

/***/ }),

/***/ "./src/js/components/AdminApp.vue?vue&type=script&lang=js":
/*!****************************************************************!*\
  !*** ./src/js/components/AdminApp.vue?vue&type=script&lang=js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_3_use_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_8_use_0_AdminApp_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__.default)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_3_use_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_8_use_0_AdminApp_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!../../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./AdminApp.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/js/components/AdminApp.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./src/js/components/AdminApp.vue?vue&type=template&id=713a361e&scoped=true":
/*!**********************************************************************************!*\
  !*** ./src/js/components/AdminApp.vue?vue&type=template&id=713a361e&scoped=true ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_3_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_8_use_0_AdminApp_vue_vue_type_template_id_713a361e_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_3_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_8_use_0_AdminApp_vue_vue_type_template_id_713a361e_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./AdminApp.vue?vue&type=template&id=713a361e&scoped=true */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/js/components/AdminApp.vue?vue&type=template&id=713a361e&scoped=true");


/***/ }),

/***/ "./src/views/ChartLibrary.vue?vue&type=template&id=0d5619b7":
/*!******************************************************************!*\
  !*** ./src/views/ChartLibrary.vue?vue&type=template&id=0d5619b7 ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_3_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_8_use_0_ChartLibrary_vue_vue_type_template_id_0d5619b7__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_3_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_8_use_0_ChartLibrary_vue_vue_type_template_id_0d5619b7__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./ChartLibrary.vue?vue&type=template&id=0d5619b7 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/views/ChartLibrary.vue?vue&type=template&id=0d5619b7");


/***/ }),

/***/ "./src/views/Settings.vue?vue&type=template&id=53cc84dd":
/*!**************************************************************!*\
  !*** ./src/views/Settings.vue?vue&type=template&id=53cc84dd ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_3_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_8_use_0_Settings_vue_vue_type_template_id_53cc84dd__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_3_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_8_use_0_Settings_vue_vue_type_template_id_53cc84dd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./Settings.vue?vue&type=template&id=53cc84dd */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/views/Settings.vue?vue&type=template&id=53cc84dd");


/***/ }),

/***/ "./src/views/Support.vue?vue&type=template&id=1fa75705":
/*!*************************************************************!*\
  !*** ./src/views/Support.vue?vue&type=template&id=1fa75705 ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_3_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_8_use_0_Support_vue_vue_type_template_id_1fa75705__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_3_use_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_8_use_0_Support_vue_vue_type_template_id_1fa75705__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./Support.vue?vue&type=template&id=1fa75705 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-3.use!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[8].use[0]!./src/views/Support.vue?vue&type=template&id=1fa75705");


/***/ }),

/***/ "./node_modules/vue-router/dist/vue-router.esm-bundler.js":
/*!****************************************************************!*\
  !*** ./node_modules/vue-router/dist/vue-router.esm-bundler.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NavigationFailureType": () => (/* binding */ NavigationFailureType),
/* harmony export */   "RouterLink": () => (/* binding */ RouterLink),
/* harmony export */   "RouterView": () => (/* binding */ RouterView),
/* harmony export */   "START_LOCATION": () => (/* binding */ START_LOCATION_NORMALIZED),
/* harmony export */   "createMemoryHistory": () => (/* binding */ createMemoryHistory),
/* harmony export */   "createRouter": () => (/* binding */ createRouter),
/* harmony export */   "createRouterMatcher": () => (/* binding */ createRouterMatcher),
/* harmony export */   "createWebHashHistory": () => (/* binding */ createWebHashHistory),
/* harmony export */   "createWebHistory": () => (/* binding */ createWebHistory),
/* harmony export */   "isNavigationFailure": () => (/* binding */ isNavigationFailure),
/* harmony export */   "matchedRouteKey": () => (/* binding */ matchedRouteKey),
/* harmony export */   "onBeforeRouteLeave": () => (/* binding */ onBeforeRouteLeave),
/* harmony export */   "onBeforeRouteUpdate": () => (/* binding */ onBeforeRouteUpdate),
/* harmony export */   "parseQuery": () => (/* binding */ parseQuery),
/* harmony export */   "routeLocationKey": () => (/* binding */ routeLocationKey),
/* harmony export */   "routerKey": () => (/* binding */ routerKey),
/* harmony export */   "routerViewLocationKey": () => (/* binding */ routerViewLocationKey),
/* harmony export */   "stringifyQuery": () => (/* binding */ stringifyQuery),
/* harmony export */   "useLink": () => (/* binding */ useLink),
/* harmony export */   "useRoute": () => (/* binding */ useRoute),
/* harmony export */   "useRouter": () => (/* binding */ useRouter),
/* harmony export */   "viewDepthKey": () => (/* binding */ viewDepthKey)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");
/* harmony import */ var _vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/devtools-api */ "./node_modules/@vue/devtools-api/lib/esm/index.js");
/*!
  * vue-router v4.0.10
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */



const hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
const PolySymbol = (name) => 
// vr = vue router
hasSymbol
    ? Symbol(( true) ? '[vue-router]: ' + name : 0)
    : (( true) ? '[vue-router]: ' : 0) + name;
// rvlm = Router View Location Matched
/**
 * RouteRecord being rendered by the closest ancestor Router View. Used for
 * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View
 * Location Matched
 *
 * @internal
 */
const matchedRouteKey = /*#__PURE__*/ PolySymbol(( true) ? 'router view location matched' : 0);
/**
 * Allows overriding the router view depth to control which component in
 * `matched` is rendered. rvd stands for Router View Depth
 *
 * @internal
 */
const viewDepthKey = /*#__PURE__*/ PolySymbol(( true) ? 'router view depth' : 0);
/**
 * Allows overriding the router instance returned by `useRouter` in tests. r
 * stands for router
 *
 * @internal
 */
const routerKey = /*#__PURE__*/ PolySymbol(( true) ? 'router' : 0);
/**
 * Allows overriding the current route returned by `useRoute` in tests. rl
 * stands for route location
 *
 * @internal
 */
const routeLocationKey = /*#__PURE__*/ PolySymbol(( true) ? 'route location' : 0);
/**
 * Allows overriding the current route used by router-view. Internally this is
 * used when the `route` prop is passed.
 *
 * @internal
 */
const routerViewLocationKey = /*#__PURE__*/ PolySymbol(( true) ? 'router view location' : 0);

const isBrowser = typeof window !== 'undefined';

function isESModule(obj) {
    return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module');
}
const assign = Object.assign;
function applyToParams(fn, params) {
    const newParams = {};
    for (const key in params) {
        const value = params[key];
        newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);
    }
    return newParams;
}
let noop = () => { };

function warn(msg) {
    // avoid using ...args as it breaks in older Edge builds
    const args = Array.from(arguments).slice(1);
    console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));
}

const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, '');
/**
 * Transforms an URI into a normalized history location
 *
 * @param parseQuery
 * @param location - URI to normalize
 * @param currentLocation - current absolute location. Allows resolving relative
 * paths. Must start with `/`. Defaults to `/`
 * @returns a normalized history location
 */
function parseURL(parseQuery, location, currentLocation = '/') {
    let path, query = {}, searchString = '', hash = '';
    // Could use URL and URLSearchParams but IE 11 doesn't support it
    const searchPos = location.indexOf('?');
    const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);
    if (searchPos > -1) {
        path = location.slice(0, searchPos);
        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);
        query = parseQuery(searchString);
    }
    if (hashPos > -1) {
        path = path || location.slice(0, hashPos);
        // keep the # character
        hash = location.slice(hashPos, location.length);
    }
    // no search and no query
    path = resolveRelativePath(path != null ? path : location, currentLocation);
    // empty path means a relative query or hash `?foo=f`, `#thing`
    return {
        fullPath: path + (searchString && '?') + searchString + hash,
        path,
        query,
        hash,
    };
}
/**
 * Stringifies a URL object
 *
 * @param stringifyQuery
 * @param location
 */
function stringifyURL(stringifyQuery, location) {
    let query = location.query ? stringifyQuery(location.query) : '';
    return location.path + (query && '?') + query + (location.hash || '');
}
/**
 * Strips off the base from the beginning of a location.pathname in a non
 * case-sensitive way.
 *
 * @param pathname - location.pathname
 * @param base - base to strip off
 */
function stripBase(pathname, base) {
    // no base or base is not found at the beginning
    if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
        return pathname;
    return pathname.slice(base.length) || '/';
}
/**
 * Checks if two RouteLocation are equal. This means that both locations are
 * pointing towards the same {@link RouteRecord} and that all `params`, `query`
 * parameters and `hash` are the same
 *
 * @param a - first {@link RouteLocation}
 * @param b - second {@link RouteLocation}
 */
function isSameRouteLocation(stringifyQuery, a, b) {
    let aLastIndex = a.matched.length - 1;
    let bLastIndex = b.matched.length - 1;
    return (aLastIndex > -1 &&
        aLastIndex === bLastIndex &&
        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&
        isSameRouteLocationParams(a.params, b.params) &&
        stringifyQuery(a.query) === stringifyQuery(b.query) &&
        a.hash === b.hash);
}
/**
 * Check if two `RouteRecords` are equal. Takes into account aliases: they are
 * considered equal to the `RouteRecord` they are aliasing.
 *
 * @param a - first {@link RouteRecord}
 * @param b - second {@link RouteRecord}
 */
function isSameRouteRecord(a, b) {
    // since the original record has an undefined value for aliasOf
    // but all aliases point to the original record, this will always compare
    // the original record
    return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
    if (Object.keys(a).length !== Object.keys(b).length)
        return false;
    for (let key in a) {
        if (!isSameRouteLocationParamsValue(a[key], b[key]))
            return false;
    }
    return true;
}
function isSameRouteLocationParamsValue(a, b) {
    return Array.isArray(a)
        ? isEquivalentArray(a, b)
        : Array.isArray(b)
            ? isEquivalentArray(b, a)
            : a === b;
}
/**
 * Check if two arrays are the same or if an array with one single entry is the
 * same as another primitive value. Used to check query and parameters
 *
 * @param a - array of values
 * @param b - array of values or a single value
 */
function isEquivalentArray(a, b) {
    return Array.isArray(b)
        ? a.length === b.length && a.every((value, i) => value === b[i])
        : a.length === 1 && a[0] === b;
}
/**
 * Resolves a relative path that starts with `.`.
 *
 * @param to - path location we are resolving
 * @param from - currentLocation.path, should start with `/`
 */
function resolveRelativePath(to, from) {
    if (to.startsWith('/'))
        return to;
    if (( true) && !from.startsWith('/')) {
        warn(`Cannot resolve a relative location without an absolute path. Trying to resolve "${to}" from "${from}". It should look like "/${from}".`);
        return to;
    }
    if (!to)
        return from;
    const fromSegments = from.split('/');
    const toSegments = to.split('/');
    let position = fromSegments.length - 1;
    let toPosition;
    let segment;
    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
        segment = toSegments[toPosition];
        // can't go below zero
        if (position === 1 || segment === '.')
            continue;
        if (segment === '..')
            position--;
        // found something that is not relative path
        else
            break;
    }
    return (fromSegments.slice(0, position).join('/') +
        '/' +
        toSegments
            .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))
            .join('/'));
}

var NavigationType;
(function (NavigationType) {
    NavigationType["pop"] = "pop";
    NavigationType["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function (NavigationDirection) {
    NavigationDirection["back"] = "back";
    NavigationDirection["forward"] = "forward";
    NavigationDirection["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
/**
 * Starting location for Histories
 */
const START = '';
// Generic utils
/**
 * Normalizes a base by removing any trailing slash and reading the base tag if
 * present.
 *
 * @param base - base to normalize
 */
function normalizeBase(base) {
    if (!base) {
        if (isBrowser) {
            // respect <base> tag
            const baseEl = document.querySelector('base');
            base = (baseEl && baseEl.getAttribute('href')) || '/';
            // strip full URL origin
            base = base.replace(/^\w+:\/\/[^\/]+/, '');
        }
        else {
            base = '/';
        }
    }
    // ensure leading slash when it was removed by the regex above avoid leading
    // slash with hash because the file could be read from the disk like file://
    // and the leading slash would cause problems
    if (base[0] !== '/' && base[0] !== '#')
        base = '/' + base;
    // remove the trailing slash so all other method can just do `base + fullPath`
    // to build an href
    return removeTrailingSlash(base);
}
// remove any character before the hash
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location) {
    return base.replace(BEFORE_HASH_RE, '#') + location;
}

function getElementPosition(el, offset) {
    const docRect = document.documentElement.getBoundingClientRect();
    const elRect = el.getBoundingClientRect();
    return {
        behavior: offset.behavior,
        left: elRect.left - docRect.left - (offset.left || 0),
        top: elRect.top - docRect.top - (offset.top || 0),
    };
}
const computeScrollPosition = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset,
});
function scrollToPosition(position) {
    let scrollToOptions;
    if ('el' in position) {
        let positionEl = position.el;
        const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');
        /**
         * `id`s can accept pretty much any characters, including CSS combinators
         * like `>` or `~`. It's still possible to retrieve elements using
         * `document.getElementById('~')` but it needs to be escaped when using
         * `document.querySelector('#\\~')` for it to be valid. The only
         * requirements for `id`s are them to be unique on the page and to not be
         * empty (`id=""`). Because of that, when passing an id selector, it should
         * be properly escaped for it to work with `querySelector`. We could check
         * for the id selector to be simple (no CSS combinators `+ >~`) but that
         * would make things inconsistent since they are valid characters for an
         * `id` but would need to be escaped when using `querySelector`, breaking
         * their usage and ending up in no selector returned. Selectors need to be
         * escaped:
         *
         * - `#1-thing` becomes `#\31 -thing`
         * - `#with~symbols` becomes `#with\\~symbols`
         *
         * - More information about  the topic can be found at
         *   https://mathiasbynens.be/notes/html5-id-class.
         * - Practical example: https://mathiasbynens.be/demo/html5-id
         */
        if (( true) && typeof position.el === 'string') {
            if (!isIdSelector || !document.getElementById(position.el.slice(1))) {
                try {
                    let foundEl = document.querySelector(position.el);
                    if (isIdSelector && foundEl) {
                        warn(`The selector "${position.el}" should be passed as "el: document.querySelector('${position.el}')" because it starts with "#".`);
                        // return to avoid other warnings
                        return;
                    }
                }
                catch (err) {
                    warn(`The selector "${position.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
                    // return to avoid other warnings
                    return;
                }
            }
        }
        const el = typeof positionEl === 'string'
            ? isIdSelector
                ? document.getElementById(positionEl.slice(1))
                : document.querySelector(positionEl)
            : positionEl;
        if (!el) {
            ( true) &&
                warn(`Couldn't find element using selector "${position.el}" returned by scrollBehavior.`);
            return;
        }
        scrollToOptions = getElementPosition(el, position);
    }
    else {
        scrollToOptions = position;
    }
    if ('scrollBehavior' in document.documentElement.style)
        window.scrollTo(scrollToOptions);
    else {
        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
    }
}
function getScrollKey(path, delta) {
    const position = history.state ? history.state.position - delta : -1;
    return position + path;
}
const scrollPositions = new Map();
function saveScrollPosition(key, scrollPosition) {
    scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
    const scroll = scrollPositions.get(key);
    // consume it so it's not used again
    scrollPositions.delete(key);
    return scroll;
}
// TODO: RFC about how to save scroll position
/**
 * ScrollBehavior instance used by the router to compute and restore the scroll
 * position when navigating.
 */
// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {
//   // returns a scroll position that can be saved in history
//   compute(): ScrollPositionEntry
//   // can take an extended ScrollPositionEntry
//   scroll(position: ScrollPosition): void
// }
// export const scrollHandler: ScrollHandler<ScrollPosition> = {
//   compute: computeScroll,
//   scroll: scrollToPosition,
// }

let createBaseLocation = () => location.protocol + '//' + location.host;
/**
 * Creates a normalized history location from a window.location object
 * @param location -
 */
function createCurrentLocation(base, location) {
    const { pathname, search, hash } = location;
    // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end
    const hashPos = base.indexOf('#');
    if (hashPos > -1) {
        let slicePos = hash.includes(base.slice(hashPos))
            ? base.slice(hashPos).length
            : 1;
        let pathFromHash = hash.slice(slicePos);
        // prepend the starting slash to hash so the url starts with /#
        if (pathFromHash[0] !== '/')
            pathFromHash = '/' + pathFromHash;
        return stripBase(pathFromHash, '');
    }
    const path = stripBase(pathname, base);
    return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
    let listeners = [];
    let teardowns = [];
    // TODO: should it be a stack? a Dict. Check if the popstate listener
    // can trigger twice
    let pauseState = null;
    const popStateHandler = ({ state, }) => {
        const to = createCurrentLocation(base, location);
        const from = currentLocation.value;
        const fromState = historyState.value;
        let delta = 0;
        if (state) {
            currentLocation.value = to;
            historyState.value = state;
            // ignore the popstate and reset the pauseState
            if (pauseState && pauseState === from) {
                pauseState = null;
                return;
            }
            delta = fromState ? state.position - fromState.position : 0;
        }
        else {
            replace(to);
        }
        // console.log({ deltaFromCurrent })
        // Here we could also revert the navigation by calling history.go(-delta)
        // this listener will have to be adapted to not trigger again and to wait for the url
        // to be updated before triggering the listeners. Some kind of validation function would also
        // need to be passed to the listeners so the navigation can be accepted
        // call all listeners
        listeners.forEach(listener => {
            listener(currentLocation.value, from, {
                delta,
                type: NavigationType.pop,
                direction: delta
                    ? delta > 0
                        ? NavigationDirection.forward
                        : NavigationDirection.back
                    : NavigationDirection.unknown,
            });
        });
    };
    function pauseListeners() {
        pauseState = currentLocation.value;
    }
    function listen(callback) {
        // setup the listener and prepare teardown callbacks
        listeners.push(callback);
        const teardown = () => {
            const index = listeners.indexOf(callback);
            if (index > -1)
                listeners.splice(index, 1);
        };
        teardowns.push(teardown);
        return teardown;
    }
    function beforeUnloadListener() {
        const { history } = window;
        if (!history.state)
            return;
        history.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), '');
    }
    function destroy() {
        for (const teardown of teardowns)
            teardown();
        teardowns = [];
        window.removeEventListener('popstate', popStateHandler);
        window.removeEventListener('beforeunload', beforeUnloadListener);
    }
    // setup the listeners and prepare teardown callbacks
    window.addEventListener('popstate', popStateHandler);
    window.addEventListener('beforeunload', beforeUnloadListener);
    return {
        pauseListeners,
        listen,
        destroy,
    };
}
/**
 * Creates a state object
 */
function buildState(back, current, forward, replaced = false, computeScroll = false) {
    return {
        back,
        current,
        forward,
        replaced,
        position: window.history.length,
        scroll: computeScroll ? computeScrollPosition() : null,
    };
}
function useHistoryStateNavigation(base) {
    const { history, location } = window;
    // private variables
    let currentLocation = {
        value: createCurrentLocation(base, location),
    };
    let historyState = { value: history.state };
    // build current history entry as this is a fresh navigation
    if (!historyState.value) {
        changeLocation(currentLocation.value, {
            back: null,
            current: currentLocation.value,
            forward: null,
            // the length is off by one, we need to decrease it
            position: history.length - 1,
            replaced: true,
            // don't add a scroll as the user may have an anchor and we want
            // scrollBehavior to be triggered without a saved position
            scroll: null,
        }, true);
    }
    function changeLocation(to, state, replace) {
        /**
         * if a base tag is provided and we are on a normal domain, we have to
         * respect the provided `base` attribute because pushState() will use it and
         * potentially erase anything before the `#` like at
         * https://github.com/vuejs/vue-router-next/issues/685 where a base of
         * `/folder/#` but a base of `/` would erase the `/folder/` section. If
         * there is no host, the `<base>` tag makes no sense and if there isn't a
         * base tag we can just use everything after the `#`.
         */
        const hashIndex = base.indexOf('#');
        const url = hashIndex > -1
            ? (location.host && document.querySelector('base')
                ? base
                : base.slice(hashIndex)) + to
            : createBaseLocation() + base + to;
        try {
            // BROWSER QUIRK
            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds
            history[replace ? 'replaceState' : 'pushState'](state, '', url);
            historyState.value = state;
        }
        catch (err) {
            if ((true)) {
                warn('Error with push/replace State', err);
            }
            else {}
            // Force the navigation, this also resets the call count
            location[replace ? 'replace' : 'assign'](url);
        }
    }
    function replace(to, data) {
        const state = assign({}, history.state, buildState(historyState.value.back, 
        // keep back and forward entries but override current position
        to, historyState.value.forward, true), data, { position: historyState.value.position });
        changeLocation(to, state, true);
        currentLocation.value = to;
    }
    function push(to, data) {
        // Add to current entry the information of where we are going
        // as well as saving the current position
        const currentState = assign({}, 
        // use current history state to gracefully handle a wrong call to
        // history.replaceState
        // https://github.com/vuejs/vue-router-next/issues/366
        historyState.value, history.state, {
            forward: to,
            scroll: computeScrollPosition(),
        });
        if (( true) && !history.state) {
            warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\n\n` +
                `history.replaceState(history.state, '', url)\n\n` +
                `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);
        }
        changeLocation(currentState.current, currentState, true);
        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
        changeLocation(to, state, false);
        currentLocation.value = to;
    }
    return {
        location: currentLocation,
        state: historyState,
        push,
        replace,
    };
}
/**
 * Creates an HTML5 history. Most common history for single page applications.
 *
 * @param base -
 */
function createWebHistory(base) {
    base = normalizeBase(base);
    const historyNavigation = useHistoryStateNavigation(base);
    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
    function go(delta, triggerListeners = true) {
        if (!triggerListeners)
            historyListeners.pauseListeners();
        history.go(delta);
    }
    const routerHistory = assign({
        // it's overridden right after
        location: '',
        base,
        go,
        createHref: createHref.bind(null, base),
    }, historyNavigation, historyListeners);
    Object.defineProperty(routerHistory, 'location', {
        enumerable: true,
        get: () => historyNavigation.location.value,
    });
    Object.defineProperty(routerHistory, 'state', {
        enumerable: true,
        get: () => historyNavigation.state.value,
    });
    return routerHistory;
}

/**
 * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.
 * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.
 *
 * @param base - Base applied to all urls, defaults to '/'
 * @returns a history object that can be passed to the router constructor
 */
function createMemoryHistory(base = '') {
    let listeners = [];
    let queue = [START];
    let position = 0;
    function setLocation(location) {
        position++;
        if (position === queue.length) {
            // we are at the end, we can simply append a new entry
            queue.push(location);
        }
        else {
            // we are in the middle, we remove everything from here in the queue
            queue.splice(position);
            queue.push(location);
        }
    }
    function triggerListeners(to, from, { direction, delta }) {
        const info = {
            direction,
            delta,
            type: NavigationType.pop,
        };
        for (let callback of listeners) {
            callback(to, from, info);
        }
    }
    const routerHistory = {
        // rewritten by Object.defineProperty
        location: START,
        // TODO: should be kept in queue
        state: {},
        base,
        createHref: createHref.bind(null, base),
        replace(to) {
            // remove current entry and decrement position
            queue.splice(position--, 1);
            setLocation(to);
        },
        push(to, data) {
            setLocation(to);
        },
        listen(callback) {
            listeners.push(callback);
            return () => {
                const index = listeners.indexOf(callback);
                if (index > -1)
                    listeners.splice(index, 1);
            };
        },
        destroy() {
            listeners = [];
            queue = [START];
            position = 0;
        },
        go(delta, shouldTrigger = true) {
            const from = this.location;
            const direction = 
            // we are considering delta === 0 going forward, but in abstract mode
            // using 0 for the delta doesn't make sense like it does in html5 where
            // it reloads the page
            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;
            position = Math.max(0, Math.min(position + delta, queue.length - 1));
            if (shouldTrigger) {
                triggerListeners(this.location, from, {
                    direction,
                    delta,
                });
            }
        },
    };
    Object.defineProperty(routerHistory, 'location', {
        enumerable: true,
        get: () => queue[position],
    });
    return routerHistory;
}

/**
 * Creates a hash history. Useful for web applications with no host (e.g.
 * `file://`) or when configuring a server to handle any URL is not possible.
 *
 * @param base - optional base to provide. Defaults to `location.pathname +
 * location.search` If there is a `<base>` tag in the `head`, its value will be
 * ignored in favor of this parameter **but note it affects all the
 * history.pushState() calls**, meaning that if you use a `<base>` tag, it's
 * `href` value **has to match this parameter** (ignoring anything after the
 * `#`).
 *
 * @example
 * ```js
 * // at https://example.com/folder
 * createWebHashHistory() // gives a url of `https://example.com/folder#`
 * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`
 * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`
 * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`
 * // you should avoid doing this because it changes the original url and breaks copying urls
 * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`
 *
 * // at file:///usr/etc/folder/index.html
 * // for locations with no `host`, the base is ignored
 * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`
 * ```
 */
function createWebHashHistory(base) {
    // Make sure this implementation is fine in terms of encoding, specially for IE11
    // for `file://`, directly use the pathname and ignore the base
    // location.pathname contains an initial `/` even at the root: `https://example.com`
    base = location.host ? base || location.pathname + location.search : '';
    // allow the user to provide a `#` in the middle: `/base/#/app`
    if (!base.includes('#'))
        base += '#';
    if (( true) && !base.endsWith('#/') && !base.endsWith('#')) {
        warn(`A hash base must end with a "#":\n"${base}" should be "${base.replace(/#.*$/, '#')}".`);
    }
    return createWebHistory(base);
}

function isRouteLocation(route) {
    return typeof route === 'string' || (route && typeof route === 'object');
}
function isRouteName(name) {
    return typeof name === 'string' || typeof name === 'symbol';
}

/**
 * Initial route location where the router is. Can be used in navigation guards
 * to differentiate the initial navigation.
 *
 * @example
 * ```js
 * import { START_LOCATION } from 'vue-router'
 *
 * router.beforeEach((to, from) => {
 *   if (from === START_LOCATION) {
 *     // initial navigation
 *   }
 * })
 * ```
 */
const START_LOCATION_NORMALIZED = {
    path: '/',
    name: undefined,
    params: {},
    query: {},
    hash: '',
    fullPath: '/',
    matched: [],
    meta: {},
    redirectedFrom: undefined,
};

const NavigationFailureSymbol = /*#__PURE__*/ PolySymbol(( true) ? 'navigation failure' : 0);
/**
 * Enumeration with all possible types for navigation failures. Can be passed to
 * {@link isNavigationFailure} to check for specific failures.
 */
var NavigationFailureType;
(function (NavigationFailureType) {
    /**
     * An aborted navigation is a navigation that failed because a navigation
     * guard returned `false` or called `next(false)`
     */
    NavigationFailureType[NavigationFailureType["aborted"] = 4] = "aborted";
    /**
     * A cancelled navigation is a navigation that failed because a more recent
     * navigation finished started (not necessarily finished).
     */
    NavigationFailureType[NavigationFailureType["cancelled"] = 8] = "cancelled";
    /**
     * A duplicated navigation is a navigation that failed because it was
     * initiated while already being at the exact same location.
     */
    NavigationFailureType[NavigationFailureType["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
// DEV only debug messages
const ErrorTypeMessages = {
    [1 /* MATCHER_NOT_FOUND */]({ location, currentLocation }) {
        return `No match for\n ${JSON.stringify(location)}${currentLocation
            ? '\nwhile being at\n' + JSON.stringify(currentLocation)
            : ''}`;
    },
    [2 /* NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {
        return `Redirected from "${from.fullPath}" to "${stringifyRoute(to)}" via a navigation guard.`;
    },
    [4 /* NAVIGATION_ABORTED */]({ from, to }) {
        return `Navigation aborted from "${from.fullPath}" to "${to.fullPath}" via a navigation guard.`;
    },
    [8 /* NAVIGATION_CANCELLED */]({ from, to }) {
        return `Navigation cancelled from "${from.fullPath}" to "${to.fullPath}" with a new navigation.`;
    },
    [16 /* NAVIGATION_DUPLICATED */]({ from, to }) {
        return `Avoided redundant navigation to current location: "${from.fullPath}".`;
    },
};
function createRouterError(type, params) {
    // keep full error messages in cjs versions
    if (true) {
        return assign(new Error(ErrorTypeMessages[type](params)), {
            type,
            [NavigationFailureSymbol]: true,
        }, params);
    }
    else {}
}
function isNavigationFailure(error, type) {
    return (error instanceof Error &&
        NavigationFailureSymbol in error &&
        (type == null || !!(error.type & type)));
}
const propertiesToLog = ['params', 'query', 'hash'];
function stringifyRoute(to) {
    if (typeof to === 'string')
        return to;
    if ('path' in to)
        return to.path;
    const location = {};
    for (const key of propertiesToLog) {
        if (key in to)
            location[key] = to[key];
    }
    return JSON.stringify(location, null, 2);
}

// default pattern for a param: non greedy everything but /
const BASE_PARAM_PATTERN = '[^/]+?';
const BASE_PATH_PARSER_OPTIONS = {
    sensitive: false,
    strict: false,
    start: true,
    end: true,
};
// Special Regex characters that must be escaped in static tokens
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
/**
 * Creates a path parser from an array of Segments (a segment is an array of Tokens)
 *
 * @param segments - array of segments returned by tokenizePath
 * @param extraOptions - optional options for the regexp
 * @returns a PathParser
 */
function tokensToParser(segments, extraOptions) {
    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
    // the amount of scores is the same as the length of segments except for the root segment "/"
    let score = [];
    // the regexp as a string
    let pattern = options.start ? '^' : '';
    // extracted keys
    const keys = [];
    for (const segment of segments) {
        // the root segment needs special treatment
        const segmentScores = segment.length ? [] : [90 /* Root */];
        // allow trailing slash
        if (options.strict && !segment.length)
            pattern += '/';
        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
            const token = segment[tokenIndex];
            // resets the score if we are inside a sub segment /:a-other-:b
            let subSegmentScore = 40 /* Segment */ +
                (options.sensitive ? 0.25 /* BonusCaseSensitive */ : 0);
            if (token.type === 0 /* Static */) {
                // prepend the slash if we are starting a new segment
                if (!tokenIndex)
                    pattern += '/';
                pattern += token.value.replace(REGEX_CHARS_RE, '\\$&');
                subSegmentScore += 40 /* Static */;
            }
            else if (token.type === 1 /* Param */) {
                const { value, repeatable, optional, regexp } = token;
                keys.push({
                    name: value,
                    repeatable,
                    optional,
                });
                const re = regexp ? regexp : BASE_PARAM_PATTERN;
                // the user provided a custom regexp /:id(\\d+)
                if (re !== BASE_PARAM_PATTERN) {
                    subSegmentScore += 10 /* BonusCustomRegExp */;
                    // make sure the regexp is valid before using it
                    try {
                        new RegExp(`(${re})`);
                    }
                    catch (err) {
                        throw new Error(`Invalid custom RegExp for param "${value}" (${re}): ` +
                            err.message);
                    }
                }
                // when we repeat we must take care of the repeating leading slash
                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;
                // prepend the slash if we are starting a new segment
                if (!tokenIndex)
                    subPattern =
                        // avoid an optional / if there are more segments e.g. /:p?-static
                        // or /:p?-:p2
                        optional && segment.length < 2
                            ? `(?:/${subPattern})`
                            : '/' + subPattern;
                if (optional)
                    subPattern += '?';
                pattern += subPattern;
                subSegmentScore += 20 /* Dynamic */;
                if (optional)
                    subSegmentScore += -8 /* BonusOptional */;
                if (repeatable)
                    subSegmentScore += -20 /* BonusRepeatable */;
                if (re === '.*')
                    subSegmentScore += -50 /* BonusWildcard */;
            }
            segmentScores.push(subSegmentScore);
        }
        // an empty array like /home/ -> [[{home}], []]
        // if (!segment.length) pattern += '/'
        score.push(segmentScores);
    }
    // only apply the strict bonus to the last score
    if (options.strict && options.end) {
        const i = score.length - 1;
        score[i][score[i].length - 1] += 0.7000000000000001 /* BonusStrict */;
    }
    // TODO: dev only warn double trailing slash
    if (!options.strict)
        pattern += '/?';
    if (options.end)
        pattern += '$';
    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else
    else if (options.strict)
        pattern += '(?:/|$)';
    const re = new RegExp(pattern, options.sensitive ? '' : 'i');
    function parse(path) {
        const match = path.match(re);
        const params = {};
        if (!match)
            return null;
        for (let i = 1; i < match.length; i++) {
            const value = match[i] || '';
            const key = keys[i - 1];
            params[key.name] = value && key.repeatable ? value.split('/') : value;
        }
        return params;
    }
    function stringify(params) {
        let path = '';
        // for optional parameters to allow to be empty
        let avoidDuplicatedSlash = false;
        for (const segment of segments) {
            if (!avoidDuplicatedSlash || !path.endsWith('/'))
                path += '/';
            avoidDuplicatedSlash = false;
            for (const token of segment) {
                if (token.type === 0 /* Static */) {
                    path += token.value;
                }
                else if (token.type === 1 /* Param */) {
                    const { value, repeatable, optional } = token;
                    const param = value in params ? params[value] : '';
                    if (Array.isArray(param) && !repeatable)
                        throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
                    const text = Array.isArray(param) ? param.join('/') : param;
                    if (!text) {
                        if (optional) {
                            // if we have more than one optional param like /:a?-static we
                            // don't need to care about the optional param
                            if (segment.length < 2) {
                                // remove the last slash as we could be at the end
                                if (path.endsWith('/'))
                                    path = path.slice(0, -1);
                                // do not append a slash on the next iteration
                                else
                                    avoidDuplicatedSlash = true;
                            }
                        }
                        else
                            throw new Error(`Missing required param "${value}"`);
                    }
                    path += text;
                }
            }
        }
        return path;
    }
    return {
        re,
        score,
        keys,
        parse,
        stringify,
    };
}
/**
 * Compares an array of numbers as used in PathParser.score and returns a
 * number. This function can be used to `sort` an array
 * @param a - first array of numbers
 * @param b - second array of numbers
 * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
 * should be sorted first
 */
function compareScoreArray(a, b) {
    let i = 0;
    while (i < a.length && i < b.length) {
        const diff = b[i] - a[i];
        // only keep going if diff === 0
        if (diff)
            return diff;
        i++;
    }
    // if the last subsegment was Static, the shorter segments should be sorted first
    // otherwise sort the longest segment first
    if (a.length < b.length) {
        return a.length === 1 && a[0] === 40 /* Static */ + 40 /* Segment */
            ? -1
            : 1;
    }
    else if (a.length > b.length) {
        return b.length === 1 && b[0] === 40 /* Static */ + 40 /* Segment */
            ? 1
            : -1;
    }
    return 0;
}
/**
 * Compare function that can be used with `sort` to sort an array of PathParser
 * @param a - first PathParser
 * @param b - second PathParser
 * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
 */
function comparePathParserScore(a, b) {
    let i = 0;
    const aScore = a.score;
    const bScore = b.score;
    while (i < aScore.length && i < bScore.length) {
        const comp = compareScoreArray(aScore[i], bScore[i]);
        // do not return if both are equal
        if (comp)
            return comp;
        i++;
    }
    // if a and b share the same score entries but b has more, sort b first
    return bScore.length - aScore.length;
    // this is the ternary version
    // return aScore.length < bScore.length
    //   ? 1
    //   : aScore.length > bScore.length
    //   ? -1
    //   : 0
}

const ROOT_TOKEN = {
    type: 0 /* Static */,
    value: '',
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
// After some profiling, the cache seems to be unnecessary because tokenizePath
// (the slowest part of adding a route) is very fast
// const tokenCache = new Map<string, Token[][]>()
function tokenizePath(path) {
    if (!path)
        return [[]];
    if (path === '/')
        return [[ROOT_TOKEN]];
    if (!path.startsWith('/')) {
        throw new Error(( true)
            ? `Route paths should start with a "/": "${path}" should be "/${path}".`
            : 0);
    }
    // if (tokenCache.has(path)) return tokenCache.get(path)!
    function crash(message) {
        throw new Error(`ERR (${state})/"${buffer}": ${message}`);
    }
    let state = 0 /* Static */;
    let previousState = state;
    const tokens = [];
    // the segment will always be valid because we get into the initial state
    // with the leading /
    let segment;
    function finalizeSegment() {
        if (segment)
            tokens.push(segment);
        segment = [];
    }
    // index on the path
    let i = 0;
    // char at index
    let char;
    // buffer of the value read
    let buffer = '';
    // custom regexp for a param
    let customRe = '';
    function consumeBuffer() {
        if (!buffer)
            return;
        if (state === 0 /* Static */) {
            segment.push({
                type: 0 /* Static */,
                value: buffer,
            });
        }
        else if (state === 1 /* Param */ ||
            state === 2 /* ParamRegExp */ ||
            state === 3 /* ParamRegExpEnd */) {
            if (segment.length > 1 && (char === '*' || char === '+'))
                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
            segment.push({
                type: 1 /* Param */,
                value: buffer,
                regexp: customRe,
                repeatable: char === '*' || char === '+',
                optional: char === '*' || char === '?',
            });
        }
        else {
            crash('Invalid state to consume buffer');
        }
        buffer = '';
    }
    function addCharToBuffer() {
        buffer += char;
    }
    while (i < path.length) {
        char = path[i++];
        if (char === '\\' && state !== 2 /* ParamRegExp */) {
            previousState = state;
            state = 4 /* EscapeNext */;
            continue;
        }
        switch (state) {
            case 0 /* Static */:
                if (char === '/') {
                    if (buffer) {
                        consumeBuffer();
                    }
                    finalizeSegment();
                }
                else if (char === ':') {
                    consumeBuffer();
                    state = 1 /* Param */;
                }
                else {
                    addCharToBuffer();
                }
                break;
            case 4 /* EscapeNext */:
                addCharToBuffer();
                state = previousState;
                break;
            case 1 /* Param */:
                if (char === '(') {
                    state = 2 /* ParamRegExp */;
                }
                else if (VALID_PARAM_RE.test(char)) {
                    addCharToBuffer();
                }
                else {
                    consumeBuffer();
                    state = 0 /* Static */;
                    // go back one character if we were not modifying
                    if (char !== '*' && char !== '?' && char !== '+')
                        i--;
                }
                break;
            case 2 /* ParamRegExp */:
                // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)
                // it already works by escaping the closing )
                // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#
                // is this really something people need since you can also write
                // /prefix_:p()_suffix
                if (char === ')') {
                    // handle the escaped )
                    if (customRe[customRe.length - 1] == '\\')
                        customRe = customRe.slice(0, -1) + char;
                    else
                        state = 3 /* ParamRegExpEnd */;
                }
                else {
                    customRe += char;
                }
                break;
            case 3 /* ParamRegExpEnd */:
                // same as finalizing a param
                consumeBuffer();
                state = 0 /* Static */;
                // go back one character if we were not modifying
                if (char !== '*' && char !== '?' && char !== '+')
                    i--;
                customRe = '';
                break;
            default:
                crash('Unknown state');
                break;
        }
    }
    if (state === 2 /* ParamRegExp */)
        crash(`Unfinished custom RegExp for param "${buffer}"`);
    consumeBuffer();
    finalizeSegment();
    // tokenCache.set(path, tokens)
    return tokens;
}

function createRouteRecordMatcher(record, parent, options) {
    const parser = tokensToParser(tokenizePath(record.path), options);
    // warn against params with the same name
    if ((true)) {
        const existingKeys = new Set();
        for (const key of parser.keys) {
            if (existingKeys.has(key.name))
                warn(`Found duplicated params with name "${key.name}" for path "${record.path}". Only the last one will be available on "$route.params".`);
            existingKeys.add(key.name);
        }
    }
    const matcher = assign(parser, {
        record,
        parent,
        // these needs to be populated by the parent
        children: [],
        alias: [],
    });
    if (parent) {
        // both are aliases or both are not aliases
        // we don't want to mix them because the order is used when
        // passing originalRecord in Matcher.addRoute
        if (!matcher.record.aliasOf === !parent.record.aliasOf)
            parent.children.push(matcher);
    }
    return matcher;
}

/**
 * Creates a Router Matcher.
 *
 * @internal
 * @param routes - array of initial routes
 * @param globalOptions - global route options
 */
function createRouterMatcher(routes, globalOptions) {
    // normalized ordered array of matchers
    const matchers = [];
    const matcherMap = new Map();
    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
    function getRecordMatcher(name) {
        return matcherMap.get(name);
    }
    function addRoute(record, parent, originalRecord) {
        // used later on to remove by name
        let isRootAdd = !originalRecord;
        let mainNormalizedRecord = normalizeRouteRecord(record);
        // we might be the child of an alias
        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
        const options = mergeOptions(globalOptions, record);
        // generate an array of records to correctly handle aliases
        const normalizedRecords = [
            mainNormalizedRecord,
        ];
        if ('alias' in record) {
            const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;
            for (const alias of aliases) {
                normalizedRecords.push(assign({}, mainNormalizedRecord, {
                    // this allows us to hold a copy of the `components` option
                    // so that async components cache is hold on the original record
                    components: originalRecord
                        ? originalRecord.record.components
                        : mainNormalizedRecord.components,
                    path: alias,
                    // we might be the child of an alias
                    aliasOf: originalRecord
                        ? originalRecord.record
                        : mainNormalizedRecord,
                    // the aliases are always of the same kind as the original since they
                    // are defined on the same record
                }));
            }
        }
        let matcher;
        let originalMatcher;
        for (const normalizedRecord of normalizedRecords) {
            let { path } = normalizedRecord;
            // Build up the path for nested routes if the child isn't an absolute
            // route. Only add the / delimiter if the child path isn't empty and if the
            // parent path doesn't have a trailing slash
            if (parent && path[0] !== '/') {
                let parentPath = parent.record.path;
                let connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';
                normalizedRecord.path =
                    parent.record.path + (path && connectingSlash + path);
            }
            if (( true) && normalizedRecord.path === '*') {
                throw new Error('Catch all routes ("*") must now be defined using a param with a custom regexp.\n' +
                    'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');
            }
            // create the object before hand so it can be passed to children
            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
            if (( true) && parent && path[0] === '/')
                checkMissingParamsInAbsolutePath(matcher, parent);
            // if we are an alias we must tell the original record that we exist
            // so we can be removed
            if (originalRecord) {
                originalRecord.alias.push(matcher);
                if ((true)) {
                    checkSameParams(originalRecord, matcher);
                }
            }
            else {
                // otherwise, the first record is the original and others are aliases
                originalMatcher = originalMatcher || matcher;
                if (originalMatcher !== matcher)
                    originalMatcher.alias.push(matcher);
                // remove the route if named and only for the top record (avoid in nested calls)
                // this works because the original record is the first one
                if (isRootAdd && record.name && !isAliasRecord(matcher))
                    removeRoute(record.name);
            }
            if ('children' in mainNormalizedRecord) {
                let children = mainNormalizedRecord.children;
                for (let i = 0; i < children.length; i++) {
                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
                }
            }
            // if there was no original record, then the first one was not an alias and all
            // other alias (if any) need to reference this record when adding children
            originalRecord = originalRecord || matcher;
            // TODO: add normalized records for more flexibility
            // if (parent && isAliasRecord(originalRecord)) {
            //   parent.children.push(originalRecord)
            // }
            insertMatcher(matcher);
        }
        return originalMatcher
            ? () => {
                // since other matchers are aliases, they should be removed by the original matcher
                removeRoute(originalMatcher);
            }
            : noop;
    }
    function removeRoute(matcherRef) {
        if (isRouteName(matcherRef)) {
            const matcher = matcherMap.get(matcherRef);
            if (matcher) {
                matcherMap.delete(matcherRef);
                matchers.splice(matchers.indexOf(matcher), 1);
                matcher.children.forEach(removeRoute);
                matcher.alias.forEach(removeRoute);
            }
        }
        else {
            let index = matchers.indexOf(matcherRef);
            if (index > -1) {
                matchers.splice(index, 1);
                if (matcherRef.record.name)
                    matcherMap.delete(matcherRef.record.name);
                matcherRef.children.forEach(removeRoute);
                matcherRef.alias.forEach(removeRoute);
            }
        }
    }
    function getRoutes() {
        return matchers;
    }
    function insertMatcher(matcher) {
        let i = 0;
        // console.log('i is', { i })
        while (i < matchers.length &&
            comparePathParserScore(matcher, matchers[i]) >= 0)
            i++;
        // console.log('END i is', { i })
        // while (i < matchers.length && matcher.score <= matchers[i].score) i++
        matchers.splice(i, 0, matcher);
        // only add the original record to the name map
        if (matcher.record.name && !isAliasRecord(matcher))
            matcherMap.set(matcher.record.name, matcher);
    }
    function resolve(location, currentLocation) {
        let matcher;
        let params = {};
        let path;
        let name;
        if ('name' in location && location.name) {
            matcher = matcherMap.get(location.name);
            if (!matcher)
                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {
                    location,
                });
            name = matcher.record.name;
            params = assign(
            // paramsFromLocation is a new object
            paramsFromLocation(currentLocation.params, 
            // only keep params that exist in the resolved location
            // TODO: only keep optional params coming from a parent record
            matcher.keys.filter(k => !k.optional).map(k => k.name)), location.params);
            // throws if cannot be stringified
            path = matcher.stringify(params);
        }
        else if ('path' in location) {
            // no need to resolve the path with the matcher as it was provided
            // this also allows the user to control the encoding
            path = location.path;
            if (( true) && !path.startsWith('/')) {
                warn(`The Matcher cannot resolve relative paths but received "${path}". Unless you directly called \`matcher.resolve("${path}")\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-router-next.`);
            }
            matcher = matchers.find(m => m.re.test(path));
            // matcher should have a value after the loop
            if (matcher) {
                // TODO: dev warning of unused params if provided
                // we know the matcher works because we tested the regexp
                params = matcher.parse(path);
                name = matcher.record.name;
            }
            // location is a relative path
        }
        else {
            // match by name or path of current route
            matcher = currentLocation.name
                ? matcherMap.get(currentLocation.name)
                : matchers.find(m => m.re.test(currentLocation.path));
            if (!matcher)
                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {
                    location,
                    currentLocation,
                });
            name = matcher.record.name;
            // since we are navigating to the same location, we don't need to pick the
            // params like when `name` is provided
            params = assign({}, currentLocation.params, location.params);
            path = matcher.stringify(params);
        }
        const matched = [];
        let parentMatcher = matcher;
        while (parentMatcher) {
            // reversed order so parents are at the beginning
            matched.unshift(parentMatcher.record);
            parentMatcher = parentMatcher.parent;
        }
        return {
            name,
            path,
            params,
            matched,
            meta: mergeMetaFields(matched),
        };
    }
    // add initial routes
    routes.forEach(route => addRoute(route));
    return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys) {
    let newParams = {};
    for (let key of keys) {
        if (key in params)
            newParams[key] = params[key];
    }
    return newParams;
}
/**
 * Normalizes a RouteRecordRaw. Creates a copy
 *
 * @param record
 * @returns the normalized version
 */
function normalizeRouteRecord(record) {
    return {
        path: record.path,
        redirect: record.redirect,
        name: record.name,
        meta: record.meta || {},
        aliasOf: undefined,
        beforeEnter: record.beforeEnter,
        props: normalizeRecordProps(record),
        children: record.children || [],
        instances: {},
        leaveGuards: new Set(),
        updateGuards: new Set(),
        enterCallbacks: {},
        components: 'components' in record
            ? record.components || {}
            : { default: record.component },
    };
}
/**
 * Normalize the optional `props` in a record to always be an object similar to
 * components. Also accept a boolean for components.
 * @param record
 */
function normalizeRecordProps(record) {
    const propsObject = {};
    // props does not exist on redirect records but we can set false directly
    const props = record.props || false;
    if ('component' in record) {
        propsObject.default = props;
    }
    else {
        // NOTE: we could also allow a function to be applied to every component.
        // Would need user feedback for use cases
        for (let name in record.components)
            propsObject[name] = typeof props === 'boolean' ? props : props[name];
    }
    return propsObject;
}
/**
 * Checks if a record or any of its parent is an alias
 * @param record
 */
function isAliasRecord(record) {
    while (record) {
        if (record.record.aliasOf)
            return true;
        record = record.parent;
    }
    return false;
}
/**
 * Merge meta fields of an array of records
 *
 * @param matched - array of matched records
 */
function mergeMetaFields(matched) {
    return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
    let options = {};
    for (let key in defaults) {
        options[key] =
            key in partialOptions ? partialOptions[key] : defaults[key];
    }
    return options;
}
function isSameParam(a, b) {
    return (a.name === b.name &&
        a.optional === b.optional &&
        a.repeatable === b.repeatable);
}
/**
 * Check if a path and its alias have the same required params
 *
 * @param a - original record
 * @param b - alias record
 */
function checkSameParams(a, b) {
    for (let key of a.keys) {
        if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))
            return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" should have the exact same param named "${key.name}"`);
    }
    for (let key of b.keys) {
        if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))
            return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" should have the exact same param named "${key.name}"`);
    }
}
function checkMissingParamsInAbsolutePath(record, parent) {
    for (let key of parent.keys) {
        if (!record.keys.find(isSameParam.bind(null, key)))
            return warn(`Absolute path "${record.record.path}" should have the exact same param named "${key.name}" as its parent "${parent.record.path}".`);
    }
}

/**
 * Encoding Rules ␣ = Space Path: ␣ " < > # ? { } Query: ␣ " < > # & = Hash: ␣ "
 * < > `
 *
 * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)
 * defines some extra characters to be encoded. Most browsers do not encode them
 * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to
 * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)
 * plus `-._~`. This extra safety should be applied to query by patching the
 * string returned by encodeURIComponent encodeURI also encodes `[\]^`. `\`
 * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\`
 * into a `/` if directly typed in. The _backtick_ (`````) should also be
 * encoded everywhere because some browsers like FF encode it when directly
 * written while others don't. Safari and IE don't encode ``"<>{}``` in hash.
 */
// const EXTRA_RESERVED_RE = /[!'()*]/g
// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)
const HASH_RE = /#/g; // %23
const AMPERSAND_RE = /&/g; // %26
const SLASH_RE = /\//g; // %2F
const EQUAL_RE = /=/g; // %3D
const IM_RE = /\?/g; // %3F
const PLUS_RE = /\+/g; // %2B
/**
 * NOTE: It's not clear to me if we should encode the + symbol in queries, it
 * seems to be less flexible than not doing so and I can't find out the legacy
 * systems requiring this for regular requests like text/html. In the standard,
 * the encoding of the plus character is only mentioned for
 * application/x-www-form-urlencoded
 * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo
 * leave the plus character as is in queries. To be more flexible, we allow the
 * plus character on the query but it can also be manually encoded by the user.
 *
 * Resources:
 * - https://url.spec.whatwg.org/#urlencoded-parsing
 * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20
 */
const ENC_BRACKET_OPEN_RE = /%5B/g; // [
const ENC_BRACKET_CLOSE_RE = /%5D/g; // ]
const ENC_CARET_RE = /%5E/g; // ^
const ENC_BACKTICK_RE = /%60/g; // `
const ENC_CURLY_OPEN_RE = /%7B/g; // {
const ENC_PIPE_RE = /%7C/g; // |
const ENC_CURLY_CLOSE_RE = /%7D/g; // }
const ENC_SPACE_RE = /%20/g; // }
/**
 * Encode characters that need to be encoded on the path, search and hash
 * sections of the URL.
 *
 * @internal
 * @param text - string to encode
 * @returns encoded string
 */
function commonEncode(text) {
    return encodeURI('' + text)
        .replace(ENC_PIPE_RE, '|')
        .replace(ENC_BRACKET_OPEN_RE, '[')
        .replace(ENC_BRACKET_CLOSE_RE, ']');
}
/**
 * Encode characters that need to be encoded on the hash section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodeHash(text) {
    return commonEncode(text)
        .replace(ENC_CURLY_OPEN_RE, '{')
        .replace(ENC_CURLY_CLOSE_RE, '}')
        .replace(ENC_CARET_RE, '^');
}
/**
 * Encode characters that need to be encoded query values on the query
 * section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodeQueryValue(text) {
    return (commonEncode(text)
        // Encode the space as +, encode the + to differentiate it from the space
        .replace(PLUS_RE, '%2B')
        .replace(ENC_SPACE_RE, '+')
        .replace(HASH_RE, '%23')
        .replace(AMPERSAND_RE, '%26')
        .replace(ENC_BACKTICK_RE, '`')
        .replace(ENC_CURLY_OPEN_RE, '{')
        .replace(ENC_CURLY_CLOSE_RE, '}')
        .replace(ENC_CARET_RE, '^'));
}
/**
 * Like `encodeQueryValue` but also encodes the `=` character.
 *
 * @param text - string to encode
 */
function encodeQueryKey(text) {
    return encodeQueryValue(text).replace(EQUAL_RE, '%3D');
}
/**
 * Encode characters that need to be encoded on the path section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodePath(text) {
    return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');
}
/**
 * Encode characters that need to be encoded on the path section of the URL as a
 * param. This function encodes everything {@link encodePath} does plus the
 * slash (`/`) character.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodeParam(text) {
    return encodePath(text).replace(SLASH_RE, '%2F');
}
/**
 * Decode text using `decodeURIComponent`. Returns the original text if it
 * fails.
 *
 * @param text - string to decode
 * @returns decoded string
 */
function decode(text) {
    try {
        return decodeURIComponent('' + text);
    }
    catch (err) {
        ( true) && warn(`Error decoding "${text}". Using original value`);
    }
    return '' + text;
}

/**
 * Transforms a queryString into a {@link LocationQuery} object. Accept both, a
 * version with the leading `?` and without Should work as URLSearchParams

 * @internal
 *
 * @param search - search string to parse
 * @returns a query object
 */
function parseQuery(search) {
    const query = {};
    // avoid creating an object with an empty key and empty value
    // because of split('&')
    if (search === '' || search === '?')
        return query;
    const hasLeadingIM = search[0] === '?';
    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');
    for (let i = 0; i < searchParams.length; ++i) {
        // pre decode the + into space
        const searchParam = searchParams[i].replace(PLUS_RE, ' ');
        // allow the = character
        let eqPos = searchParam.indexOf('=');
        let key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
        let value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
        if (key in query) {
            // an extra variable for ts types
            let currentValue = query[key];
            if (!Array.isArray(currentValue)) {
                currentValue = query[key] = [currentValue];
            }
            currentValue.push(value);
        }
        else {
            query[key] = value;
        }
    }
    return query;
}
/**
 * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it
 * doesn't prepend a `?`
 *
 * @internal
 *
 * @param query - query object to stringify
 * @returns string version of the query without the leading `?`
 */
function stringifyQuery(query) {
    let search = '';
    for (let key in query) {
        const value = query[key];
        key = encodeQueryKey(key);
        if (value == null) {
            // only null adds the value
            if (value !== undefined) {
                search += (search.length ? '&' : '') + key;
            }
            continue;
        }
        // keep null values
        let values = Array.isArray(value)
            ? value.map(v => v && encodeQueryValue(v))
            : [value && encodeQueryValue(value)];
        values.forEach(value => {
            // skip undefined values in arrays as if they were not present
            // smaller code than using filter
            if (value !== undefined) {
                // only append & with non-empty search
                search += (search.length ? '&' : '') + key;
                if (value != null)
                    search += '=' + value;
            }
        });
    }
    return search;
}
/**
 * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting
 * numbers into strings, removing keys with an undefined value and replacing
 * undefined with null in arrays
 *
 * @param query - query object to normalize
 * @returns a normalized query object
 */
function normalizeQuery(query) {
    const normalizedQuery = {};
    for (let key in query) {
        let value = query[key];
        if (value !== undefined) {
            normalizedQuery[key] = Array.isArray(value)
                ? value.map(v => (v == null ? null : '' + v))
                : value == null
                    ? value
                    : '' + value;
        }
    }
    return normalizedQuery;
}

/**
 * Create a list of callbacks that can be reset. Used to create before and after navigation guards list
 */
function useCallbacks() {
    let handlers = [];
    function add(handler) {
        handlers.push(handler);
        return () => {
            const i = handlers.indexOf(handler);
            if (i > -1)
                handlers.splice(i, 1);
        };
    }
    function reset() {
        handlers = [];
    }
    return {
        add,
        list: () => handlers,
        reset,
    };
}

function registerGuard(record, name, guard) {
    const removeFromList = () => {
        record[name].delete(guard);
    };
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(removeFromList);
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onDeactivated)(removeFromList);
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onActivated)(() => {
        record[name].add(guard);
    });
    record[name].add(guard);
}
/**
 * Add a navigation guard that triggers whenever the component for the current
 * location is about to be left. Similar to {@link beforeRouteLeave} but can be
 * used in any component. The guard is removed when the component is unmounted.
 *
 * @param leaveGuard - {@link NavigationGuard}
 */
function onBeforeRouteLeave(leaveGuard) {
    if (( true) && !(0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)()) {
        warn('getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function');
        return;
    }
    const activeRecord = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(matchedRouteKey, {}).value;
    if (!activeRecord) {
        ( true) &&
            warn('No active route record was found. Are you missing a <router-view> component?');
        return;
    }
    registerGuard(activeRecord, 'leaveGuards', leaveGuard);
}
/**
 * Add a navigation guard that triggers whenever the current location is about
 * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any
 * component. The guard is removed when the component is unmounted.
 *
 * @param updateGuard - {@link NavigationGuard}
 */
function onBeforeRouteUpdate(updateGuard) {
    if (( true) && !(0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)()) {
        warn('getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function');
        return;
    }
    const activeRecord = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(matchedRouteKey, {}).value;
    if (!activeRecord) {
        ( true) &&
            warn('No active route record was found. Are you missing a <router-view> component?');
        return;
    }
    registerGuard(activeRecord, 'updateGuards', updateGuard);
}
function guardToPromiseFn(guard, to, from, record, name) {
    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place
    const enterCallbackArray = record &&
        // name is defined if record is because of the function overload
        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
    return () => new Promise((resolve, reject) => {
        const next = (valid) => {
            if (valid === false)
                reject(createRouterError(4 /* NAVIGATION_ABORTED */, {
                    from,
                    to,
                }));
            else if (valid instanceof Error) {
                reject(valid);
            }
            else if (isRouteLocation(valid)) {
                reject(createRouterError(2 /* NAVIGATION_GUARD_REDIRECT */, {
                    from: to,
                    to: valid,
                }));
            }
            else {
                if (enterCallbackArray &&
                    // since enterCallbackArray is truthy, both record and name also are
                    record.enterCallbacks[name] === enterCallbackArray &&
                    typeof valid === 'function')
                    enterCallbackArray.push(valid);
                resolve();
            }
        };
        // wrapping with Promise.resolve allows it to work with both async and sync guards
        const guardReturn = guard.call(record && record.instances[name], to, from, ( true) ? canOnlyBeCalledOnce(next, to, from) : 0);
        let guardCall = Promise.resolve(guardReturn);
        if (guard.length < 3)
            guardCall = guardCall.then(next);
        if (( true) && guard.length > 2) {
            const message = `The "next" callback was never called inside of ${guard.name ? '"' + guard.name + '"' : ''}:\n${guard.toString()}\n. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
            if (typeof guardReturn === 'object' && 'then' in guardReturn) {
                guardCall = guardCall.then(resolvedValue => {
                    // @ts-expect-error: _called is added at canOnlyBeCalledOnce
                    if (!next._called) {
                        warn(message);
                        return Promise.reject(new Error('Invalid navigation guard'));
                    }
                    return resolvedValue;
                });
                // TODO: test me!
            }
            else if (guardReturn !== undefined) {
                // @ts-expect-error: _called is added at canOnlyBeCalledOnce
                if (!next._called) {
                    warn(message);
                    reject(new Error('Invalid navigation guard'));
                    return;
                }
            }
        }
        guardCall.catch(err => reject(err));
    });
}
function canOnlyBeCalledOnce(next, to, from) {
    let called = 0;
    return function () {
        if (called++ === 1)
            warn(`The "next" callback was called more than once in one navigation guard when going from "${from.fullPath}" to "${to.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`);
        // @ts-expect-error: we put it in the original one because it's easier to check
        next._called = true;
        if (called === 1)
            next.apply(null, arguments);
    };
}
function extractComponentsGuards(matched, guardType, to, from) {
    const guards = [];
    for (const record of matched) {
        for (const name in record.components) {
            let rawComponent = record.components[name];
            if ((true)) {
                if (!rawComponent ||
                    (typeof rawComponent !== 'object' &&
                        typeof rawComponent !== 'function')) {
                    warn(`Component "${name}" in record with path "${record.path}" is not` +
                        ` a valid component. Received "${String(rawComponent)}".`);
                    // throw to ensure we stop here but warn to ensure the message isn't
                    // missed by the user
                    throw new Error('Invalid route component');
                }
                else if ('then' in rawComponent) {
                    // warn if user wrote import('/component.vue') instead of () =>
                    // import('./component.vue')
                    warn(`Component "${name}" in record with path "${record.path}" is a ` +
                        `Promise instead of a function that returns a Promise. Did you ` +
                        `write "import('./MyPage.vue')" instead of ` +
                        `"() => import('./MyPage.vue')" ? This will break in ` +
                        `production if not fixed.`);
                    let promise = rawComponent;
                    rawComponent = () => promise;
                }
                else if (rawComponent.__asyncLoader &&
                    // warn only once per component
                    !rawComponent.__warnedDefineAsync) {
                    rawComponent.__warnedDefineAsync = true;
                    warn(`Component "${name}" in record with path "${record.path}" is defined ` +
                        `using "defineAsyncComponent()". ` +
                        `Write "() => import('./MyPage.vue')" instead of ` +
                        `"defineAsyncComponent(() => import('./MyPage.vue'))".`);
                }
            }
            // skip update and leave guards if the route component is not mounted
            if (guardType !== 'beforeRouteEnter' && !record.instances[name])
                continue;
            if (isRouteComponent(rawComponent)) {
                // __vccOpts is added by vue-class-component and contain the regular options
                let options = rawComponent.__vccOpts || rawComponent;
                const guard = options[guardType];
                guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
            }
            else {
                // start requesting the chunk already
                let componentPromise = rawComponent();
                if (( true) && !('catch' in componentPromise)) {
                    warn(`Component "${name}" in record with path "${record.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`);
                    componentPromise = Promise.resolve(componentPromise);
                }
                guards.push(() => componentPromise.then(resolved => {
                    if (!resolved)
                        return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
                    const resolvedComponent = isESModule(resolved)
                        ? resolved.default
                        : resolved;
                    // replace the function with the resolved component
                    record.components[name] = resolvedComponent;
                    // __vccOpts is added by vue-class-component and contain the regular options
                    let options = resolvedComponent.__vccOpts || resolvedComponent;
                    const guard = options[guardType];
                    return guard && guardToPromiseFn(guard, to, from, record, name)();
                }));
            }
        }
    }
    return guards;
}
/**
 * Allows differentiating lazy components from functional components and vue-class-component
 * @param component
 */
function isRouteComponent(component) {
    return (typeof component === 'object' ||
        'displayName' in component ||
        'props' in component ||
        '__vccOpts' in component);
}

// TODO: we could allow currentRoute as a prop to expose `isActive` and
// `isExactActive` behavior should go through an RFC
function useLink(props) {
    const router = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routerKey);
    const currentRoute = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routeLocationKey);
    const route = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => router.resolve((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(props.to)));
    const activeRecordIndex = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
        let { matched } = route.value;
        let { length } = matched;
        const routeMatched = matched[length - 1];
        let currentMatched = currentRoute.matched;
        if (!routeMatched || !currentMatched.length)
            return -1;
        let index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
        if (index > -1)
            return index;
        // possible parent record
        let parentRecordPath = getOriginalPath(matched[length - 2]);
        return (
        // we are dealing with nested routes
        length > 1 &&
            // if the parent and matched route have the same path, this link is
            // referring to the empty child. Or we currently are on a different
            // child of the same parent
            getOriginalPath(routeMatched) === parentRecordPath &&
            // avoid comparing the child with its parent
            currentMatched[currentMatched.length - 1].path !== parentRecordPath
            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))
            : index);
    });
    const isActive = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => activeRecordIndex.value > -1 &&
        includesParams(currentRoute.params, route.value.params));
    const isExactActive = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => activeRecordIndex.value > -1 &&
        activeRecordIndex.value === currentRoute.matched.length - 1 &&
        isSameRouteLocationParams(currentRoute.params, route.value.params));
    function navigate(e = {}) {
        if (guardEvent(e)) {
            return router[(0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(props.replace) ? 'replace' : 'push']((0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(props.to)
            // avoid uncaught errors are they are logged anyway
            ).catch(noop);
        }
        return Promise.resolve();
    }
    // devtools only
    if (( true) && isBrowser) {
        const instance = (0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
        if (instance) {
            const linkContextDevtools = {
                route: route.value,
                isActive: isActive.value,
                isExactActive: isExactActive.value,
            };
            // @ts-expect-error: this is internal
            instance.__vrl_devtools = instance.__vrl_devtools || [];
            // @ts-expect-error: this is internal
            instance.__vrl_devtools.push(linkContextDevtools);
            (0,vue__WEBPACK_IMPORTED_MODULE_0__.watchEffect)(() => {
                linkContextDevtools.route = route.value;
                linkContextDevtools.isActive = isActive.value;
                linkContextDevtools.isExactActive = isExactActive.value;
            }, { flush: 'post' });
        }
    }
    return {
        route,
        href: (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => route.value.href),
        isActive,
        isExactActive,
        navigate,
    };
}
const RouterLinkImpl = /*#__PURE__*/ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
    name: 'RouterLink',
    props: {
        to: {
            type: [String, Object],
            required: true,
        },
        replace: Boolean,
        activeClass: String,
        // inactiveClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: 'page',
        },
    },
    useLink,
    setup(props, { slots }) {
        const link = (0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)(useLink(props));
        const { options } = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routerKey);
        const elClass = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => ({
            [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,
            // [getLinkClass(
            //   props.inactiveClass,
            //   options.linkInactiveClass,
            //   'router-link-inactive'
            // )]: !link.isExactActive,
            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive,
        }));
        return () => {
            const children = slots.default && slots.default(link);
            return props.custom
                ? children
                : (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)('a', {
                    'aria-current': link.isExactActive
                        ? props.ariaCurrentValue
                        : null,
                    href: link.href,
                    // this would override user added attrs but Vue will still add
                    // the listener so we end up triggering both
                    onClick: link.navigate,
                    class: elClass.value,
                }, children);
        };
    },
});
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
/**
 * Component to render a link that triggers a navigation on click.
 */
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
    // don't redirect with control keys
    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
        return;
    // don't redirect when preventDefault called
    if (e.defaultPrevented)
        return;
    // don't redirect on right click
    if (e.button !== undefined && e.button !== 0)
        return;
    // don't redirect if `target="_blank"`
    // @ts-expect-error getAttribute does exist
    if (e.currentTarget && e.currentTarget.getAttribute) {
        // @ts-expect-error getAttribute exists
        const target = e.currentTarget.getAttribute('target');
        if (/\b_blank\b/i.test(target))
            return;
    }
    // this may be a Weex event which doesn't have this method
    if (e.preventDefault)
        e.preventDefault();
    return true;
}
function includesParams(outer, inner) {
    for (let key in inner) {
        let innerValue = inner[key];
        let outerValue = outer[key];
        if (typeof innerValue === 'string') {
            if (innerValue !== outerValue)
                return false;
        }
        else {
            if (!Array.isArray(outerValue) ||
                outerValue.length !== innerValue.length ||
                innerValue.some((value, i) => value !== outerValue[i]))
                return false;
        }
    }
    return true;
}
/**
 * Get the original path value of a record by following its aliasOf
 * @param record
 */
function getOriginalPath(record) {
    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : '';
}
/**
 * Utility class to get the active class based on defaults.
 * @param propClass
 * @param globalClass
 * @param defaultClass
 */
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null
    ? propClass
    : globalClass != null
        ? globalClass
        : defaultClass;

const RouterViewImpl = /*#__PURE__*/ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
    name: 'RouterView',
    // #674 we manually inherit them
    inheritAttrs: false,
    props: {
        name: {
            type: String,
            default: 'default',
        },
        route: Object,
    },
    setup(props, { attrs, slots }) {
        ( true) && warnDeprecatedUsage();
        const injectedRoute = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routerViewLocationKey);
        const routeToDisplay = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.route || injectedRoute.value);
        const depth = (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(viewDepthKey, 0);
        const matchedRouteRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => routeToDisplay.value.matched[depth]);
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(viewDepthKey, depth + 1);
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(matchedRouteKey, matchedRouteRef);
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.provide)(routerViewLocationKey, routeToDisplay);
        const viewRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)();
        // watch at the same time the component instance, the route record we are
        // rendering, and the name
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
            // copy reused instances
            if (to) {
                // this will update the instance for new instances as well as reused
                // instances when navigating to a new route
                to.instances[name] = instance;
                // the component instance is reused for a different route or name so
                // we copy any saved update or leave guards. With async setup, the
                // mounting component will mount before the matchedRoute changes,
                // making instance === oldInstance, so we check if guards have been
                // added before. This works because we remove guards when
                // unmounting/deactivating components
                if (from && from !== to && instance && instance === oldInstance) {
                    if (!to.leaveGuards.size) {
                        to.leaveGuards = from.leaveGuards;
                    }
                    if (!to.updateGuards.size) {
                        to.updateGuards = from.updateGuards;
                    }
                }
            }
            // trigger beforeRouteEnter next callbacks
            if (instance &&
                to &&
                // if there is no instance but to and from are the same this might be
                // the first visit
                (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
                (to.enterCallbacks[name] || []).forEach(callback => callback(instance));
            }
        }, { flush: 'post' });
        return () => {
            const route = routeToDisplay.value;
            const matchedRoute = matchedRouteRef.value;
            const ViewComponent = matchedRoute && matchedRoute.components[props.name];
            // we need the value at the time we render because when we unmount, we
            // navigated to a different location so the value is different
            const currentName = props.name;
            if (!ViewComponent) {
                return normalizeSlot(slots.default, { Component: ViewComponent, route });
            }
            // props from route configuration
            const routePropsOption = matchedRoute.props[props.name];
            const routeProps = routePropsOption
                ? routePropsOption === true
                    ? route.params
                    : typeof routePropsOption === 'function'
                        ? routePropsOption(route)
                        : routePropsOption
                : null;
            const onVnodeUnmounted = vnode => {
                // remove the instance reference to prevent leak
                if (vnode.component.isUnmounted) {
                    matchedRoute.instances[currentName] = null;
                }
            };
            const component = (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(ViewComponent, assign({}, routeProps, attrs, {
                onVnodeUnmounted,
                ref: viewRef,
            }));
            return (
            // pass the vnode to the slot as a prop.
            // h and <component :is="..."> both accept vnodes
            normalizeSlot(slots.default, { Component: component, route }) ||
                component);
        };
    },
});
function normalizeSlot(slot, data) {
    if (!slot)
        return null;
    const slotContent = slot(data);
    return slotContent.length === 1 ? slotContent[0] : slotContent;
}
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
/**
 * Component to display the current route the user is at.
 */
const RouterView = RouterViewImpl;
// warn against deprecated usage with <transition> & <keep-alive>
// due to functional component being no longer eager in Vue 3
function warnDeprecatedUsage() {
    const instance = (0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    const parentName = instance.parent && instance.parent.type.name;
    if (parentName &&
        (parentName === 'KeepAlive' || parentName.includes('Transition'))) {
        const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';
        warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\n` +
            `Use slot props instead:\n\n` +
            `<router-view v-slot="{ Component }">\n` +
            `  <${comp}>\n` +
            `    <component :is="Component" />\n` +
            `  </${comp}>\n` +
            `</router-view>`);
    }
}

function formatRouteLocation(routeLocation, tooltip) {
    const copy = assign({}, routeLocation, {
        // remove variables that can contain vue instances
        matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf'])),
    });
    return {
        _custom: {
            type: null,
            readOnly: true,
            display: routeLocation.fullPath,
            tooltip,
            value: copy,
        },
    };
}
function formatDisplay(display) {
    return {
        _custom: {
            display,
        },
    };
}
// to support multiple router instances
let routerId = 0;
function addDevtools(app, router, matcher) {
    // Take over router.beforeEach and afterEach
    // make sure we are not registering the devtool twice
    if (router.__hasDevtools)
        return;
    router.__hasDevtools = true;
    // increment to support multiple router instances
    const id = routerId++;
    (0,_vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__.setupDevtoolsPlugin)({
        id: 'org.vuejs.router' + (id ? '.' + id : ''),
        label: 'Vue Router',
        packageName: 'vue-router',
        homepage: 'https://next.router.vuejs.org/',
        logo: 'https://vuejs.org/images/icons/favicon-96x96.png',
        componentStateTypes: ['Routing'],
        app,
    }, api => {
        // display state added by the router
        api.on.inspectComponent((payload, ctx) => {
            if (payload.instanceData) {
                payload.instanceData.state.push({
                    type: 'Routing',
                    key: '$route',
                    editable: false,
                    value: formatRouteLocation(router.currentRoute.value, 'Current Route'),
                });
            }
        });
        // mark router-link as active
        api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {
            // if multiple useLink are used
            if (Array.isArray(componentInstance.__vrl_devtools)) {
                componentInstance.__devtoolsApi = api;
                componentInstance.__vrl_devtools.forEach(devtoolsData => {
                    let backgroundColor = ORANGE_400;
                    let tooltip = '';
                    if (devtoolsData.isExactActive) {
                        backgroundColor = LIME_500;
                        tooltip = 'This is exactly active';
                    }
                    else if (devtoolsData.isActive) {
                        backgroundColor = BLUE_600;
                        tooltip = 'This link is active';
                    }
                    node.tags.push({
                        label: devtoolsData.route.path,
                        textColor: 0,
                        tooltip,
                        backgroundColor,
                    });
                });
            }
        });
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(router.currentRoute, () => {
            // refresh active state
            refreshRoutesView();
            api.notifyComponentUpdate();
            api.sendInspectorTree(routerInspectorId);
            api.sendInspectorState(routerInspectorId);
        });
        const navigationsLayerId = 'router:navigations:' + id;
        api.addTimelineLayer({
            id: navigationsLayerId,
            label: `Router${id ? ' ' + id : ''} Navigations`,
            color: 0x40a8c4,
        });
        // const errorsLayerId = 'router:errors'
        // api.addTimelineLayer({
        //   id: errorsLayerId,
        //   label: 'Router Errors',
        //   color: 0xea5455,
        // })
        router.onError((error, to) => {
            api.addTimelineEvent({
                layerId: navigationsLayerId,
                event: {
                    title: 'Error during Navigation',
                    subtitle: to.fullPath,
                    logType: 'error',
                    time: Date.now(),
                    data: { error },
                    groupId: to.meta.__navigationId,
                },
            });
        });
        // attached to `meta` and used to group events
        let navigationId = 0;
        router.beforeEach((to, from) => {
            const data = {
                guard: formatDisplay('beforeEach'),
                from: formatRouteLocation(from, 'Current Location during this navigation'),
                to: formatRouteLocation(to, 'Target location'),
            };
            // Used to group navigations together, hide from devtools
            Object.defineProperty(to.meta, '__navigationId', {
                value: navigationId++,
            });
            api.addTimelineEvent({
                layerId: navigationsLayerId,
                event: {
                    time: Date.now(),
                    title: 'Start of navigation',
                    subtitle: to.fullPath,
                    data,
                    groupId: to.meta.__navigationId,
                },
            });
        });
        router.afterEach((to, from, failure) => {
            const data = {
                guard: formatDisplay('afterEach'),
            };
            if (failure) {
                data.failure = {
                    _custom: {
                        type: Error,
                        readOnly: true,
                        display: failure ? failure.message : '',
                        tooltip: 'Navigation Failure',
                        value: failure,
                    },
                };
                data.status = formatDisplay('❌');
            }
            else {
                data.status = formatDisplay('✅');
            }
            // we set here to have the right order
            data.from = formatRouteLocation(from, 'Current Location during this navigation');
            data.to = formatRouteLocation(to, 'Target location');
            api.addTimelineEvent({
                layerId: navigationsLayerId,
                event: {
                    title: 'End of navigation',
                    subtitle: to.fullPath,
                    time: Date.now(),
                    data,
                    logType: failure ? 'warning' : 'default',
                    groupId: to.meta.__navigationId,
                },
            });
        });
        /**
         * Inspector of Existing routes
         */
        const routerInspectorId = 'router-inspector:' + id;
        api.addInspector({
            id: routerInspectorId,
            label: 'Routes' + (id ? ' ' + id : ''),
            icon: 'book',
            treeFilterPlaceholder: 'Search routes',
        });
        function refreshRoutesView() {
            // the routes view isn't active
            if (!activeRoutesPayload)
                return;
            const payload = activeRoutesPayload;
            // children routes will appear as nested
            let routes = matcher.getRoutes().filter(route => !route.parent);
            // reset match state to false
            routes.forEach(resetMatchStateOnRouteRecord);
            // apply a match state if there is a payload
            if (payload.filter) {
                routes = routes.filter(route => 
                // save matches state based on the payload
                isRouteMatching(route, payload.filter.toLowerCase()));
            }
            // mark active routes
            routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));
            payload.rootNodes = routes.map(formatRouteRecordForInspector);
        }
        let activeRoutesPayload;
        api.on.getInspectorTree(payload => {
            activeRoutesPayload = payload;
            if (payload.app === app && payload.inspectorId === routerInspectorId) {
                refreshRoutesView();
            }
        });
        /**
         * Display information about the currently selected route record
         */
        api.on.getInspectorState(payload => {
            if (payload.app === app && payload.inspectorId === routerInspectorId) {
                const routes = matcher.getRoutes();
                const route = routes.find(route => route.record.__vd_id === payload.nodeId);
                if (route) {
                    payload.state = {
                        options: formatRouteRecordMatcherForStateInspector(route),
                    };
                }
            }
        });
        api.sendInspectorTree(routerInspectorId);
        api.sendInspectorState(routerInspectorId);
    });
}
function modifierForKey(key) {
    if (key.optional) {
        return key.repeatable ? '*' : '?';
    }
    else {
        return key.repeatable ? '+' : '';
    }
}
function formatRouteRecordMatcherForStateInspector(route) {
    const { record } = route;
    const fields = [
        { editable: false, key: 'path', value: record.path },
    ];
    if (record.name != null) {
        fields.push({
            editable: false,
            key: 'name',
            value: record.name,
        });
    }
    fields.push({ editable: false, key: 'regexp', value: route.re });
    if (route.keys.length) {
        fields.push({
            editable: false,
            key: 'keys',
            value: {
                _custom: {
                    type: null,
                    readOnly: true,
                    display: route.keys
                        .map(key => `${key.name}${modifierForKey(key)}`)
                        .join(' '),
                    tooltip: 'Param keys',
                    value: route.keys,
                },
            },
        });
    }
    if (record.redirect != null) {
        fields.push({
            editable: false,
            key: 'redirect',
            value: record.redirect,
        });
    }
    if (route.alias.length) {
        fields.push({
            editable: false,
            key: 'aliases',
            value: route.alias.map(alias => alias.record.path),
        });
    }
    fields.push({
        key: 'score',
        editable: false,
        value: {
            _custom: {
                type: null,
                readOnly: true,
                display: route.score.map(score => score.join(', ')).join(' | '),
                tooltip: 'Score used to sort routes',
                value: route.score,
            },
        },
    });
    return fields;
}
/**
 * Extracted from tailwind palette
 */
const PINK_500 = 0xec4899;
const BLUE_600 = 0x2563eb;
const LIME_500 = 0x84cc16;
const CYAN_400 = 0x22d3ee;
const ORANGE_400 = 0xfb923c;
// const GRAY_100 = 0xf4f4f5
const DARK = 0x666666;
function formatRouteRecordForInspector(route) {
    const tags = [];
    const { record } = route;
    if (record.name != null) {
        tags.push({
            label: String(record.name),
            textColor: 0,
            backgroundColor: CYAN_400,
        });
    }
    if (record.aliasOf) {
        tags.push({
            label: 'alias',
            textColor: 0,
            backgroundColor: ORANGE_400,
        });
    }
    if (route.__vd_match) {
        tags.push({
            label: 'matches',
            textColor: 0,
            backgroundColor: PINK_500,
        });
    }
    if (route.__vd_exactActive) {
        tags.push({
            label: 'exact',
            textColor: 0,
            backgroundColor: LIME_500,
        });
    }
    if (route.__vd_active) {
        tags.push({
            label: 'active',
            textColor: 0,
            backgroundColor: BLUE_600,
        });
    }
    if (record.redirect) {
        tags.push({
            label: 'redirect: ' +
                (typeof record.redirect === 'string' ? record.redirect : 'Object'),
            textColor: 0xffffff,
            backgroundColor: DARK,
        });
    }
    // add an id to be able to select it. Using the `path` is not possible because
    // empty path children would collide with their parents
    let id = record.__vd_id;
    if (id == null) {
        id = String(routeRecordId++);
        record.__vd_id = id;
    }
    return {
        id,
        label: record.path,
        tags,
        children: route.children.map(formatRouteRecordForInspector),
    };
}
//  incremental id for route records and inspector state
let routeRecordId = 0;
const EXTRACT_REGEXP_RE = /^\/(.*)\/([a-z]*)$/;
function markRouteRecordActive(route, currentRoute) {
    // no route will be active if matched is empty
    // reset the matching state
    const isExactActive = currentRoute.matched.length &&
        isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);
    route.__vd_exactActive = route.__vd_active = isExactActive;
    if (!isExactActive) {
        route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));
    }
    route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));
}
function resetMatchStateOnRouteRecord(route) {
    route.__vd_match = false;
    route.children.forEach(resetMatchStateOnRouteRecord);
}
function isRouteMatching(route, filter) {
    const found = String(route.re).match(EXTRACT_REGEXP_RE);
    route.__vd_match = false;
    if (!found || found.length < 3) {
        return false;
    }
    // use a regexp without $ at the end to match nested routes better
    const nonEndingRE = new RegExp(found[1].replace(/\$$/, ''), found[2]);
    if (nonEndingRE.test(filter)) {
        // mark children as matches
        route.children.forEach(child => isRouteMatching(child, filter));
        // exception case: `/`
        if (route.record.path !== '/' || filter === '/') {
            route.__vd_match = route.re.test(filter);
            return true;
        }
        // hide the / route
        return false;
    }
    const path = route.record.path.toLowerCase();
    const decodedPath = decode(path);
    // also allow partial matching on the path
    if (!filter.startsWith('/') &&
        (decodedPath.includes(filter) || path.includes(filter)))
        return true;
    if (decodedPath.startsWith(filter) || path.startsWith(filter))
        return true;
    if (route.record.name && String(route.record.name).includes(filter))
        return true;
    return route.children.some(child => isRouteMatching(child, filter));
}
function omit(obj, keys) {
    const ret = {};
    for (let key in obj) {
        if (!keys.includes(key)) {
            // @ts-expect-error
            ret[key] = obj[key];
        }
    }
    return ret;
}

/**
 * Creates a Router instance that can be used by a Vue app.
 *
 * @param options - {@link RouterOptions}
 */
function createRouter(options) {
    const matcher = createRouterMatcher(options.routes, options);
    let parseQuery$1 = options.parseQuery || parseQuery;
    let stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
    let routerHistory = options.history;
    if (( true) && !routerHistory)
        throw new Error('Provide the "history" option when calling "createRouter()":' +
            ' https://next.router.vuejs.org/api/#history.');
    const beforeGuards = useCallbacks();
    const beforeResolveGuards = useCallbacks();
    const afterGuards = useCallbacks();
    const currentRoute = (0,vue__WEBPACK_IMPORTED_MODULE_0__.shallowRef)(START_LOCATION_NORMALIZED);
    let pendingLocation = START_LOCATION_NORMALIZED;
    // leave the scrollRestoration if no scrollBehavior is provided
    if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
    }
    const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);
    const encodeParams = applyToParams.bind(null, encodeParam);
    const decodeParams = applyToParams.bind(null, decode);
    function addRoute(parentOrRoute, route) {
        let parent;
        let record;
        if (isRouteName(parentOrRoute)) {
            parent = matcher.getRecordMatcher(parentOrRoute);
            record = route;
        }
        else {
            record = parentOrRoute;
        }
        return matcher.addRoute(record, parent);
    }
    function removeRoute(name) {
        let recordMatcher = matcher.getRecordMatcher(name);
        if (recordMatcher) {
            matcher.removeRoute(recordMatcher);
        }
        else if ((true)) {
            warn(`Cannot remove non-existent route "${String(name)}"`);
        }
    }
    function getRoutes() {
        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);
    }
    function hasRoute(name) {
        return !!matcher.getRecordMatcher(name);
    }
    function resolve(rawLocation, currentLocation) {
        // const objectLocation = routerLocationAsObject(rawLocation)
        // we create a copy to modify it later
        currentLocation = assign({}, currentLocation || currentRoute.value);
        if (typeof rawLocation === 'string') {
            let locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
            let matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);
            let href = routerHistory.createHref(locationNormalized.fullPath);
            if ((true)) {
                if (href.startsWith('//'))
                    warn(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);
                else if (!matchedRoute.matched.length) {
                    warn(`No match found for location with path "${rawLocation}"`);
                }
            }
            // locationNormalized is always a new object
            return assign(locationNormalized, matchedRoute, {
                params: decodeParams(matchedRoute.params),
                hash: decode(locationNormalized.hash),
                redirectedFrom: undefined,
                href,
            });
        }
        let matcherLocation;
        // path could be relative in object as well
        if ('path' in rawLocation) {
            if (( true) &&
                'params' in rawLocation &&
                !('name' in rawLocation) &&
                Object.keys(rawLocation.params).length) {
                warn(`Path "${rawLocation.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`);
            }
            matcherLocation = assign({}, rawLocation, {
                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,
            });
        }
        else {
            // pass encoded values to the matcher so it can produce encoded path and fullPath
            matcherLocation = assign({}, rawLocation, {
                params: encodeParams(rawLocation.params),
            });
            // current location params are decoded, we need to encode them in case the
            // matcher merges the params
            currentLocation.params = encodeParams(currentLocation.params);
        }
        let matchedRoute = matcher.resolve(matcherLocation, currentLocation);
        const hash = rawLocation.hash || '';
        if (( true) && hash && !hash.startsWith('#')) {
            warn(`A \`hash\` should always start with the character "#". Replace "${hash}" with "#${hash}".`);
        }
        // decoding them) the matcher might have merged current location params so
        // we need to run the decoding again
        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
            hash: encodeHash(hash),
            path: matchedRoute.path,
        }));
        let href = routerHistory.createHref(fullPath);
        if ((true)) {
            if (href.startsWith('//')) {
                warn(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);
            }
            else if (!matchedRoute.matched.length) {
                warn(`No match found for location with path "${'path' in rawLocation ? rawLocation.path : rawLocation}"`);
            }
        }
        return assign({
            fullPath,
            // keep the hash encoded so fullPath is effectively path + encodedQuery +
            // hash
            hash,
            query: 
            // if the user is using a custom query lib like qs, we might have
            // nested objects, so we keep the query as is, meaning it can contain
            // numbers at `$route.query`, but at the point, the user will have to
            // use their own type anyway.
            // https://github.com/vuejs/vue-router-next/issues/328#issuecomment-649481567
            stringifyQuery$1 === stringifyQuery
                ? normalizeQuery(rawLocation.query)
                : rawLocation.query,
        }, matchedRoute, {
            redirectedFrom: undefined,
            href,
        });
    }
    function locationAsObject(to) {
        return typeof to === 'string'
            ? parseURL(parseQuery$1, to, currentRoute.value.path)
            : assign({}, to);
    }
    function checkCanceledNavigation(to, from) {
        if (pendingLocation !== to) {
            return createRouterError(8 /* NAVIGATION_CANCELLED */, {
                from,
                to,
            });
        }
    }
    function push(to) {
        return pushWithRedirect(to);
    }
    function replace(to) {
        return push(assign(locationAsObject(to), { replace: true }));
    }
    function handleRedirectRecord(to) {
        const lastMatched = to.matched[to.matched.length - 1];
        if (lastMatched && lastMatched.redirect) {
            const { redirect } = lastMatched;
            let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;
            if (typeof newTargetLocation === 'string') {
                newTargetLocation =
                    newTargetLocation.includes('?') || newTargetLocation.includes('#')
                        ? (newTargetLocation = locationAsObject(newTargetLocation))
                        : // force empty params
                            { path: newTargetLocation };
                // @ts-expect-error: force empty params when a string is passed to let
                // the router parse them again
                newTargetLocation.params = {};
            }
            if (( true) &&
                !('path' in newTargetLocation) &&
                !('name' in newTargetLocation)) {
                warn(`Invalid redirect found:\n${JSON.stringify(newTargetLocation, null, 2)}\n when navigating to "${to.fullPath}". A redirect must contain a name or path. This will break in production.`);
                throw new Error('Invalid redirect');
            }
            return assign({
                query: to.query,
                hash: to.hash,
                params: to.params,
            }, newTargetLocation);
        }
    }
    function pushWithRedirect(to, redirectedFrom) {
        const targetLocation = (pendingLocation = resolve(to));
        const from = currentRoute.value;
        const data = to.state;
        const force = to.force;
        // to could be a string where `replace` is a function
        const replace = to.replace === true;
        const shouldRedirect = handleRedirectRecord(targetLocation);
        if (shouldRedirect)
            return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
                state: data,
                force,
                replace,
            }), 
            // keep original redirectedFrom if it exists
            redirectedFrom || targetLocation);
        // if it was a redirect we already called `pushWithRedirect` above
        const toLocation = targetLocation;
        toLocation.redirectedFrom = redirectedFrom;
        let failure;
        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
            failure = createRouterError(16 /* NAVIGATION_DUPLICATED */, { to: toLocation, from });
            // trigger scroll to allow scrolling to the same anchor
            handleScroll(from, from, 
            // this is a push, the only way for it to be triggered from a
            // history.listen is with a redirect, which makes it become a push
            true, 
            // This cannot be the first navigation because the initial location
            // cannot be manually navigated to
            false);
        }
        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))
            .catch((error) => isNavigationFailure(error)
            ? error
            : // reject any unknown error
                triggerError(error, toLocation, from))
            .then((failure) => {
            if (failure) {
                if (isNavigationFailure(failure, 2 /* NAVIGATION_GUARD_REDIRECT */)) {
                    if (( true) &&
                        // we are redirecting to the same location we were already at
                        isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) &&
                        // and we have done it a couple of times
                        redirectedFrom &&
                        // @ts-expect-error: added only in dev
                        (redirectedFrom._count = redirectedFrom._count
                            ? // @ts-expect-error
                                redirectedFrom._count + 1
                            : 1) > 10) {
                        warn(`Detected an infinite redirection in a navigation guard when going from "${from.fullPath}" to "${toLocation.fullPath}". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);
                        return Promise.reject(new Error('Infinite redirect in navigation guard'));
                    }
                    return pushWithRedirect(
                    // keep options
                    assign(locationAsObject(failure.to), {
                        state: data,
                        force,
                        replace,
                    }), 
                    // preserve the original redirectedFrom if any
                    redirectedFrom || toLocation);
                }
            }
            else {
                // if we fail we don't finalize the navigation
                failure = finalizeNavigation(toLocation, from, true, replace, data);
            }
            triggerAfterEach(toLocation, from, failure);
            return failure;
        });
    }
    /**
     * Helper to reject and skip all navigation guards if a new navigation happened
     * @param to
     * @param from
     */
    function checkCanceledNavigationAndReject(to, from) {
        const error = checkCanceledNavigation(to, from);
        return error ? Promise.reject(error) : Promise.resolve();
    }
    // TODO: refactor the whole before guards by internally using router.beforeEach
    function navigate(to, from) {
        let guards;
        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
        // all components here have been resolved once because we are leaving
        guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);
        // leavingRecords is already reversed
        for (const record of leavingRecords) {
            record.leaveGuards.forEach(guard => {
                guards.push(guardToPromiseFn(guard, to, from));
            });
        }
        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
        guards.push(canceledNavigationCheck);
        // run the queue of per route beforeRouteLeave guards
        return (runGuardQueue(guards)
            .then(() => {
            // check global guards beforeEach
            guards = [];
            for (const guard of beforeGuards.list()) {
                guards.push(guardToPromiseFn(guard, to, from));
            }
            guards.push(canceledNavigationCheck);
            return runGuardQueue(guards);
        })
            .then(() => {
            // check in components beforeRouteUpdate
            guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);
            for (const record of updatingRecords) {
                record.updateGuards.forEach(guard => {
                    guards.push(guardToPromiseFn(guard, to, from));
                });
            }
            guards.push(canceledNavigationCheck);
            // run the queue of per route beforeEnter guards
            return runGuardQueue(guards);
        })
            .then(() => {
            // check the route beforeEnter
            guards = [];
            for (const record of to.matched) {
                // do not trigger beforeEnter on reused views
                if (record.beforeEnter && !from.matched.includes(record)) {
                    if (Array.isArray(record.beforeEnter)) {
                        for (const beforeEnter of record.beforeEnter)
                            guards.push(guardToPromiseFn(beforeEnter, to, from));
                    }
                    else {
                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));
                    }
                }
            }
            guards.push(canceledNavigationCheck);
            // run the queue of per route beforeEnter guards
            return runGuardQueue(guards);
        })
            .then(() => {
            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>
            // clear existing enterCallbacks, these are added by extractComponentsGuards
            to.matched.forEach(record => (record.enterCallbacks = {}));
            // check in-component beforeRouteEnter
            guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);
            guards.push(canceledNavigationCheck);
            // run the queue of per route beforeEnter guards
            return runGuardQueue(guards);
        })
            .then(() => {
            // check global guards beforeResolve
            guards = [];
            for (const guard of beforeResolveGuards.list()) {
                guards.push(guardToPromiseFn(guard, to, from));
            }
            guards.push(canceledNavigationCheck);
            return runGuardQueue(guards);
        })
            // catch any navigation canceled
            .catch(err => isNavigationFailure(err, 8 /* NAVIGATION_CANCELLED */)
            ? err
            : Promise.reject(err)));
    }
    function triggerAfterEach(to, from, failure) {
        // navigation is confirmed, call afterGuards
        // TODO: wrap with error handlers
        for (const guard of afterGuards.list())
            guard(to, from, failure);
    }
    /**
     * - Cleans up any navigation guards
     * - Changes the url if necessary
     * - Calls the scrollBehavior
     */
    function finalizeNavigation(toLocation, from, isPush, replace, data) {
        // a more recent navigation took place
        const error = checkCanceledNavigation(toLocation, from);
        if (error)
            return error;
        // only consider as push if it's not the first navigation
        const isFirstNavigation = from === START_LOCATION_NORMALIZED;
        const state = !isBrowser ? {} : history.state;
        // change URL only if the user did a push/replace and if it's not the initial navigation because
        // it's just reflecting the url
        if (isPush) {
            // on the initial navigation, we want to reuse the scroll position from
            // history state if it exists
            if (replace || isFirstNavigation)
                routerHistory.replace(toLocation.fullPath, assign({
                    scroll: isFirstNavigation && state && state.scroll,
                }, data));
            else
                routerHistory.push(toLocation.fullPath, data);
        }
        // accept current navigation
        currentRoute.value = toLocation;
        handleScroll(toLocation, from, isPush, isFirstNavigation);
        markAsReady();
    }
    let removeHistoryListener;
    // attach listener to history to trigger navigations
    function setupListeners() {
        removeHistoryListener = routerHistory.listen((to, _from, info) => {
            // cannot be a redirect route because it was in history
            let toLocation = resolve(to);
            // due to dynamic routing, and to hash history with manual navigation
            // (manually changing the url or calling history.hash = '#/somewhere'),
            // there could be a redirect record in history
            const shouldRedirect = handleRedirectRecord(toLocation);
            if (shouldRedirect) {
                pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
                return;
            }
            pendingLocation = toLocation;
            const from = currentRoute.value;
            // TODO: should be moved to web history?
            if (isBrowser) {
                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
            }
            navigate(toLocation, from)
                .catch((error) => {
                if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ | 8 /* NAVIGATION_CANCELLED */)) {
                    return error;
                }
                if (isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)) {
                    // Here we could call if (info.delta) routerHistory.go(-info.delta,
                    // false) but this is bug prone as we have no way to wait the
                    // navigation to be finished before calling pushWithRedirect. Using
                    // a setTimeout of 16ms seems to work but there is not guarantee for
                    // it to work on every browser. So Instead we do not restore the
                    // history entry and trigger a new navigation as requested by the
                    // navigation guard.
                    // the error is already handled by router.push we just want to avoid
                    // logging the error
                    pushWithRedirect(error.to, toLocation
                    // avoid an uncaught rejection, let push call triggerError
                    )
                        .then(failure => {
                        // manual change in hash history #916 ending up in the URL not
                        // changing but it was changed by the manual url change, so we
                        // need to manually change it ourselves
                        if (isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ |
                            16 /* NAVIGATION_DUPLICATED */) &&
                            !info.delta &&
                            info.type === NavigationType.pop) {
                            routerHistory.go(-1, false);
                        }
                    })
                        .catch(noop);
                    // avoid the then branch
                    return Promise.reject();
                }
                // do not restore history on unknown direction
                if (info.delta)
                    routerHistory.go(-info.delta, false);
                // unrecognized error, transfer to the global handler
                return triggerError(error, toLocation, from);
            })
                .then((failure) => {
                failure =
                    failure ||
                        finalizeNavigation(
                        // after navigation, all matched components are resolved
                        toLocation, from, false);
                // revert the navigation
                if (failure) {
                    if (info.delta) {
                        routerHistory.go(-info.delta, false);
                    }
                    else if (info.type === NavigationType.pop &&
                        isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ | 16 /* NAVIGATION_DUPLICATED */)) {
                        // manual change in hash history #916
                        // it's like a push but lacks the information of the direction
                        routerHistory.go(-1, false);
                    }
                }
                triggerAfterEach(toLocation, from, failure);
            })
                .catch(noop);
        });
    }
    // Initialization and Errors
    let readyHandlers = useCallbacks();
    let errorHandlers = useCallbacks();
    let ready;
    /**
     * Trigger errorHandlers added via onError and throws the error as well
     *
     * @param error - error to throw
     * @param to - location we were navigating to when the error happened
     * @param from - location we were navigating from when the error happened
     * @returns the error as a rejected promise
     */
    function triggerError(error, to, from) {
        markAsReady(error);
        const list = errorHandlers.list();
        if (list.length) {
            list.forEach(handler => handler(error, to, from));
        }
        else {
            if ((true)) {
                warn('uncaught error during route navigation:');
            }
            console.error(error);
        }
        return Promise.reject(error);
    }
    function isReady() {
        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
            return Promise.resolve();
        return new Promise((resolve, reject) => {
            readyHandlers.add([resolve, reject]);
        });
    }
    /**
     * Mark the router as ready, resolving the promised returned by isReady(). Can
     * only be called once, otherwise does nothing.
     * @param err - optional error
     */
    function markAsReady(err) {
        if (ready)
            return;
        ready = true;
        setupListeners();
        readyHandlers
            .list()
            .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));
        readyHandlers.reset();
    }
    // Scroll behavior
    function handleScroll(to, from, isPush, isFirstNavigation) {
        const { scrollBehavior } = options;
        if (!isBrowser || !scrollBehavior)
            return Promise.resolve();
        let scrollPosition = (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||
            ((isFirstNavigation || !isPush) &&
                history.state &&
                history.state.scroll) ||
            null;
        return (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)()
            .then(() => scrollBehavior(to, from, scrollPosition))
            .then(position => position && scrollToPosition(position))
            .catch(err => triggerError(err, to, from));
    }
    const go = (delta) => routerHistory.go(delta);
    let started;
    const installedApps = new Set();
    const router = {
        currentRoute,
        addRoute,
        removeRoute,
        hasRoute,
        getRoutes,
        resolve,
        options,
        push,
        replace,
        go,
        back: () => go(-1),
        forward: () => go(1),
        beforeEach: beforeGuards.add,
        beforeResolve: beforeResolveGuards.add,
        afterEach: afterGuards.add,
        onError: errorHandlers.add,
        isReady,
        install(app) {
            const router = this;
            app.component('RouterLink', RouterLink);
            app.component('RouterView', RouterView);
            app.config.globalProperties.$router = router;
            Object.defineProperty(app.config.globalProperties, '$route', {
                enumerable: true,
                get: () => (0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(currentRoute),
            });
            // this initial navigation is only necessary on client, on server it doesn't
            // make sense because it will create an extra unnecessary navigation and could
            // lead to problems
            if (isBrowser &&
                // used for the initial navigation client side to avoid pushing
                // multiple times when the router is used in multiple apps
                !started &&
                currentRoute.value === START_LOCATION_NORMALIZED) {
                // see above
                started = true;
                push(routerHistory.location).catch(err => {
                    if ((true))
                        warn('Unexpected error when starting the router:', err);
                });
            }
            const reactiveRoute = {};
            for (let key in START_LOCATION_NORMALIZED) {
                // @ts-expect-error: the key matches
                reactiveRoute[key] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => currentRoute.value[key]);
            }
            app.provide(routerKey, router);
            app.provide(routeLocationKey, (0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)(reactiveRoute));
            app.provide(routerViewLocationKey, currentRoute);
            let unmountApp = app.unmount;
            installedApps.add(app);
            app.unmount = function () {
                installedApps.delete(app);
                if (installedApps.size < 1) {
                    removeHistoryListener();
                    currentRoute.value = START_LOCATION_NORMALIZED;
                    started = false;
                    ready = false;
                }
                unmountApp();
            };
            if (( true) && isBrowser) {
                addDevtools(app, router, matcher);
            }
        },
    };
    return router;
}
function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
}
function extractChangingRecords(to, from) {
    const leavingRecords = [];
    const updatingRecords = [];
    const enteringRecords = [];
    const len = Math.max(from.matched.length, to.matched.length);
    for (let i = 0; i < len; i++) {
        const recordFrom = from.matched[i];
        if (recordFrom) {
            if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))
                updatingRecords.push(recordFrom);
            else
                leavingRecords.push(recordFrom);
        }
        const recordTo = to.matched[i];
        if (recordTo) {
            // the type doesn't matter because we are comparing per reference
            if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {
                enteringRecords.push(recordTo);
            }
        }
    }
    return [leavingRecords, updatingRecords, enteringRecords];
}

/**
 * Returns the router instance. Equivalent to using `$router` inside
 * templates.
 */
function useRouter() {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routerKey);
}
/**
 * Returns the current route location. Equivalent to using `$route` inside
 * templates.
 */
function useRoute() {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(routeLocationKey);
}




/***/ }),

/***/ "./node_modules/vue/dist/vue.runtime.esm-bundler.js":
/*!**********************************************************!*\
  !*** ./node_modules/vue/dist/vue.runtime.esm-bundler.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "Transition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   "TransitionGroup": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSSRApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineEmit": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmit),
/* harmony export */   "defineEmits": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "hydrate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "render": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useContext),
/* harmony export */   "useCssModule": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   "useCssVars": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "vModelCheckbox": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   "vModelSelect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   "vModelText": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   "vShow": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withKeys": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   "withModifiers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "compile": () => (/* binding */ compile)
/* harmony export */ });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js");



function initDev() {
    {
        (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.initCustomFormatter)();
    }
}

// This entry exports the runtime only, and is built as
if ((true)) {
    initDev();
}
const compile = () => {
    if ((true)) {
        (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`Runtime compilation is not supported in this build of Vue.` +
            (` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
                ) /* should not happen */);
    }
};




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*************************!*\
  !*** ./src/js/admin.js ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");
/* harmony import */ var _components_AdminApp_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/AdminApp.vue */ "./src/js/components/AdminApp.vue");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../router */ "./src/router/index.js");



(0,vue__WEBPACK_IMPORTED_MODULE_0__.createApp)(_components_AdminApp_vue__WEBPACK_IMPORTED_MODULE_1__.default).use(_router__WEBPACK_IMPORTED_MODULE_2__.default).mount("#".concat(yrl_wp_vue_plotly_charts_obj.prefix, "__admin")); // createApp(AdminApp).mount(`#${yrl_wp_vue_plotly_charts_obj.prefix}__admin`)
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92dWUtd3AtcGxvdGx5LWNoYXJ0cy8uL25vZGVfbW9kdWxlcy9AdnVlL2RldnRvb2xzLWFwaS9saWIvZXNtL2FwaS9pbmRleC5qcyIsIndlYnBhY2s6Ly92dWUtd3AtcGxvdGx5LWNoYXJ0cy8uL25vZGVfbW9kdWxlcy9AdnVlL2RldnRvb2xzLWFwaS9saWIvZXNtL2NvbnN0LmpzIiwid2VicGFjazovL3Z1ZS13cC1wbG90bHktY2hhcnRzLy4vbm9kZV9tb2R1bGVzL0B2dWUvZGV2dG9vbHMtYXBpL2xpYi9lc20vZW52LmpzIiwid2VicGFjazovL3Z1ZS13cC1wbG90bHktY2hhcnRzLy4vbm9kZV9tb2R1bGVzL0B2dWUvZGV2dG9vbHMtYXBpL2xpYi9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdnVlLXdwLXBsb3RseS1jaGFydHMvLi9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly92dWUtd3AtcGxvdGx5LWNoYXJ0cy8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly92dWUtd3AtcGxvdGx5LWNoYXJ0cy8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtZG9tL2Rpc3QvcnVudGltZS1kb20uZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vdnVlLXdwLXBsb3RseS1jaGFydHMvLi9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vdnVlLXdwLXBsb3RseS1jaGFydHMvLi9zcmMvanMvY29tcG9uZW50cy9BZG1pbkFwcC52dWUiLCJ3ZWJwYWNrOi8vdnVlLXdwLXBsb3RseS1jaGFydHMvLi9zcmMvdmlld3MvQ2hhcnRMaWJyYXJ5LnZ1ZSIsIndlYnBhY2s6Ly92dWUtd3AtcGxvdGx5LWNoYXJ0cy8uL3NyYy92aWV3cy9TZXR0aW5ncy52dWUiLCJ3ZWJwYWNrOi8vdnVlLXdwLXBsb3RseS1jaGFydHMvLi9zcmMvdmlld3MvU3VwcG9ydC52dWUiLCJ3ZWJwYWNrOi8vdnVlLXdwLXBsb3RseS1jaGFydHMvLi9zcmMvcm91dGVyL2luZGV4LmpzIiwid2VicGFjazovL3Z1ZS13cC1wbG90bHktY2hhcnRzLy4vc3JjL2pzL2NvbXBvbmVudHMvQWRtaW5BcHAudnVlPzNhYTMiLCJ3ZWJwYWNrOi8vdnVlLXdwLXBsb3RseS1jaGFydHMvLi9zcmMvdmlld3MvQ2hhcnRMaWJyYXJ5LnZ1ZT8wYWE5Iiwid2VicGFjazovL3Z1ZS13cC1wbG90bHktY2hhcnRzLy4vc3JjL3ZpZXdzL1NldHRpbmdzLnZ1ZT80MTE3Iiwid2VicGFjazovL3Z1ZS13cC1wbG90bHktY2hhcnRzLy4vc3JjL3ZpZXdzL1N1cHBvcnQudnVlPzQxOGEiLCJ3ZWJwYWNrOi8vdnVlLXdwLXBsb3RseS1jaGFydHMvLi9zcmMvanMvY29tcG9uZW50cy9BZG1pbkFwcC52dWU/NTAwMyIsIndlYnBhY2s6Ly92dWUtd3AtcGxvdGx5LWNoYXJ0cy8uL25vZGVfbW9kdWxlcy92dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly92dWUtd3AtcGxvdGx5LWNoYXJ0cy8uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUucnVudGltZS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly92dWUtd3AtcGxvdGx5LWNoYXJ0cy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly92dWUtd3AtcGxvdGx5LWNoYXJ0cy93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly92dWUtd3AtcGxvdGx5LWNoYXJ0cy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vdnVlLXdwLXBsb3RseS1jaGFydHMvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly92dWUtd3AtcGxvdGx5LWNoYXJ0cy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3Z1ZS13cC1wbG90bHktY2hhcnRzL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdnVlLXdwLXBsb3RseS1jaGFydHMvLi9zcmMvanMvYWRtaW4uanMiXSwibmFtZXMiOlsicm91dGVzIiwicGF0aCIsIm5hbWUiLCJjb21wb25lbnQiLCJDaGFydExpYnJhcnkiLCJyZWRpcmVjdCIsIlNldHRpbmdzIiwiU3VwcG9ydCIsInJvdXRlciIsImNyZWF0ZVJvdXRlciIsImhpc3RvcnkiLCJjcmVhdGVXZWJIaXN0b3J5IiwiY3JlYXRlQXBwIiwiQWRtaW5BcHAiLCJ1c2UiLCJtb3VudCIsInlybF93cF92dWVfcGxvdGx5X2NoYXJ0c19vYmoiLCJwcmVmaXgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0I7QUFDQTtBQUNNO0FBQ0Y7QUFDRjtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0xoQjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBTTtBQUN2QixjQUFjLHFCQUFNO0FBQ3BCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWeUQ7QUFDcEI7QUFDZjtBQUNmO0FBQ1AsaUJBQWlCLDJEQUFxQjtBQUN0QztBQUNBLGtCQUFrQiw4Q0FBVTtBQUM1QjtBQUNBO0FBQ0EsdUJBQXVCLCtDQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQjZLOztBQUU3SztBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXd1Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcG1QdjVCO0FBQy9TO0FBQzJNOztBQUU3TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZLHFEQUFxRCxZQUFZO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQztBQUNsRCw4REFBOEQsWUFBWTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsK0NBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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ZSI6ImFkbWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9hcGknO1xuZXhwb3J0ICogZnJvbSAnLi9hcHAnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9jb250ZXh0JztcbmV4cG9ydCAqIGZyb20gJy4vaG9va3MnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlsJztcbiIsImV4cG9ydCBjb25zdCBIT09LX1NFVFVQID0gJ2RldnRvb2xzLXBsdWdpbjpzZXR1cCc7XG4iLCJleHBvcnQgZnVuY3Rpb24gZ2V0RGV2dG9vbHNHbG9iYWxIb29rKCkge1xuICAgIHJldHVybiBnZXRUYXJnZXQoKS5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gd2luZG93XG4gICAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gZ2xvYmFsXG4gICAgICAgICAgICA6IHt9O1xufVxuIiwiaW1wb3J0IHsgZ2V0VGFyZ2V0LCBnZXREZXZ0b29sc0dsb2JhbEhvb2sgfSBmcm9tICcuL2Vudic7XG5pbXBvcnQgeyBIT09LX1NFVFVQIH0gZnJvbSAnLi9jb25zdCc7XG5leHBvcnQgKiBmcm9tICcuL2FwaSc7XG5leHBvcnQgZnVuY3Rpb24gc2V0dXBEZXZ0b29sc1BsdWdpbihwbHVnaW5EZXNjcmlwdG9yLCBzZXR1cEZuKSB7XG4gICAgY29uc3QgaG9vayA9IGdldERldnRvb2xzR2xvYmFsSG9vaygpO1xuICAgIGlmIChob29rKSB7XG4gICAgICAgIGhvb2suZW1pdChIT09LX1NFVFVQLCBwbHVnaW5EZXNjcmlwdG9yLCBzZXR1cEZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldCgpO1xuICAgICAgICBjb25zdCBsaXN0ID0gdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX1BMVUdJTlNfXyA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19QTFVHSU5TX18gfHwgW107XG4gICAgICAgIGxpc3QucHVzaCh7XG4gICAgICAgICAgICBwbHVnaW5EZXNjcmlwdG9yLFxuICAgICAgICAgICAgc2V0dXBGblxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBFTVBUWV9PQkosIGlzQXJyYXksIGlzTWFwLCBpc0ludGVnZXJLZXksIGlzU3ltYm9sLCBleHRlbmQsIGhhc093biwgaXNPYmplY3QsIGhhc0NoYW5nZWQsIG1ha2VNYXAsIGNhcGl0YWxpemUsIHRvUmF3VHlwZSwgZGVmLCBpc0Z1bmN0aW9uLCBOT09QIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCB0YXJnZXRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBlZmZlY3RTdGFjayA9IFtdO1xyXG5sZXQgYWN0aXZlRWZmZWN0O1xyXG5jb25zdCBJVEVSQVRFX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnaXRlcmF0ZScgOiAnJyk7XHJcbmNvbnN0IE1BUF9LRVlfSVRFUkFURV9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ01hcCBrZXkgaXRlcmF0ZScgOiAnJyk7XHJcbmZ1bmN0aW9uIGlzRWZmZWN0KGZuKSB7XHJcbiAgICByZXR1cm4gZm4gJiYgZm4uX2lzRWZmZWN0ID09PSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGVmZmVjdChmbiwgb3B0aW9ucyA9IEVNUFRZX09CSikge1xyXG4gICAgaWYgKGlzRWZmZWN0KGZuKSkge1xyXG4gICAgICAgIGZuID0gZm4ucmF3O1xyXG4gICAgfVxyXG4gICAgY29uc3QgZWZmZWN0ID0gY3JlYXRlUmVhY3RpdmVFZmZlY3QoZm4sIG9wdGlvbnMpO1xyXG4gICAgaWYgKCFvcHRpb25zLmxhenkpIHtcclxuICAgICAgICBlZmZlY3QoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlZmZlY3Q7XHJcbn1cclxuZnVuY3Rpb24gc3RvcChlZmZlY3QpIHtcclxuICAgIGlmIChlZmZlY3QuYWN0aXZlKSB7XHJcbiAgICAgICAgY2xlYW51cChlZmZlY3QpO1xyXG4gICAgICAgIGlmIChlZmZlY3Qub3B0aW9ucy5vblN0b3ApIHtcclxuICAgICAgICAgICAgZWZmZWN0Lm9wdGlvbnMub25TdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVmZmVjdC5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5sZXQgdWlkID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVFZmZlY3QoZm4sIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGVmZmVjdCA9IGZ1bmN0aW9uIHJlYWN0aXZlRWZmZWN0KCkge1xyXG4gICAgICAgIGlmICghZWZmZWN0LmFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFlZmZlY3RTdGFjay5pbmNsdWRlcyhlZmZlY3QpKSB7XHJcbiAgICAgICAgICAgIGNsZWFudXAoZWZmZWN0KTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZVRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3RTdGFjay5wdXNoKGVmZmVjdCk7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3QgPSBlZmZlY3Q7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIGVmZmVjdFN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0ID0gZWZmZWN0U3RhY2tbZWZmZWN0U3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZWZmZWN0LmlkID0gdWlkKys7XHJcbiAgICBlZmZlY3QuYWxsb3dSZWN1cnNlID0gISFvcHRpb25zLmFsbG93UmVjdXJzZTtcclxuICAgIGVmZmVjdC5faXNFZmZlY3QgPSB0cnVlO1xyXG4gICAgZWZmZWN0LmFjdGl2ZSA9IHRydWU7XHJcbiAgICBlZmZlY3QucmF3ID0gZm47XHJcbiAgICBlZmZlY3QuZGVwcyA9IFtdO1xyXG4gICAgZWZmZWN0Lm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgcmV0dXJuIGVmZmVjdDtcclxufVxyXG5mdW5jdGlvbiBjbGVhbnVwKGVmZmVjdCkge1xyXG4gICAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3Q7XHJcbiAgICBpZiAoZGVwcy5sZW5ndGgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVwc1tpXS5kZWxldGUoZWZmZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVwcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG59XHJcbmxldCBzaG91bGRUcmFjayA9IHRydWU7XHJcbmNvbnN0IHRyYWNrU3RhY2sgPSBbXTtcclxuZnVuY3Rpb24gcGF1c2VUcmFja2luZygpIHtcclxuICAgIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XHJcbiAgICBzaG91bGRUcmFjayA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGVuYWJsZVRyYWNraW5nKCkge1xyXG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcclxuICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiByZXNldFRyYWNraW5nKCkge1xyXG4gICAgY29uc3QgbGFzdCA9IHRyYWNrU3RhY2sucG9wKCk7XHJcbiAgICBzaG91bGRUcmFjayA9IGxhc3QgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBsYXN0O1xyXG59XHJcbmZ1bmN0aW9uIHRyYWNrKHRhcmdldCwgdHlwZSwga2V5KSB7XHJcbiAgICBpZiAoIXNob3VsZFRyYWNrIHx8IGFjdGl2ZUVmZmVjdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICBpZiAoIWRlcHNNYXApIHtcclxuICAgICAgICB0YXJnZXRNYXAuc2V0KHRhcmdldCwgKGRlcHNNYXAgPSBuZXcgTWFwKCkpKTtcclxuICAgIH1cclxuICAgIGxldCBkZXAgPSBkZXBzTWFwLmdldChrZXkpO1xyXG4gICAgaWYgKCFkZXApIHtcclxuICAgICAgICBkZXBzTWFwLnNldChrZXksIChkZXAgPSBuZXcgU2V0KCkpKTtcclxuICAgIH1cclxuICAgIGlmICghZGVwLmhhcyhhY3RpdmVFZmZlY3QpKSB7XHJcbiAgICAgICAgZGVwLmFkZChhY3RpdmVFZmZlY3QpO1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdC5kZXBzLnB1c2goZGVwKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGFjdGl2ZUVmZmVjdC5vcHRpb25zLm9uVHJhY2spIHtcclxuICAgICAgICAgICAgYWN0aXZlRWZmZWN0Lm9wdGlvbnMub25UcmFjayh7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3Q6IGFjdGl2ZUVmZmVjdCxcclxuICAgICAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICBrZXlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0KSB7XHJcbiAgICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgaWYgKCFkZXBzTWFwKSB7XHJcbiAgICAgICAgLy8gbmV2ZXIgYmVlbiB0cmFja2VkXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZWZmZWN0cyA9IG5ldyBTZXQoKTtcclxuICAgIGNvbnN0IGFkZCA9IChlZmZlY3RzVG9BZGQpID0+IHtcclxuICAgICAgICBpZiAoZWZmZWN0c1RvQWRkKSB7XHJcbiAgICAgICAgICAgIGVmZmVjdHNUb0FkZC5mb3JFYWNoKGVmZmVjdCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0ICE9PSBhY3RpdmVFZmZlY3QgfHwgZWZmZWN0LmFsbG93UmVjdXJzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHMuYWRkKGVmZmVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAodHlwZSA9PT0gXCJjbGVhclwiIC8qIENMRUFSICovKSB7XHJcbiAgICAgICAgLy8gY29sbGVjdGlvbiBiZWluZyBjbGVhcmVkXHJcbiAgICAgICAgLy8gdHJpZ2dlciBhbGwgZWZmZWN0cyBmb3IgdGFyZ2V0XHJcbiAgICAgICAgZGVwc01hcC5mb3JFYWNoKGFkZCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChrZXkgPT09ICdsZW5ndGgnICYmIGlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgIGRlcHNNYXAuZm9yRWFjaCgoZGVwLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2xlbmd0aCcgfHwga2V5ID49IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBhZGQoZGVwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc2NoZWR1bGUgcnVucyBmb3IgU0VUIHwgQUREIHwgREVMRVRFXHJcbiAgICAgICAgaWYgKGtleSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWxzbyBydW4gZm9yIGl0ZXJhdGlvbiBrZXkgb24gQUREIHwgREVMRVRFIHwgTWFwLlNFVFxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiYWRkXCIgLyogQUREICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSW50ZWdlcktleShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV3IGluZGV4IGFkZGVkIHRvIGFycmF5IC0+IGxlbmd0aCBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KCdsZW5ndGgnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVwiIC8qIERFTEVURSAqLzpcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInNldFwiIC8qIFNFVCAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBydW4gPSAoZWZmZWN0KSA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBlZmZlY3Qub3B0aW9ucy5vblRyaWdnZXIpIHtcclxuICAgICAgICAgICAgZWZmZWN0Lm9wdGlvbnMub25UcmlnZ2VyKHtcclxuICAgICAgICAgICAgICAgIGVmZmVjdCxcclxuICAgICAgICAgICAgICAgIHRhcmdldCxcclxuICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgb2xkVGFyZ2V0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWZmZWN0Lm9wdGlvbnMuc2NoZWR1bGVyKSB7XHJcbiAgICAgICAgICAgIGVmZmVjdC5vcHRpb25zLnNjaGVkdWxlcihlZmZlY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWZmZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGVmZmVjdHMuZm9yRWFjaChydW4pO1xyXG59XG5cbmNvbnN0IGlzTm9uVHJhY2thYmxlS2V5cyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgX19wcm90b19fLF9fdl9pc1JlZixfX2lzVnVlYCk7XHJcbmNvbnN0IGJ1aWx0SW5TeW1ib2xzID0gbmV3IFNldChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpXHJcbiAgICAubWFwKGtleSA9PiBTeW1ib2xba2V5XSlcclxuICAgIC5maWx0ZXIoaXNTeW1ib2wpKTtcclxuY29uc3QgZ2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIoKTtcclxuY29uc3Qgc2hhbGxvd0dldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKGZhbHNlLCB0cnVlKTtcclxuY29uc3QgcmVhZG9ubHlHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcih0cnVlKTtcclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIodHJ1ZSwgdHJ1ZSk7XHJcbmNvbnN0IGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IC8qI19fUFVSRV9fKi8gY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zKCk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5SW5zdHJ1bWVudGF0aW9ucygpIHtcclxuICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSB7fTtcclxuICAgIFsnaW5jbHVkZXMnLCAnaW5kZXhPZicsICdsYXN0SW5kZXhPZiddLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBpbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgICAgICBjb25zdCBhcnIgPSB0b1Jhdyh0aGlzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdHJhY2soYXJyLCBcImdldFwiIC8qIEdFVCAqLywgaSArICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB3ZSBydW4gdGhlIG1ldGhvZCB1c2luZyB0aGUgb3JpZ2luYWwgYXJncyBmaXJzdCAod2hpY2ggbWF5IGJlIHJlYWN0aXZlKVxyXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhcnJba2V5XSguLi5hcmdzKTtcclxuICAgICAgICAgICAgaWYgKHJlcyA9PT0gLTEgfHwgcmVzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhhdCBkaWRuJ3Qgd29yaywgcnVuIGl0IGFnYWluIHVzaW5nIHJhdyB2YWx1ZXMuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyW2tleV0oLi4uYXJncy5tYXAodG9SYXcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3Vuc2hpZnQnLCAnc3BsaWNlJ10uZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzID0gdG9SYXcodGhpcylba2V5XS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBpbnN0cnVtZW50YXRpb25zO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUdldHRlcihpc1JlYWRvbmx5ID0gZmFsc2UsIHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcclxuICAgICAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNSZWFkb25seTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIiAvKiBSQVcgKi8gJiZcclxuICAgICAgICAgICAgcmVjZWl2ZXIgPT09XHJcbiAgICAgICAgICAgICAgICAoaXNSZWFkb25seVxyXG4gICAgICAgICAgICAgICAgICAgID8gc2hhbGxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNoYWxsb3dSZWFkb25seU1hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlYWRvbmx5TWFwXHJcbiAgICAgICAgICAgICAgICAgICAgOiBzaGFsbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2hhbGxvd1JlYWN0aXZlTWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRhcmdldElzQXJyYXkgPSBpc0FycmF5KHRhcmdldCk7XHJcbiAgICAgICAgaWYgKCFpc1JlYWRvbmx5ICYmIHRhcmdldElzQXJyYXkgJiYgaGFzT3duKGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXksIHJlY2VpdmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcclxuICAgICAgICBpZiAoaXNTeW1ib2woa2V5KSA/IGJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpIDogaXNOb25UcmFja2FibGVLZXlzKGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1JlYWRvbmx5KSB7XHJcbiAgICAgICAgICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiAvKiBHRVQgKi8sIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFsbG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1JlZihyZXMpKSB7XHJcbiAgICAgICAgICAgIC8vIHJlZiB1bndyYXBwaW5nIC0gZG9lcyBub3QgYXBwbHkgZm9yIEFycmF5ICsgaW50ZWdlciBrZXkuXHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFVud3JhcCA9ICF0YXJnZXRJc0FycmF5IHx8ICFpc0ludGVnZXJLZXkoa2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNob3VsZFVud3JhcCA/IHJlcy52YWx1ZSA6IHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcclxuICAgICAgICAgICAgLy8gQ29udmVydCByZXR1cm5lZCB2YWx1ZSBpbnRvIGEgcHJveHkgYXMgd2VsbC4gd2UgZG8gdGhlIGlzT2JqZWN0IGNoZWNrXHJcbiAgICAgICAgICAgIC8vIGhlcmUgdG8gYXZvaWQgaW52YWxpZCB2YWx1ZSB3YXJuaW5nLiBBbHNvIG5lZWQgdG8gbGF6eSBhY2Nlc3MgcmVhZG9ubHlcclxuICAgICAgICAgICAgLy8gYW5kIHJlYWN0aXZlIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeS5cclxuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHkgPyByZWFkb25seShyZXMpIDogcmVhY3RpdmUocmVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbn1cclxuY29uc3Qgc2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVTZXR0ZXIoKTtcclxuY29uc3Qgc2hhbGxvd1NldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU2V0dGVyKHRydWUpO1xyXG5mdW5jdGlvbiBjcmVhdGVTZXR0ZXIoc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcclxuICAgICAgICBsZXQgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICBpZiAoIXNoYWxsb3cpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIG9sZFZhbHVlID0gdG9SYXcob2xkVmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhhZEtleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KVxyXG4gICAgICAgICAgICA/IE51bWJlcihrZXkpIDwgdGFyZ2V0Lmxlbmd0aFxyXG4gICAgICAgICAgICA6IGhhc093bih0YXJnZXQsIGtleSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XHJcbiAgICAgICAgLy8gZG9uJ3QgdHJpZ2dlciBpZiB0YXJnZXQgaXMgc29tZXRoaW5nIHVwIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gb2Ygb3JpZ2luYWxcclxuICAgICAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcclxuICAgICAgICAgICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiAvKiBTRVQgKi8sIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xyXG4gICAgY29uc3QgaGFkS2V5ID0gaGFzT3duKHRhcmdldCwga2V5KTtcclxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcclxuICAgIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIgLyogREVMRVRFICovLCBrZXksIHVuZGVmaW5lZCwgb2xkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBoYXModGFyZ2V0LCBrZXkpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaXNTeW1ib2woa2V5KSB8fCAhYnVpbHRJblN5bWJvbHMuaGFzKGtleSkpIHtcclxuICAgICAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIgLyogSEFTICovLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xyXG4gICAgdHJhY2sodGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBpc0FycmF5KHRhcmdldCkgPyAnbGVuZ3RoJyA6IElURVJBVEVfS0VZKTtcclxuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcclxufVxyXG5jb25zdCBtdXRhYmxlSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQsXHJcbiAgICBzZXQsXHJcbiAgICBkZWxldGVQcm9wZXJ0eSxcclxuICAgIGhhcyxcclxuICAgIG93bktleXNcclxufTtcclxuY29uc3QgcmVhZG9ubHlIYW5kbGVycyA9IHtcclxuICAgIGdldDogcmVhZG9ubHlHZXQsXHJcbiAgICBzZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2V0IG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufTtcclxuY29uc3Qgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgbXV0YWJsZUhhbmRsZXJzLCB7XHJcbiAgICBnZXQ6IHNoYWxsb3dHZXQsXHJcbiAgICBzZXQ6IHNoYWxsb3dTZXRcclxufSk7XHJcbi8vIFByb3BzIGhhbmRsZXJzIGFyZSBzcGVjaWFsIGluIHRoZSBzZW5zZSB0aGF0IGl0IHNob3VsZCBub3QgdW53cmFwIHRvcC1sZXZlbFxyXG4vLyByZWZzIChpbiBvcmRlciB0byBhbGxvdyByZWZzIHRvIGJlIGV4cGxpY2l0bHkgcGFzc2VkIGRvd24pLCBidXQgc2hvdWxkXHJcbi8vIHJldGFpbiB0aGUgcmVhY3Rpdml0eSBvZiB0aGUgbm9ybWFsIHJlYWRvbmx5IG9iamVjdC5cclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgcmVhZG9ubHlIYW5kbGVycywge1xyXG4gICAgZ2V0OiBzaGFsbG93UmVhZG9ubHlHZXRcclxufSk7XG5cbmNvbnN0IHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlKHZhbHVlKSA6IHZhbHVlO1xyXG5jb25zdCB0b1JlYWRvbmx5ID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFkb25seSh2YWx1ZSkgOiB2YWx1ZTtcclxuY29uc3QgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcclxuY29uc3QgZ2V0UHJvdG8gPSAodikgPT4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih2KTtcclxuZnVuY3Rpb24gZ2V0JDEodGFyZ2V0LCBrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSwgaXNTaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIC8vICMxNzcyOiByZWFkb25seShyZWFjdGl2ZShNYXApKSBzaG91bGQgcmV0dXJuIHJlYWRvbmx5ICsgcmVhY3RpdmUgdmVyc2lvblxyXG4gICAgLy8gb2YgdGhlIHZhbHVlXHJcbiAgICB0YXJnZXQgPSB0YXJnZXRbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XHJcbiAgICAgICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiIC8qIEdFVCAqLywga2V5KTtcclxuICAgIH1cclxuICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiAvKiBHRVQgKi8sIHJhd0tleSk7XHJcbiAgICBjb25zdCB7IGhhcyB9ID0gZ2V0UHJvdG8ocmF3VGFyZ2V0KTtcclxuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XHJcbiAgICBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCBrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwgcmF3S2V5KSkge1xyXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQocmF3S2V5KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xyXG4gICAgICAgIC8vICMzNjAyIHJlYWRvbmx5KHJlYWN0aXZlKE1hcCkpXHJcbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIG5lc3RlZCByZWFjdGl2ZSBgTWFwYCBjYW4gZG8gdHJhY2tpbmcgZm9yIGl0c2VsZlxyXG4gICAgICAgIHRhcmdldC5nZXQoa2V5KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYXMkMShrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcclxuICAgICAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIgLyogSEFTICovLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiIC8qIEhBUyAqLywgcmF3S2V5KTtcclxuICAgIHJldHVybiBrZXkgPT09IHJhd0tleVxyXG4gICAgICAgID8gdGFyZ2V0LmhhcyhrZXkpXHJcbiAgICAgICAgOiB0YXJnZXQuaGFzKGtleSkgfHwgdGFyZ2V0LmhhcyhyYXdLZXkpO1xyXG59XHJcbmZ1bmN0aW9uIHNpemUodGFyZ2V0LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcclxuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2sodG9SYXcodGFyZ2V0KSwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgSVRFUkFURV9LRVkpO1xyXG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgJ3NpemUnLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xyXG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgIGNvbnN0IGhhZEtleSA9IHByb3RvLmhhcy5jYWxsKHRhcmdldCwgdmFsdWUpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICB0YXJnZXQuYWRkKHZhbHVlKTtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiAvKiBBREQgKi8sIHZhbHVlLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5mdW5jdGlvbiBzZXQkMShrZXksIHZhbHVlKSB7XHJcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIGtleSA9IHRvUmF3KGtleSk7XHJcbiAgICAgICAgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldC5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywga2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiAvKiBTRVQgKi8sIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcbmZ1bmN0aW9uIGRlbGV0ZUVudHJ5KGtleSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCB7IGhhcywgZ2V0IH0gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcclxuICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0ID8gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpIDogdW5kZWZpbmVkO1xyXG4gICAgLy8gZm9yd2FyZCB0aGUgb3BlcmF0aW9uIGJlZm9yZSBxdWV1ZWluZyByZWFjdGlvbnNcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcclxuICAgIGlmIChoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiAvKiBERUxFVEUgKi8sIGtleSwgdW5kZWZpbmVkLCBvbGRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFyKCkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCBoYWRJdGVtcyA9IHRhcmdldC5zaXplICE9PSAwO1xyXG4gICAgY29uc3Qgb2xkVGFyZ2V0ID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgPyBpc01hcCh0YXJnZXQpXHJcbiAgICAgICAgICAgID8gbmV3IE1hcCh0YXJnZXQpXHJcbiAgICAgICAgICAgIDogbmV3IFNldCh0YXJnZXQpXHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAvLyBmb3J3YXJkIHRoZSBvcGVyYXRpb24gYmVmb3JlIHF1ZXVlaW5nIHJlYWN0aW9uc1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmNsZWFyKCk7XHJcbiAgICBpZiAoaGFkSXRlbXMpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJjbGVhclwiIC8qIENMRUFSICovLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb2xkVGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZWQgPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgICAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgSVRFUkFURV9LRVkpO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQ6IG1ha2Ugc3VyZSB0aGUgY2FsbGJhY2sgaXNcclxuICAgICAgICAgICAgLy8gMS4gaW52b2tlZCB3aXRoIHRoZSByZWFjdGl2ZSBtYXAgYXMgYHRoaXNgIGFuZCAzcmQgYXJnXHJcbiAgICAgICAgICAgIC8vIDIuIHRoZSB2YWx1ZSByZWNlaXZlZCBzaG91bGQgYmUgYSBjb3JyZXNwb25kaW5nIHJlYWN0aXZlL3JlYWRvbmx5LlxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgICAgICBjb25zdCB0YXJnZXRJc01hcCA9IGlzTWFwKHJhd1RhcmdldCk7XHJcbiAgICAgICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSAnZW50cmllcycgfHwgKG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwKTtcclxuICAgICAgICBjb25zdCBpc0tleU9ubHkgPSBtZXRob2QgPT09ICdrZXlzJyAmJiB0YXJnZXRJc01hcDtcclxuICAgICAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGFyZ2V0W21ldGhvZF0oLi4uYXJncyk7XHJcbiAgICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcclxuICAgICAgICAhaXNSZWFkb25seSAmJlxyXG4gICAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIGlzS2V5T25seSA/IE1BUF9LRVlfSVRFUkFURV9LRVkgOiBJVEVSQVRFX0tFWSk7XHJcbiAgICAgICAgLy8gcmV0dXJuIGEgd3JhcHBlZCBpdGVyYXRvciB3aGljaCByZXR1cm5zIG9ic2VydmVkIHZlcnNpb25zIG9mIHRoZVxyXG4gICAgICAgIC8vIHZhbHVlcyBlbWl0dGVkIGZyb20gdGhlIHJlYWwgaXRlcmF0b3JcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvLyBpdGVyYXRvciBwcm90b2NvbFxyXG4gICAgICAgICAgICBuZXh0KCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgID8geyB2YWx1ZSwgZG9uZSB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpc1BhaXIgPyBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSA6IHdyYXAodmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gaXRlcmFibGUgcHJvdG9jb2xcclxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5TWV0aG9kKHR5cGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7Y2FwaXRhbGl6ZSh0eXBlKX0gb3BlcmF0aW9uICR7a2V5fWZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRvUmF3KHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgLyogREVMRVRFICovID8gZmFsc2UgOiB0aGlzO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCkge1xyXG4gICAgY29uc3QgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgICAgICAgZ2V0KGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhczogaGFzJDEsXHJcbiAgICAgICAgYWRkLFxyXG4gICAgICAgIHNldDogc2V0JDEsXHJcbiAgICAgICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcclxuICAgICAgICBjbGVhcixcclxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCBmYWxzZSlcclxuICAgIH07XHJcbiAgICBjb25zdCBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhczogaGFzJDEsXHJcbiAgICAgICAgYWRkLFxyXG4gICAgICAgIHNldDogc2V0JDEsXHJcbiAgICAgICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcclxuICAgICAgICBjbGVhcixcclxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCB0cnVlKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzJDEuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiIC8qIEFERCAqLyksXHJcbiAgICAgICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiIC8qIFNFVCAqLyksXHJcbiAgICAgICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiIC8qIERFTEVURSAqLyksXHJcbiAgICAgICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiAvKiBDTEVBUiAqLyksXHJcbiAgICAgICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCBmYWxzZSlcclxuICAgIH07XHJcbiAgICBjb25zdCBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgICAgIGdldChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYXMkMS5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIgLyogQUREICovKSxcclxuICAgICAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIgLyogU0VUICovKSxcclxuICAgICAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIgLyogREVMRVRFICovKSxcclxuICAgICAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiIC8qIENMRUFSICovKSxcclxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIHRydWUpXHJcbiAgICB9O1xyXG4gICAgY29uc3QgaXRlcmF0b3JNZXRob2RzID0gWydrZXlzJywgJ3ZhbHVlcycsICdlbnRyaWVzJywgU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGl0ZXJhdG9yTWV0aG9kcy5mb3JFYWNoKG1ldGhvZCA9PiB7XHJcbiAgICAgICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICByZWFkb25seUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIHRydWUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zLFxyXG4gICAgICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyxcclxuICAgICAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyxcclxuICAgICAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXHJcbiAgICBdO1xyXG59XHJcbmNvbnN0IFttdXRhYmxlSW5zdHJ1bWVudGF0aW9ucywgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zLCBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucywgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc10gPSAvKiAjX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihpc1JlYWRvbmx5LCBzaGFsbG93KSB7XHJcbiAgICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0gc2hhbGxvd1xyXG4gICAgICAgID8gaXNSZWFkb25seVxyXG4gICAgICAgICAgICA/IHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgOiBzaGFsbG93SW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgIDogaXNSZWFkb25seVxyXG4gICAgICAgICAgICA/IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgICAgICA6IG11dGFibGVJbnN0cnVtZW50YXRpb25zO1xyXG4gICAgcmV0dXJuICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNSZWFkb25seTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIiAvKiBSQVcgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGhhc093bihpbnN0cnVtZW50YXRpb25zLCBrZXkpICYmIGtleSBpbiB0YXJnZXRcclxuICAgICAgICAgICAgPyBpbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgICAgIDogdGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcclxuICAgIH07XHJcbn1cclxuY29uc3QgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgdHJ1ZSlcclxufTtcclxuY29uc3QgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIHRydWUpXHJcbn07XHJcbmZ1bmN0aW9uIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpIHtcclxuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICBpZiAocmF3S2V5ICE9PSBrZXkgJiYgaGFzLmNhbGwodGFyZ2V0LCByYXdLZXkpKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHRvUmF3VHlwZSh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIGAgK1xyXG4gICAgICAgICAgICBgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIGAgK1xyXG4gICAgICAgICAgICBgd2hpY2ggY2FuIGxlYWQgdG8gaW5jb25zaXN0ZW5jaWVzLiBgICtcclxuICAgICAgICAgICAgYEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIGAgK1xyXG4gICAgICAgICAgICBgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gKTtcclxuICAgIH1cclxufVxuXG5jb25zdCByZWFjdGl2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHJlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuZnVuY3Rpb24gdGFyZ2V0VHlwZU1hcChyYXdUeXBlKSB7XHJcbiAgICBzd2l0Y2ggKHJhd1R5cGUpIHtcclxuICAgICAgICBjYXNlICdPYmplY3QnOlxyXG4gICAgICAgIGNhc2UgJ0FycmF5JzpcclxuICAgICAgICAgICAgcmV0dXJuIDEgLyogQ09NTU9OICovO1xyXG4gICAgICAgIGNhc2UgJ01hcCc6XHJcbiAgICAgICAgY2FzZSAnU2V0JzpcclxuICAgICAgICBjYXNlICdXZWFrTWFwJzpcclxuICAgICAgICBjYXNlICdXZWFrU2V0JzpcclxuICAgICAgICAgICAgcmV0dXJuIDIgLyogQ09MTEVDVElPTiAqLztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBJTlZBTElEICovO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFRhcmdldFR5cGUodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZVtcIl9fdl9za2lwXCIgLyogU0tJUCAqL10gfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpXHJcbiAgICAgICAgPyAwIC8qIElOVkFMSUQgKi9cclxuICAgICAgICA6IHRhcmdldFR5cGVNYXAodG9SYXdUeXBlKHZhbHVlKSk7XHJcbn1cclxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XHJcbiAgICAvLyBpZiB0cnlpbmcgdG8gb2JzZXJ2ZSBhIHJlYWRvbmx5IHByb3h5LCByZXR1cm4gdGhlIHJlYWRvbmx5IHZlcnNpb24uXHJcbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldFtcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi9dKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGZhbHNlLCBtdXRhYmxlSGFuZGxlcnMsIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWN0aXZlTWFwKTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIGEgc2hhbGxvd2x5LXJlYWN0aXZlIGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdFxyXG4gKiBsZXZlbCBwcm9wZXJ0aWVzIGFyZSByZWFjdGl2ZS4gSXQgYWxzbyBkb2VzIG5vdCBhdXRvLXVud3JhcCByZWZzIChldmVuIGF0IHRoZVxyXG4gKiByb290IGxldmVsKS5cclxuICovXHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGZhbHNlLCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycywgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycywgc2hhbGxvd1JlYWN0aXZlTWFwKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHJlYWRvbmx5IGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdC4gTm90ZSB0aGUgcmV0dXJuZWQgY29weSBpcyBub3RcclxuICogbWFkZSByZWFjdGl2ZSwgYnV0IGByZWFkb25seWAgY2FuIGJlIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHJlYWN0aXZlIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgcmVhZG9ubHlIYW5kbGVycywgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWRvbmx5TWFwKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHJlYWN0aXZlLWNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdCBsZXZlbFxyXG4gKiBwcm9wZXJ0aWVzIGFyZSByZWFkb25seSwgYW5kIGRvZXMgTk9UIHVud3JhcCByZWZzIG5vciByZWN1cnNpdmVseSBjb252ZXJ0XHJcbiAqIHJldHVybmVkIHByb3BlcnRpZXMuXHJcbiAqIFRoaXMgaXMgdXNlZCBmb3IgY3JlYXRpbmcgdGhlIHByb3BzIHByb3h5IG9iamVjdCBmb3Igc3RhdGVmdWwgY29tcG9uZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWFkb25seSh0YXJnZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIHRydWUsIHNoYWxsb3dSZWFkb25seUhhbmRsZXJzLCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHNoYWxsb3dSZWFkb25seU1hcCk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBpc1JlYWRvbmx5LCBiYXNlSGFuZGxlcnMsIGNvbGxlY3Rpb25IYW5kbGVycywgcHJveHlNYXApIHtcclxuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSByZWFjdGl2ZTogJHtTdHJpbmcodGFyZ2V0KX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIHRhcmdldCBpcyBhbHJlYWR5IGEgUHJveHksIHJldHVybiBpdC5cclxuICAgIC8vIGV4Y2VwdGlvbjogY2FsbGluZyByZWFkb25seSgpIG9uIGEgcmVhY3RpdmUgb2JqZWN0XHJcbiAgICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL10gJiZcclxuICAgICAgICAhKGlzUmVhZG9ubHkgJiYgdGFyZ2V0W1wiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqL10pKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIHRhcmdldCBhbHJlYWR5IGhhcyBjb3JyZXNwb25kaW5nIFByb3h5XHJcbiAgICBjb25zdCBleGlzdGluZ1Byb3h5ID0gcHJveHlNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICBpZiAoZXhpc3RpbmdQcm94eSkge1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xyXG4gICAgfVxyXG4gICAgLy8gb25seSBhIHdoaXRlbGlzdCBvZiB2YWx1ZSB0eXBlcyBjYW4gYmUgb2JzZXJ2ZWQuXHJcbiAgICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xyXG4gICAgaWYgKHRhcmdldFR5cGUgPT09IDAgLyogSU5WQUxJRCAqLykge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0YXJnZXQsIHRhcmdldFR5cGUgPT09IDIgLyogQ09MTEVDVElPTiAqLyA/IGNvbGxlY3Rpb25IYW5kbGVycyA6IGJhc2VIYW5kbGVycyk7XHJcbiAgICBwcm94eU1hcC5zZXQodGFyZ2V0LCBwcm94eSk7XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbn1cclxuZnVuY3Rpb24gaXNSZWFjdGl2ZSh2YWx1ZSkge1xyXG4gICAgaWYgKGlzUmVhZG9ubHkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWVbXCJfX3ZfcmF3XCIgLyogUkFXICovXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIElTX1JFQUNUSVZFICovXSk7XHJcbn1cclxuZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqL10pO1xyXG59XHJcbmZ1bmN0aW9uIGlzUHJveHkodmFsdWUpIHtcclxuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlKSB8fCBpc1JlYWRvbmx5KHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiB0b1JhdyhvYnNlcnZlZCkge1xyXG4gICAgcmV0dXJuICgob2JzZXJ2ZWQgJiYgdG9SYXcob2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUkFXICovXSkpIHx8IG9ic2VydmVkKTtcclxufVxyXG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XHJcbiAgICBkZWYodmFsdWUsIFwiX192X3NraXBcIiAvKiBTS0lQICovLCB0cnVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxuXG5jb25zdCBjb252ZXJ0ID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSA/IHJlYWN0aXZlKHZhbCkgOiB2YWw7XHJcbmZ1bmN0aW9uIGlzUmVmKHIpIHtcclxuICAgIHJldHVybiBCb29sZWFuKHIgJiYgci5fX3ZfaXNSZWYgPT09IHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gc2hhbGxvd1JlZih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XHJcbn1cclxuY2xhc3MgUmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgX3NoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMuX3NoYWxsb3cgPSBfc2hhbGxvdztcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcmF3VmFsdWUgPSBfc2hhbGxvdyA/IHZhbHVlIDogdG9SYXcodmFsdWUpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3NoYWxsb3cgPyB2YWx1ZSA6IGNvbnZlcnQodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHRyYWNrKHRvUmF3KHRoaXMpLCBcImdldFwiIC8qIEdFVCAqLywgJ3ZhbHVlJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgIG5ld1ZhbCA9IHRoaXMuX3NoYWxsb3cgPyBuZXdWYWwgOiB0b1JhdyhuZXdWYWwpO1xyXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKG5ld1ZhbCwgdGhpcy5fcmF3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gbmV3VmFsO1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX3NoYWxsb3cgPyBuZXdWYWwgOiBjb252ZXJ0KG5ld1ZhbCk7XHJcbiAgICAgICAgICAgIHRyaWdnZXIodG9SYXcodGhpcyksIFwic2V0XCIgLyogU0VUICovLCAndmFsdWUnLCBuZXdWYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgaWYgKGlzUmVmKHJhd1ZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiByYXdWYWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlclJlZihyZWYpIHtcclxuICAgIHRyaWdnZXIodG9SYXcocmVmKSwgXCJzZXRcIiAvKiBTRVQgKi8sICd2YWx1ZScsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHJlZi52YWx1ZSA6IHZvaWQgMCk7XHJcbn1cclxuZnVuY3Rpb24gdW5yZWYocmVmKSB7XHJcbiAgICByZXR1cm4gaXNSZWYocmVmKSA/IHJlZi52YWx1ZSA6IHJlZjtcclxufVxyXG5jb25zdCBzaGFsbG93VW53cmFwSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6ICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHVucmVmKFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikpLFxyXG4gICAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgaWYgKGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gcHJveHlSZWZzKG9iamVjdFdpdGhSZWZzKSB7XHJcbiAgICByZXR1cm4gaXNSZWFjdGl2ZShvYmplY3RXaXRoUmVmcylcclxuICAgICAgICA/IG9iamVjdFdpdGhSZWZzXHJcbiAgICAgICAgOiBuZXcgUHJveHkob2JqZWN0V2l0aFJlZnMsIHNoYWxsb3dVbndyYXBIYW5kbGVycyk7XHJcbn1cclxuY2xhc3MgQ3VzdG9tUmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5KSB7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoKCkgPT4gdHJhY2sodGhpcywgXCJnZXRcIiAvKiBHRVQgKi8sICd2YWx1ZScpLCAoKSA9PiB0cmlnZ2VyKHRoaXMsIFwic2V0XCIgLyogU0VUICovLCAndmFsdWUnKSk7XHJcbiAgICAgICAgdGhpcy5fZ2V0ID0gZ2V0O1xyXG4gICAgICAgIHRoaXMuX3NldCA9IHNldDtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KCk7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0KG5ld1ZhbCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3VzdG9tUmVmKGZhY3RvcnkpIHtcclxuICAgIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcclxufVxyXG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1Byb3h5KG9iamVjdCkpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYHRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmV0ID0gaXNBcnJheShvYmplY3QpID8gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpIDoge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcclxuICAgICAgICByZXRba2V5XSA9IHRvUmVmKG9iamVjdCwga2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuY2xhc3MgT2JqZWN0UmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihfb2JqZWN0LCBfa2V5KSB7XHJcbiAgICAgICAgdGhpcy5fb2JqZWN0ID0gX29iamVjdDtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb2JqZWN0W3RoaXMuX2tleV07XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgdGhpcy5fb2JqZWN0W3RoaXMuX2tleV0gPSBuZXdWYWw7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9SZWYob2JqZWN0LCBrZXkpIHtcclxuICAgIHJldHVybiBpc1JlZihvYmplY3Rba2V5XSlcclxuICAgICAgICA/IG9iamVjdFtrZXldXHJcbiAgICAgICAgOiBuZXcgT2JqZWN0UmVmSW1wbChvYmplY3QsIGtleSk7XHJcbn1cblxuY2xhc3MgQ29tcHV0ZWRSZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKGdldHRlciwgX3NldHRlciwgaXNSZWFkb25seSkge1xyXG4gICAgICAgIHRoaXMuX3NldHRlciA9IF9zZXR0ZXI7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmVmZmVjdCA9IGVmZmVjdChnZXR0ZXIsIHtcclxuICAgICAgICAgICAgbGF6eTogdHJ1ZSxcclxuICAgICAgICAgICAgc2NoZWR1bGVyOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXIodG9SYXcodGhpcyksIFwic2V0XCIgLyogU0VUICovLCAndmFsdWUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovXSA9IGlzUmVhZG9ubHk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgLy8gdGhlIGNvbXB1dGVkIHJlZiBtYXkgZ2V0IHdyYXBwZWQgYnkgb3RoZXIgcHJveGllcyBlLmcuIHJlYWRvbmx5KCkgIzMzNzZcclxuICAgICAgICBjb25zdCBzZWxmID0gdG9SYXcodGhpcyk7XHJcbiAgICAgICAgaWYgKHNlbGYuX2RpcnR5KSB7XHJcbiAgICAgICAgICAgIHNlbGYuX3ZhbHVlID0gdGhpcy5lZmZlY3QoKTtcclxuICAgICAgICAgICAgc2VsZi5fZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhY2soc2VsZiwgXCJnZXRcIiAvKiBHRVQgKi8sICd2YWx1ZScpO1xyXG4gICAgICAgIHJldHVybiBzZWxmLl92YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3NldHRlcihuZXdWYWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zKSB7XHJcbiAgICBsZXQgZ2V0dGVyO1xyXG4gICAgbGV0IHNldHRlcjtcclxuICAgIGlmIChpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucykpIHtcclxuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnM7XHJcbiAgICAgICAgc2V0dGVyID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgID8gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDogTk9PUDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucy5nZXQ7XHJcbiAgICAgICAgc2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLnNldDtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucykgfHwgIWdldHRlck9yT3B0aW9ucy5zZXQpO1xyXG59XG5cbmV4cG9ydCB7IElURVJBVEVfS0VZLCBjb21wdXRlZCwgY3VzdG9tUmVmLCBlZmZlY3QsIGVuYWJsZVRyYWNraW5nLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgbWFya1JhdywgcGF1c2VUcmFja2luZywgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgcmVzZXRUcmFja2luZywgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0cmFjaywgdHJpZ2dlciwgdHJpZ2dlclJlZiwgdW5yZWYgfTtcbiIsImltcG9ydCB7IHBhdXNlVHJhY2tpbmcsIHJlc2V0VHJhY2tpbmcsIGlzUmVmLCB0b1JhdywgaXNSZWFjdGl2ZSwgZWZmZWN0LCBzdG9wLCByZWYsIHJlYWN0aXZlLCBzaGFsbG93UmVhY3RpdmUsIHRyaWdnZXIsIGlzUHJveHksIHNoYWxsb3dSZWFkb25seSwgdHJhY2ssIG1hcmtSYXcsIHByb3h5UmVmcywgY29tcHV0ZWQgYXMgY29tcHV0ZWQkMSwgaXNSZWFkb25seSB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5leHBvcnQgeyBjdXN0b21SZWYsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBtYXJrUmF3LCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgdG9SYXcsIHRvUmVmLCB0b1JlZnMsIHRyaWdnZXJSZWYsIHVucmVmIH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0Z1bmN0aW9uIGFzIGlzRnVuY3Rpb24kMSwgaXNQcm9taXNlIGFzIGlzUHJvbWlzZSQxLCBpc0FycmF5LCBleHRlbmQsIGhhc093biwgRU1QVFlfT0JKLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCBoeXBoZW5hdGUsIGNhbWVsaXplLCBpc09uLCBpc01vZGVsTGlzdGVuZXIsIHJlbW92ZSwgTk9PUCwgaGFzQ2hhbmdlZCwgaXNPYmplY3QgYXMgaXNPYmplY3QkMSwgaXNTZXQsIGlzTWFwLCBpc1BsYWluT2JqZWN0LCBpbnZva2VBcnJheUZucywgZGVmLCBpc1Jlc2VydmVkUHJvcCwgRU1QVFlfQVJSLCBjYXBpdGFsaXplLCB0b1Jhd1R5cGUsIG1ha2VNYXAsIE5PLCBnZXRHbG9iYWxUaGlzLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplU3R5bGUsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGNhbWVsaXplLCBjYXBpdGFsaXplLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3RhY2sgPSBbXTtcclxuZnVuY3Rpb24gcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKSB7XHJcbiAgICBzdGFjay5wdXNoKHZub2RlKTtcclxufVxyXG5mdW5jdGlvbiBwb3BXYXJuaW5nQ29udGV4dCgpIHtcclxuICAgIHN0YWNrLnBvcCgpO1xyXG59XHJcbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XHJcbiAgICAvLyBhdm9pZCBwcm9wcyBmb3JtYXR0aW5nIG9yIHdhcm4gaGFuZGxlciB0cmFja2luZyBkZXBzIHRoYXQgbWlnaHQgYmUgbXV0YXRlZFxyXG4gICAgLy8gZHVyaW5nIHBhdGNoLCBsZWFkaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uY29tcG9uZW50IDogbnVsbDtcclxuICAgIGNvbnN0IGFwcFdhcm5IYW5kbGVyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcud2FybkhhbmRsZXI7XHJcbiAgICBjb25zdCB0cmFjZSA9IGdldENvbXBvbmVudFRyYWNlKCk7XHJcbiAgICBpZiAoYXBwV2FybkhhbmRsZXIpIHtcclxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoYXBwV2FybkhhbmRsZXIsIGluc3RhbmNlLCAxMSAvKiBBUFBfV0FSTl9IQU5ETEVSICovLCBbXHJcbiAgICAgICAgICAgIG1zZyArIGFyZ3Muam9pbignJyksXHJcbiAgICAgICAgICAgIGluc3RhbmNlICYmIGluc3RhbmNlLnByb3h5LFxyXG4gICAgICAgICAgICB0cmFjZVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoeyB2bm9kZSB9KSA9PiBgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgdm5vZGUudHlwZSl9PmApXHJcbiAgICAgICAgICAgICAgICAuam9pbignXFxuJyksXHJcbiAgICAgICAgICAgIHRyYWNlXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCB3YXJuQXJncyA9IFtgW1Z1ZSB3YXJuXTogJHttc2d9YCwgLi4uYXJnc107XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHRyYWNlLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAvLyBhdm9pZCBzcGFtbWluZyBjb25zb2xlIGR1cmluZyB0ZXN0c1xyXG4gICAgICAgICAgICAhZmFsc2UpIHtcclxuICAgICAgICAgICAgd2FybkFyZ3MucHVzaChgXFxuYCwgLi4uZm9ybWF0VHJhY2UodHJhY2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS53YXJuKC4uLndhcm5BcmdzKTtcclxuICAgIH1cclxuICAgIHJlc2V0VHJhY2tpbmcoKTtcclxufVxyXG5mdW5jdGlvbiBnZXRDb21wb25lbnRUcmFjZSgpIHtcclxuICAgIGxldCBjdXJyZW50Vk5vZGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgIGlmICghY3VycmVudFZOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgLy8gd2UgY2FuJ3QganVzdCB1c2UgdGhlIHN0YWNrIGJlY2F1c2UgaXQgd2lsbCBiZSBpbmNvbXBsZXRlIGR1cmluZyB1cGRhdGVzXHJcbiAgICAvLyB0aGF0IGRpZCBub3Qgc3RhcnQgZnJvbSB0aGUgcm9vdC4gUmUtY29uc3RydWN0IHRoZSBwYXJlbnQgY2hhaW4gdXNpbmdcclxuICAgIC8vIGluc3RhbmNlIHBhcmVudCBwb2ludGVycy5cclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRTdGFjayA9IFtdO1xyXG4gICAgd2hpbGUgKGN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGxhc3QgPSBub3JtYWxpemVkU3RhY2tbMF07XHJcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC52bm9kZSA9PT0gY3VycmVudFZOb2RlKSB7XHJcbiAgICAgICAgICAgIGxhc3QucmVjdXJzZUNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub3JtYWxpemVkU3RhY2sucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB2bm9kZTogY3VycmVudFZOb2RlLFxyXG4gICAgICAgICAgICAgICAgcmVjdXJzZUNvdW50OiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IGN1cnJlbnRWTm9kZS5jb21wb25lbnQgJiYgY3VycmVudFZOb2RlLmNvbXBvbmVudC5wYXJlbnQ7XHJcbiAgICAgICAgY3VycmVudFZOb2RlID0gcGFyZW50SW5zdGFuY2UgJiYgcGFyZW50SW5zdGFuY2Uudm5vZGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZFN0YWNrO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdFRyYWNlKHRyYWNlKSB7XHJcbiAgICBjb25zdCBsb2dzID0gW107XHJcbiAgICB0cmFjZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xyXG4gICAgICAgIGxvZ3MucHVzaCguLi4oaSA9PT0gMCA/IFtdIDogW2BcXG5gXSksIC4uLmZvcm1hdFRyYWNlRW50cnkoZW50cnkpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGxvZ3M7XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0VHJhY2VFbnRyeSh7IHZub2RlLCByZWN1cnNlQ291bnQgfSkge1xyXG4gICAgY29uc3QgcG9zdGZpeCA9IHJlY3Vyc2VDb3VudCA+IDAgPyBgLi4uICgke3JlY3Vyc2VDb3VudH0gcmVjdXJzaXZlIGNhbGxzKWAgOiBgYDtcclxuICAgIGNvbnN0IGlzUm9vdCA9IHZub2RlLmNvbXBvbmVudCA/IHZub2RlLmNvbXBvbmVudC5wYXJlbnQgPT0gbnVsbCA6IGZhbHNlO1xyXG4gICAgY29uc3Qgb3BlbiA9IGAgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bm9kZS5jb21wb25lbnQsIHZub2RlLnR5cGUsIGlzUm9vdCl9YDtcclxuICAgIGNvbnN0IGNsb3NlID0gYD5gICsgcG9zdGZpeDtcclxuICAgIHJldHVybiB2bm9kZS5wcm9wc1xyXG4gICAgICAgID8gW29wZW4sIC4uLmZvcm1hdFByb3BzKHZub2RlLnByb3BzKSwgY2xvc2VdXHJcbiAgICAgICAgOiBbb3BlbiArIGNsb3NlXTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRQcm9wcyhwcm9wcykge1xyXG4gICAgY29uc3QgcmVzID0gW107XHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xyXG4gICAga2V5cy5zbGljZSgwLCAzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgcmVzLnB1c2goLi4uZm9ybWF0UHJvcChrZXksIHByb3BzW2tleV0pKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGtleXMubGVuZ3RoID4gMykge1xyXG4gICAgICAgIHJlcy5wdXNoKGAgLi4uYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdFByb3Aoa2V5LCB2YWx1ZSwgcmF3KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcclxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fFxyXG4gICAgICAgIHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUgPSBmb3JtYXRQcm9wKGtleSwgdG9SYXcodmFsdWUudmFsdWUpLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1SZWY8YCwgdmFsdWUsIGA+YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uJDEodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIFtgJHtrZXl9PWZuJHt2YWx1ZS5uYW1lID8gYDwke3ZhbHVlLm5hbWV9PmAgOiBgYH1gXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PWAsIHZhbHVlXTtcclxuICAgIH1cclxufVxuXG5jb25zdCBFcnJvclR5cGVTdHJpbmdzID0ge1xyXG4gICAgW1wic3BcIiAvKiBTRVJWRVJfUFJFRkVUQ0ggKi9dOiAnc2VydmVyUHJlZmV0Y2ggaG9vaycsXHJcbiAgICBbXCJiY1wiIC8qIEJFRk9SRV9DUkVBVEUgKi9dOiAnYmVmb3JlQ3JlYXRlIGhvb2snLFxyXG4gICAgW1wiY1wiIC8qIENSRUFURUQgKi9dOiAnY3JlYXRlZCBob29rJyxcclxuICAgIFtcImJtXCIgLyogQkVGT1JFX01PVU5UICovXTogJ2JlZm9yZU1vdW50IGhvb2snLFxyXG4gICAgW1wibVwiIC8qIE1PVU5URUQgKi9dOiAnbW91bnRlZCBob29rJyxcclxuICAgIFtcImJ1XCIgLyogQkVGT1JFX1VQREFURSAqL106ICdiZWZvcmVVcGRhdGUgaG9vaycsXHJcbiAgICBbXCJ1XCIgLyogVVBEQVRFRCAqL106ICd1cGRhdGVkJyxcclxuICAgIFtcImJ1bVwiIC8qIEJFRk9SRV9VTk1PVU5UICovXTogJ2JlZm9yZVVubW91bnQgaG9vaycsXHJcbiAgICBbXCJ1bVwiIC8qIFVOTU9VTlRFRCAqL106ICd1bm1vdW50ZWQgaG9vaycsXHJcbiAgICBbXCJhXCIgLyogQUNUSVZBVEVEICovXTogJ2FjdGl2YXRlZCBob29rJyxcclxuICAgIFtcImRhXCIgLyogREVBQ1RJVkFURUQgKi9dOiAnZGVhY3RpdmF0ZWQgaG9vaycsXHJcbiAgICBbXCJlY1wiIC8qIEVSUk9SX0NBUFRVUkVEICovXTogJ2Vycm9yQ2FwdHVyZWQgaG9vaycsXHJcbiAgICBbXCJydGNcIiAvKiBSRU5ERVJfVFJBQ0tFRCAqL106ICdyZW5kZXJUcmFja2VkIGhvb2snLFxyXG4gICAgW1wicnRnXCIgLyogUkVOREVSX1RSSUdHRVJFRCAqL106ICdyZW5kZXJUcmlnZ2VyZWQgaG9vaycsXHJcbiAgICBbMCAvKiBTRVRVUF9GVU5DVElPTiAqL106ICdzZXR1cCBmdW5jdGlvbicsXHJcbiAgICBbMSAvKiBSRU5ERVJfRlVOQ1RJT04gKi9dOiAncmVuZGVyIGZ1bmN0aW9uJyxcclxuICAgIFsyIC8qIFdBVENIX0dFVFRFUiAqL106ICd3YXRjaGVyIGdldHRlcicsXHJcbiAgICBbMyAvKiBXQVRDSF9DQUxMQkFDSyAqL106ICd3YXRjaGVyIGNhbGxiYWNrJyxcclxuICAgIFs0IC8qIFdBVENIX0NMRUFOVVAgKi9dOiAnd2F0Y2hlciBjbGVhbnVwIGZ1bmN0aW9uJyxcclxuICAgIFs1IC8qIE5BVElWRV9FVkVOVF9IQU5ETEVSICovXTogJ25hdGl2ZSBldmVudCBoYW5kbGVyJyxcclxuICAgIFs2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovXTogJ2NvbXBvbmVudCBldmVudCBoYW5kbGVyJyxcclxuICAgIFs3IC8qIFZOT0RFX0hPT0sgKi9dOiAndm5vZGUgaG9vaycsXHJcbiAgICBbOCAvKiBESVJFQ1RJVkVfSE9PSyAqL106ICdkaXJlY3RpdmUgaG9vaycsXHJcbiAgICBbOSAvKiBUUkFOU0lUSU9OX0hPT0sgKi9dOiAndHJhbnNpdGlvbiBob29rJyxcclxuICAgIFsxMCAvKiBBUFBfRVJST1JfSEFORExFUiAqL106ICdhcHAgZXJyb3JIYW5kbGVyJyxcclxuICAgIFsxMSAvKiBBUFBfV0FSTl9IQU5ETEVSICovXTogJ2FwcCB3YXJuSGFuZGxlcicsXHJcbiAgICBbMTIgLyogRlVOQ1RJT05fUkVGICovXTogJ3JlZiBmdW5jdGlvbicsXHJcbiAgICBbMTMgLyogQVNZTkNfQ09NUE9ORU5UX0xPQURFUiAqL106ICdhc3luYyBjb21wb25lbnQgbG9hZGVyJyxcclxuICAgIFsxNCAvKiBTQ0hFRFVMRVIgKi9dOiAnc2NoZWR1bGVyIGZsdXNoLiBUaGlzIGlzIGxpa2VseSBhIFZ1ZSBpbnRlcm5hbHMgYnVnLiAnICtcclxuICAgICAgICAnUGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQgaHR0cHM6Ly9uZXctaXNzdWUudnVlanMub3JnLz9yZXBvPXZ1ZWpzL3Z1ZS1uZXh0J1xyXG59O1xyXG5mdW5jdGlvbiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XHJcbiAgICBsZXQgcmVzO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXMgPSBhcmdzID8gZm4oLi4uYXJncykgOiBmbigpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uJDEoZm4pKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XHJcbiAgICAgICAgaWYgKHJlcyAmJiBpc1Byb21pc2UkMShyZXMpKSB7XHJcbiAgICAgICAgICAgIHJlcy5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsdWVzLnB1c2goY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm5baV0sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWVzO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XHJcbiAgICBjb25zdCBjb250ZXh0Vk5vZGUgPSBpbnN0YW5jZSA/IGluc3RhbmNlLnZub2RlIDogbnVsbDtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIGxldCBjdXIgPSBpbnN0YW5jZS5wYXJlbnQ7XHJcbiAgICAgICAgLy8gdGhlIGV4cG9zZWQgaW5zdGFuY2UgaXMgdGhlIHJlbmRlciBwcm94eSB0byBrZWVwIGl0IGNvbnNpc3RlbnQgd2l0aCAyLnhcclxuICAgICAgICBjb25zdCBleHBvc2VkSW5zdGFuY2UgPSBpbnN0YW5jZS5wcm94eTtcclxuICAgICAgICAvLyBpbiBwcm9kdWN0aW9uIHRoZSBob29rIHJlY2VpdmVzIG9ubHkgdGhlIGVycm9yIGNvZGVcclxuICAgICAgICBjb25zdCBlcnJvckluZm8gPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBFcnJvclR5cGVTdHJpbmdzW3R5cGVdIDogdHlwZTtcclxuICAgICAgICB3aGlsZSAoY3VyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ2FwdHVyZWRIb29rcyA9IGN1ci5lYztcclxuICAgICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvckNhcHR1cmVkSG9va3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzW2ldKGVyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm8pID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFwcC1sZXZlbCBoYW5kbGluZ1xyXG4gICAgICAgIGNvbnN0IGFwcEVycm9ySGFuZGxlciA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmVycm9ySGFuZGxlcjtcclxuICAgICAgICBpZiAoYXBwRXJyb3JIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhhcHBFcnJvckhhbmRsZXIsIG51bGwsIDEwIC8qIEFQUF9FUlJPUl9IQU5ETEVSICovLCBbZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mb10pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYpO1xyXG59XHJcbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSBFcnJvclR5cGVTdHJpbmdzW3R5cGVdO1xyXG4gICAgICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcclxuICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGNvbnRleHRWTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdhcm4oYFVuaGFuZGxlZCBlcnJvciR7aW5mbyA/IGAgZHVyaW5nIGV4ZWN1dGlvbiBvZiAke2luZm99YCA6IGBgfWApO1xyXG4gICAgICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcclxuICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY3Jhc2ggaW4gZGV2IGJ5IGRlZmF1bHQgc28gaXQncyBtb3JlIG5vdGljZWFibGVcclxuICAgICAgICBpZiAodGhyb3dJbkRldikge1xyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gcmVjb3ZlciBpbiBwcm9kIHRvIHJlZHVjZSB0aGUgaW1wYWN0IG9uIGVuZC11c2VyXHJcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgfVxyXG59XG5cbmxldCBpc0ZsdXNoaW5nID0gZmFsc2U7XHJcbmxldCBpc0ZsdXNoUGVuZGluZyA9IGZhbHNlO1xyXG5jb25zdCBxdWV1ZSA9IFtdO1xyXG5sZXQgZmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHBlbmRpbmdQcmVGbHVzaENicyA9IFtdO1xyXG5sZXQgYWN0aXZlUHJlRmx1c2hDYnMgPSBudWxsO1xyXG5sZXQgcHJlRmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHBlbmRpbmdQb3N0Rmx1c2hDYnMgPSBbXTtcclxubGV0IGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XHJcbmxldCBwb3N0Rmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5sZXQgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XHJcbmxldCBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBudWxsO1xyXG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSAxMDA7XHJcbmZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XHJcbiAgICBjb25zdCBwID0gY3VycmVudEZsdXNoUHJvbWlzZSB8fCByZXNvbHZlZFByb21pc2U7XHJcbiAgICByZXR1cm4gZm4gPyBwLnRoZW4odGhpcyA/IGZuLmJpbmQodGhpcykgOiBmbikgOiBwO1xyXG59XHJcbi8vICMyNzY4XHJcbi8vIFVzZSBiaW5hcnktc2VhcmNoIHRvIGZpbmQgYSBzdWl0YWJsZSBwb3NpdGlvbiBpbiB0aGUgcXVldWUsXHJcbi8vIHNvIHRoYXQgdGhlIHF1ZXVlIG1haW50YWlucyB0aGUgaW5jcmVhc2luZyBvcmRlciBvZiBqb2IncyBpZCxcclxuLy8gd2hpY2ggY2FuIHByZXZlbnQgdGhlIGpvYiBmcm9tIGJlaW5nIHNraXBwZWQgYW5kIGFsc28gY2FuIGF2b2lkIHJlcGVhdGVkIHBhdGNoaW5nLlxyXG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uSW5kZXgoam9iKSB7XHJcbiAgICAvLyB0aGUgc3RhcnQgaW5kZXggc2hvdWxkIGJlIGBmbHVzaEluZGV4ICsgMWBcclxuICAgIGxldCBzdGFydCA9IGZsdXNoSW5kZXggKyAxO1xyXG4gICAgbGV0IGVuZCA9IHF1ZXVlLmxlbmd0aDtcclxuICAgIGNvbnN0IGpvYklkID0gZ2V0SWQoam9iKTtcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIGNvbnN0IG1pZGRsZSA9IChzdGFydCArIGVuZCkgPj4+IDE7XHJcbiAgICAgICAgY29uc3QgbWlkZGxlSm9iSWQgPSBnZXRJZChxdWV1ZVttaWRkbGVdKTtcclxuICAgICAgICBtaWRkbGVKb2JJZCA8IGpvYklkID8gKHN0YXJ0ID0gbWlkZGxlICsgMSkgOiAoZW5kID0gbWlkZGxlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdGFydDtcclxufVxyXG5mdW5jdGlvbiBxdWV1ZUpvYihqb2IpIHtcclxuICAgIC8vIHRoZSBkZWR1cGUgc2VhcmNoIHVzZXMgdGhlIHN0YXJ0SW5kZXggYXJndW1lbnQgb2YgQXJyYXkuaW5jbHVkZXMoKVxyXG4gICAgLy8gYnkgZGVmYXVsdCB0aGUgc2VhcmNoIGluZGV4IGluY2x1ZGVzIHRoZSBjdXJyZW50IGpvYiB0aGF0IGlzIGJlaW5nIHJ1blxyXG4gICAgLy8gc28gaXQgY2Fubm90IHJlY3Vyc2l2ZWx5IHRyaWdnZXIgaXRzZWxmIGFnYWluLlxyXG4gICAgLy8gaWYgdGhlIGpvYiBpcyBhIHdhdGNoKCkgY2FsbGJhY2ssIHRoZSBzZWFyY2ggd2lsbCBzdGFydCB3aXRoIGEgKzEgaW5kZXggdG9cclxuICAgIC8vIGFsbG93IGl0IHJlY3Vyc2l2ZWx5IHRyaWdnZXIgaXRzZWxmIC0gaXQgaXMgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0b1xyXG4gICAgLy8gZW5zdXJlIGl0IGRvZXNuJ3QgZW5kIHVwIGluIGFuIGluZmluaXRlIGxvb3AuXHJcbiAgICBpZiAoKCFxdWV1ZS5sZW5ndGggfHxcclxuICAgICAgICAhcXVldWUuaW5jbHVkZXMoam9iLCBpc0ZsdXNoaW5nICYmIGpvYi5hbGxvd1JlY3Vyc2UgPyBmbHVzaEluZGV4ICsgMSA6IGZsdXNoSW5kZXgpKSAmJlxyXG4gICAgICAgIGpvYiAhPT0gY3VycmVudFByZUZsdXNoUGFyZW50Sm9iKSB7XHJcbiAgICAgICAgY29uc3QgcG9zID0gZmluZEluc2VydGlvbkluZGV4KGpvYik7XHJcbiAgICAgICAgaWYgKHBvcyA+IC0xKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlLnNwbGljZShwb3MsIDAsIGpvYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGpvYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlRmx1c2goKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBxdWV1ZUZsdXNoKCkge1xyXG4gICAgaWYgKCFpc0ZsdXNoaW5nICYmICFpc0ZsdXNoUGVuZGluZykge1xyXG4gICAgICAgIGlzRmx1c2hQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gcmVzb2x2ZWRQcm9taXNlLnRoZW4oZmx1c2hKb2JzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbnZhbGlkYXRlSm9iKGpvYikge1xyXG4gICAgY29uc3QgaSA9IHF1ZXVlLmluZGV4T2Yoam9iKTtcclxuICAgIGlmIChpID4gZmx1c2hJbmRleCkge1xyXG4gICAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBxdWV1ZUNiKGNiLCBhY3RpdmVRdWV1ZSwgcGVuZGluZ1F1ZXVlLCBpbmRleCkge1xyXG4gICAgaWYgKCFpc0FycmF5KGNiKSkge1xyXG4gICAgICAgIGlmICghYWN0aXZlUXVldWUgfHxcclxuICAgICAgICAgICAgIWFjdGl2ZVF1ZXVlLmluY2x1ZGVzKGNiLCBjYi5hbGxvd1JlY3Vyc2UgPyBpbmRleCArIDEgOiBpbmRleCkpIHtcclxuICAgICAgICAgICAgcGVuZGluZ1F1ZXVlLnB1c2goY2IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGlmIGNiIGlzIGFuIGFycmF5LCBpdCBpcyBhIGNvbXBvbmVudCBsaWZlY3ljbGUgaG9vayB3aGljaCBjYW4gb25seSBiZVxyXG4gICAgICAgIC8vIHRyaWdnZXJlZCBieSBhIGpvYiwgd2hpY2ggaXMgYWxyZWFkeSBkZWR1cGVkIGluIHRoZSBtYWluIHF1ZXVlLCBzb1xyXG4gICAgICAgIC8vIHdlIGNhbiBza2lwIGR1cGxpY2F0ZSBjaGVjayBoZXJlIHRvIGltcHJvdmUgcGVyZlxyXG4gICAgICAgIHBlbmRpbmdRdWV1ZS5wdXNoKC4uLmNiKTtcclxuICAgIH1cclxuICAgIHF1ZXVlRmx1c2goKTtcclxufVxyXG5mdW5jdGlvbiBxdWV1ZVByZUZsdXNoQ2IoY2IpIHtcclxuICAgIHF1ZXVlQ2IoY2IsIGFjdGl2ZVByZUZsdXNoQ2JzLCBwZW5kaW5nUHJlRmx1c2hDYnMsIHByZUZsdXNoSW5kZXgpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlUG9zdEZsdXNoQ2IoY2IpIHtcclxuICAgIHF1ZXVlQ2IoY2IsIGFjdGl2ZVBvc3RGbHVzaENicywgcGVuZGluZ1Bvc3RGbHVzaENicywgcG9zdEZsdXNoSW5kZXgpO1xyXG59XHJcbmZ1bmN0aW9uIGZsdXNoUHJlRmx1c2hDYnMoc2VlbiwgcGFyZW50Sm9iID0gbnVsbCkge1xyXG4gICAgaWYgKHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBwYXJlbnRKb2I7XHJcbiAgICAgICAgYWN0aXZlUHJlRmx1c2hDYnMgPSBbLi4ubmV3IFNldChwZW5kaW5nUHJlRmx1c2hDYnMpXTtcclxuICAgICAgICBwZW5kaW5nUHJlRmx1c2hDYnMubGVuZ3RoID0gMDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChwcmVGbHVzaEluZGV4ID0gMDsgcHJlRmx1c2hJbmRleCA8IGFjdGl2ZVByZUZsdXNoQ2JzLmxlbmd0aDsgcHJlRmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBhY3RpdmVQcmVGbHVzaENic1twcmVGbHVzaEluZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGl2ZVByZUZsdXNoQ2JzW3ByZUZsdXNoSW5kZXhdKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVByZUZsdXNoQ2JzID0gbnVsbDtcclxuICAgICAgICBwcmVGbHVzaEluZGV4ID0gMDtcclxuICAgICAgICBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBudWxsO1xyXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGZsdXNoIHVudGlsIGl0IGRyYWluc1xyXG4gICAgICAgIGZsdXNoUHJlRmx1c2hDYnMoc2VlbiwgcGFyZW50Sm9iKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmbHVzaFBvc3RGbHVzaENicyhzZWVuKSB7XHJcbiAgICBpZiAocGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBkZWR1cGVkID0gWy4uLm5ldyBTZXQocGVuZGluZ1Bvc3RGbHVzaENicyldO1xyXG4gICAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoID0gMDtcclxuICAgICAgICAvLyAjMTk0NyBhbHJlYWR5IGhhcyBhY3RpdmUgcXVldWUsIG5lc3RlZCBmbHVzaFBvc3RGbHVzaENicyBjYWxsXHJcbiAgICAgICAgaWYgKGFjdGl2ZVBvc3RGbHVzaENicykge1xyXG4gICAgICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMucHVzaCguLi5kZWR1cGVkKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBkZWR1cGVkO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMuc29ydCgoYSwgYikgPT4gZ2V0SWQoYSkgLSBnZXRJZChiKSk7XHJcbiAgICAgICAgZm9yIChwb3N0Rmx1c2hJbmRleCA9IDA7IHBvc3RGbHVzaEluZGV4IDwgYWN0aXZlUG9zdEZsdXNoQ2JzLmxlbmd0aDsgcG9zdEZsdXNoSW5kZXgrKykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcclxuICAgICAgICBwb3N0Rmx1c2hJbmRleCA9IDA7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IEluZmluaXR5IDogam9iLmlkO1xyXG5mdW5jdGlvbiBmbHVzaEpvYnMoc2Vlbikge1xyXG4gICAgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcclxuICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGZsdXNoUHJlRmx1c2hDYnMoc2Vlbik7XHJcbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cclxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxyXG4gICAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xyXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkIHNvIGl0cyByZW5kZXIgZWZmZWN0IHdpbGwgaGF2ZSBzbWFsbGVyXHJcbiAgICAvLyAgICBwcmlvcml0eSBudW1iZXIpXHJcbiAgICAvLyAyLiBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHVwZGF0ZSxcclxuICAgIC8vICAgIGl0cyB1cGRhdGUgY2FuIGJlIHNraXBwZWQuXHJcbiAgICBxdWV1ZS5zb3J0KChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm9yIChmbHVzaEluZGV4ID0gMDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoam9iICYmIGpvYi5hY3RpdmUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBqb2IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoam9iLCBudWxsLCAxNCAvKiBTQ0hFRFVMRVIgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgZmx1c2hJbmRleCA9IDA7XHJcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcclxuICAgICAgICBmbHVzaFBvc3RGbHVzaENicyhzZWVuKTtcclxuICAgICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgLy8gc29tZSBwb3N0Rmx1c2hDYiBxdWV1ZWQgam9icyFcclxuICAgICAgICAvLyBrZWVwIGZsdXNoaW5nIHVudGlsIGl0IGRyYWlucy5cclxuICAgICAgICBpZiAocXVldWUubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgIHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGggfHxcclxuICAgICAgICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZmx1c2hKb2JzKHNlZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgZm4pIHtcclxuICAgIGlmICghc2Vlbi5oYXMoZm4pKSB7XHJcbiAgICAgICAgc2Vlbi5zZXQoZm4sIDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSBzZWVuLmdldChmbik7XHJcbiAgICAgICAgaWYgKGNvdW50ID4gUkVDVVJTSU9OX0xJTUlUKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gZm4ub3duZXJJbnN0YW5jZTtcclxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGluc3RhbmNlICYmIGdldENvbXBvbmVudE5hbWUoaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgICAgIHdhcm4oYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBgICtcclxuICAgICAgICAgICAgICAgIGBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBgICtcclxuICAgICAgICAgICAgICAgIGBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgYCArXHJcbiAgICAgICAgICAgICAgICBgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNlZW4uc2V0KGZuLCBjb3VudCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxubGV0IGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcclxuY29uc3QgaG1yRGlydHlDb21wb25lbnRzID0gbmV3IFNldCgpO1xyXG4vLyBFeHBvc2UgdGhlIEhNUiBydW50aW1lIG9uIHRoZSBnbG9iYWwgb2JqZWN0XHJcbi8vIFRoaXMgbWFrZXMgaXQgZW50aXJlbHkgdHJlZS1zaGFrYWJsZSB3aXRob3V0IHBvbGx1dGluZyB0aGUgZXhwb3J0cyBhbmQgbWFrZXNcclxuLy8gaXQgZWFzaWVyIHRvIGJlIHVzZWQgaW4gdG9vbGluZ3MgbGlrZSB2dWUtbG9hZGVyXHJcbi8vIE5vdGU6IGZvciBhIGNvbXBvbmVudCB0byBiZSBlbGlnaWJsZSBmb3IgSE1SIGl0IGFsc28gbmVlZHMgdGhlIF9faG1ySWQgb3B0aW9uXHJcbi8vIHRvIGJlIHNldCBzbyB0aGF0IGl0cyBpbnN0YW5jZXMgY2FuIGJlIHJlZ2lzdGVyZWQgLyByZW1vdmVkLlxyXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICBjb25zdCBnbG9iYWxPYmplY3QgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgID8gZ2xvYmFsXHJcbiAgICAgICAgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgPyBzZWxmXHJcbiAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgID8gd2luZG93XHJcbiAgICAgICAgICAgICAgICA6IHt9O1xyXG4gICAgZ2xvYmFsT2JqZWN0Ll9fVlVFX0hNUl9SVU5USU1FX18gPSB7XHJcbiAgICAgICAgY3JlYXRlUmVjb3JkOiB0cnlXcmFwKGNyZWF0ZVJlY29yZCksXHJcbiAgICAgICAgcmVyZW5kZXI6IHRyeVdyYXAocmVyZW5kZXIpLFxyXG4gICAgICAgIHJlbG9hZDogdHJ5V3JhcChyZWxvYWQpXHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGlkID0gaW5zdGFuY2UudHlwZS5fX2htcklkO1xyXG4gICAgbGV0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xyXG4gICAgaWYgKCFyZWNvcmQpIHtcclxuICAgICAgICBjcmVhdGVSZWNvcmQoaWQsIGluc3RhbmNlLnR5cGUpO1xyXG4gICAgICAgIHJlY29yZCA9IG1hcC5nZXQoaWQpO1xyXG4gICAgfVxyXG4gICAgcmVjb3JkLmluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xyXG59XHJcbmZ1bmN0aW9uIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcclxuICAgIG1hcC5nZXQoaW5zdGFuY2UudHlwZS5fX2htcklkKS5pbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWNvcmQoaWQsIGNvbXBvbmVudCkge1xyXG4gICAgaWYgKCFjb21wb25lbnQpIHtcclxuICAgICAgICB3YXJuKGBITVIgQVBJIHVzYWdlIGlzIG91dCBvZiBkYXRlLlxcbmAgK1xyXG4gICAgICAgICAgICBgUGxlYXNlIHVwZ3JhZGUgdnVlLWxvYWRlci92aXRlL3JvbGx1cC1wbHVnaW4tdnVlIG9yIG90aGVyIHJlbGV2YW50IGAgK1xyXG4gICAgICAgICAgICBgZGVwZW5kZW5jeSB0aGF0IGhhbmRsZXMgVnVlIFNGQyBjb21waWxhdGlvbi5gKTtcclxuICAgICAgICBjb21wb25lbnQgPSB7fTtcclxuICAgIH1cclxuICAgIGlmIChtYXAuaGFzKGlkKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIG1hcC5zZXQoaWQsIHtcclxuICAgICAgICBjb21wb25lbnQ6IGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSA/IGNvbXBvbmVudC5fX3ZjY09wdHMgOiBjb21wb25lbnQsXHJcbiAgICAgICAgaW5zdGFuY2VzOiBuZXcgU2V0KClcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcmVyZW5kZXIoaWQsIG5ld1JlbmRlcikge1xyXG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBpZiAobmV3UmVuZGVyKVxyXG4gICAgICAgIHJlY29yZC5jb21wb25lbnQucmVuZGVyID0gbmV3UmVuZGVyO1xyXG4gICAgLy8gQXJyYXkuZnJvbSBjcmVhdGVzIGEgc25hcHNob3Qgd2hpY2ggYXZvaWRzIHRoZSBzZXQgYmVpbmcgbXV0YXRlZCBkdXJpbmdcclxuICAgIC8vIHVwZGF0ZXNcclxuICAgIEFycmF5LmZyb20ocmVjb3JkLmluc3RhbmNlcykuZm9yRWFjaChpbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgaWYgKG5ld1JlbmRlcikge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSBuZXdSZW5kZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlckNhY2hlID0gW107XHJcbiAgICAgICAgLy8gdGhpcyBmbGFnIGZvcmNlcyBjaGlsZCBjb21wb25lbnRzIHdpdGggc2xvdCBjb250ZW50IHRvIHVwZGF0ZVxyXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xyXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlbG9hZChpZCwgbmV3Q29tcCkge1xyXG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICAvLyBBcnJheS5mcm9tIGNyZWF0ZXMgYSBzbmFwc2hvdCB3aGljaCBhdm9pZHMgdGhlIHNldCBiZWluZyBtdXRhdGVkIGR1cmluZ1xyXG4gICAgLy8gdXBkYXRlc1xyXG4gICAgY29uc3QgeyBjb21wb25lbnQsIGluc3RhbmNlcyB9ID0gcmVjb3JkO1xyXG4gICAgaWYgKCFobXJEaXJ0eUNvbXBvbmVudHMuaGFzKGNvbXBvbmVudCkpIHtcclxuICAgICAgICAvLyAxLiBVcGRhdGUgZXhpc3RpbmcgY29tcCBkZWZpbml0aW9uIHRvIG1hdGNoIG5ldyBvbmVcclxuICAgICAgICBuZXdDb21wID0gaXNDbGFzc0NvbXBvbmVudChuZXdDb21wKSA/IG5ld0NvbXAuX192Y2NPcHRzIDogbmV3Q29tcDtcclxuICAgICAgICBleHRlbmQoY29tcG9uZW50LCBuZXdDb21wKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ19fZmlsZScgJiYgIShrZXkgaW4gbmV3Q29tcCkpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb21wb25lbnRba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAyLiBNYXJrIGNvbXBvbmVudCBkaXJ0eS4gVGhpcyBmb3JjZXMgdGhlIHJlbmRlcmVyIHRvIHJlcGxhY2UgdGhlIGNvbXBvbmVudFxyXG4gICAgICAgIC8vIG9uIHBhdGNoLlxyXG4gICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQoY29tcG9uZW50KTtcclxuICAgICAgICAvLyAzLiBNYWtlIHN1cmUgdG8gdW5tYXJrIHRoZSBjb21wb25lbnQgYWZ0ZXIgdGhlIHJlbG9hZC5cclxuICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKCgpID0+IHtcclxuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmRlbGV0ZShjb21wb25lbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgQXJyYXkuZnJvbShpbnN0YW5jZXMpLmZvckVhY2goaW5zdGFuY2UgPT4ge1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgLy8gNC4gRm9yY2UgdGhlIHBhcmVudCBpbnN0YW5jZSB0byByZS1yZW5kZXIuIFRoaXMgd2lsbCBjYXVzZSBhbGwgdXBkYXRlZFxyXG4gICAgICAgICAgICAvLyBjb21wb25lbnRzIHRvIGJlIHVubW91bnRlZCBhbmQgcmUtbW91bnRlZC4gUXVldWUgdGhlIHVwZGF0ZSBzbyB0aGF0IHdlXHJcbiAgICAgICAgICAgIC8vIGRvbid0IGVuZCB1cCBmb3JjaW5nIHRoZSBzYW1lIHBhcmVudCB0byByZS1yZW5kZXIgbXVsdGlwbGUgdGltZXMuXHJcbiAgICAgICAgICAgIHF1ZXVlSm9iKGluc3RhbmNlLnBhcmVudC51cGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCkge1xyXG4gICAgICAgICAgICAvLyByb290IGluc3RhbmNlIG1vdW50ZWQgdmlhIGNyZWF0ZUFwcCgpIGhhcyBhIHJlbG9hZCBtZXRob2RcclxuICAgICAgICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy8gcm9vdCBpbnN0YW5jZSBpbnNpZGUgdHJlZSBjcmVhdGVkIHZpYSByYXcgcmVuZGVyKCkuIEZvcmNlIHJlbG9hZC5cclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbSE1SXSBSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcclxuICAgIHJldHVybiAoaWQsIGFyZykgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbSE1SXSBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBgICtcclxuICAgICAgICAgICAgICAgIGBGdWxsIHJlbG9hZCByZXF1aXJlZC5gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmxldCBkZXZ0b29scztcclxuZnVuY3Rpb24gc2V0RGV2dG9vbHNIb29rKGhvb2spIHtcclxuICAgIGRldnRvb2xzID0gaG9vaztcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKSB7XHJcbiAgICAvLyBUT0RPIHF1ZXVlIGlmIGRldnRvb2xzIGlzIHVuZGVmaW5lZFxyXG4gICAgaWYgKCFkZXZ0b29scylcclxuICAgICAgICByZXR1cm47XHJcbiAgICBkZXZ0b29scy5lbWl0KFwiYXBwOmluaXRcIiAvKiBBUFBfSU5JVCAqLywgYXBwLCB2ZXJzaW9uLCB7XHJcbiAgICAgICAgRnJhZ21lbnQsXHJcbiAgICAgICAgVGV4dCxcclxuICAgICAgICBDb21tZW50OiBDb21tZW50JDEsXHJcbiAgICAgICAgU3RhdGljXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc1VubW91bnRBcHAoYXBwKSB7XHJcbiAgICBpZiAoIWRldnRvb2xzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGRldnRvb2xzLmVtaXQoXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xyXG59XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50QWRkZWQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDphZGRlZFwiIC8qIENPTVBPTkVOVF9BRERFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnVwZGF0ZWRcIiAvKiBDT01QT05FTlRfVVBEQVRFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnJlbW92ZWRcIiAvKiBDT01QT05FTlRfUkVNT1ZFRCAqLyk7XHJcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhob29rKSB7XHJcbiAgICByZXR1cm4gKGNvbXBvbmVudCkgPT4ge1xyXG4gICAgICAgIGlmICghZGV2dG9vbHMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBkZXZ0b29scy5lbWl0KGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LnBhcmVudCA/IGNvbXBvbmVudC5wYXJlbnQudWlkIDogdW5kZWZpbmVkLCBjb21wb25lbnQpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBkZXZ0b29sc1BlcmZTdGFydCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOnN0YXJ0XCIgLyogUEVSRk9STUFOQ0VfU1RBUlQgKi8pO1xyXG5jb25zdCBkZXZ0b29sc1BlcmZFbmQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjplbmRcIiAvKiBQRVJGT1JNQU5DRV9FTkQgKi8pO1xyXG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhob29rKSB7XHJcbiAgICByZXR1cm4gKGNvbXBvbmVudCwgdHlwZSwgdGltZSkgPT4ge1xyXG4gICAgICAgIGlmICghZGV2dG9vbHMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBkZXZ0b29scy5lbWl0KGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LCB0eXBlLCB0aW1lKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZGV2dG9vbHNDb21wb25lbnRFbWl0KGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcykge1xyXG4gICAgaWYgKCFkZXZ0b29scylcclxuICAgICAgICByZXR1cm47XHJcbiAgICBkZXZ0b29scy5lbWl0KFwiY29tcG9uZW50OmVtaXRcIiAvKiBDT01QT05FTlRfRU1JVCAqLywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpO1xyXG59XG5cbmNvbnN0IGRlcHJlY2F0aW9uRGF0YSA9IHtcclxuICAgIFtcIkdMT0JBTF9NT1VOVFwiIC8qIEdMT0JBTF9NT1VOVCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVGhlIGdsb2JhbCBhcHAgYm9vdHN0cmFwcGluZyBBUEkgaGFzIGNoYW5nZWQ6IHZtLiRtb3VudCgpIGFuZCB0aGUgXCJlbFwiIGAgK1xyXG4gICAgICAgICAgICBgb3B0aW9uIGhhdmUgYmVlbiByZW1vdmVkLiBVc2UgY3JlYXRlQXBwKFJvb3RDb21wb25lbnQpLm1vdW50KCkgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZ2xvYmFsLWFwaS5odG1sI21vdW50aW5nLWFwcC1pbnN0YW5jZWBcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfTU9VTlRfQ09OVEFJTkVSXCIgLyogR0xPQkFMX01PVU5UX0NPTlRBSU5FUiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlIGRldGVjdGVkIGRpcmVjdGl2ZXMgb24gdGhlIG1vdW50IGNvbnRhaW5lci4gYCArXHJcbiAgICAgICAgICAgIGBJbiBWdWUgMywgdGhlIGNvbnRhaW5lciBpcyBubyBsb25nZXIgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSB0ZW1wbGF0ZSBgICtcclxuICAgICAgICAgICAgYGFuZCB3aWxsIG5vdCBiZSBwcm9jZXNzZWQvcmVwbGFjZWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL21vdW50LWNoYW5nZXMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfRVhURU5EXCIgLyogR0xPQkFMX0VYVEVORCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlLmV4dGVuZCgpIGhhcyBiZWVuIHJlbW92ZWQgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIGRlZmluZUNvbXBvbmVudCgpIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvYXBpL2dsb2JhbC1hcGkuaHRtbCNkZWZpbmVjb21wb25lbnRgXHJcbiAgICB9LFxyXG4gICAgW1wiR0xPQkFMX1BST1RPVFlQRVwiIC8qIEdMT0JBTF9QUk9UT1RZUEUgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZS5wcm90b3R5cGUgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZSBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2dsb2JhbC1hcGkuaHRtbCN2dWUtcHJvdG90eXBlLXJlcGxhY2VkLWJ5LWNvbmZpZy1nbG9iYWxwcm9wZXJ0aWVzYFxyXG4gICAgfSxcclxuICAgIFtcIkdMT0JBTF9TRVRcIiAvKiBHTE9CQUxfU0VUICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBWdWUuc2V0KCkgaGFzIGJlZW4gcmVtb3ZlZCBhcyBpdCBpcyBubyBsb25nZXIgbmVlZGVkIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYFNpbXBseSB1c2UgbmF0aXZlIEphdmFTY3JpcHQgbXV0YXRpb25zLmBcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfREVMRVRFXCIgLyogR0xPQkFMX0RFTEVURSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlLmRlbGV0ZSgpIGhhcyBiZWVuIHJlbW92ZWQgYXMgaXQgaXMgbm8gbG9uZ2VyIG5lZWRlZCBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBTaW1wbHkgdXNlIG5hdGl2ZSBKYXZhU2NyaXB0IG11dGF0aW9ucy5gXHJcbiAgICB9LFxyXG4gICAgW1wiR0xPQkFMX09CU0VSVkFCTEVcIiAvKiBHTE9CQUxfT0JTRVJWQUJMRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlLm9ic2VydmFibGUoKSBoYXMgYmVlbiByZW1vdmVkLiBgICtcclxuICAgICAgICAgICAgYFVzZSBcXGBpbXBvcnQgeyByZWFjdGl2ZSB9IGZyb20gXCJ2dWVcIlxcYCBmcm9tIENvbXBvc2l0aW9uIEFQSSBpbnN0ZWFkLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2FwaS9iYXNpYy1yZWFjdGl2aXR5Lmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiR0xPQkFMX1BSSVZBVEVfVVRJTFwiIC8qIEdMT0JBTF9QUklWQVRFX1VUSUwgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZS51dGlsIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSByZWZhY3RvciB0byBhdm9pZCBpdHMgdXNhZ2UgYCArXHJcbiAgICAgICAgICAgIGBzaW5jZSBpdCB3YXMgYW4gaW50ZXJuYWwgQVBJIGV2ZW4gaW4gVnVlIDIuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19TSUxFTlRcIiAvKiBDT05GSUdfU0lMRU5UICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBjb25maWcuc2lsZW50IGhhcyBiZWVuIHJlbW92ZWQgYmVjYXVzZSBpdCBpcyBub3QgZ29vZCBwcmFjdGljZSB0byBgICtcclxuICAgICAgICAgICAgYGludGVudGlvbmFsbHkgc3VwcHJlc3Mgd2FybmluZ3MuIFlvdSBjYW4gdXNlIHlvdXIgYnJvd3NlciBjb25zb2xlJ3MgYCArXHJcbiAgICAgICAgICAgIGBmaWx0ZXIgZmVhdHVyZXMgdG8gZm9jdXMgb24gcmVsZXZhbnQgbWVzc2FnZXMuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19ERVZUT09MU1wiIC8qIENPTkZJR19ERVZUT09MUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgY29uZmlnLmRldnRvb2xzIGhhcyBiZWVuIHJlbW92ZWQuIFRvIGVuYWJsZSBkZXZ0b29scyBmb3IgYCArXHJcbiAgICAgICAgICAgIGBwcm9kdWN0aW9uLCBjb25maWd1cmUgdGhlIF9fVlVFX1BST0RfREVWVE9PTFNfXyBjb21waWxlLXRpbWUgZmxhZy5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLW5leHQvdHJlZS9tYXN0ZXIvcGFja2FnZXMvdnVlI2J1bmRsZXItYnVpbGQtZmVhdHVyZS1mbGFnc2BcclxuICAgIH0sXHJcbiAgICBbXCJDT05GSUdfS0VZX0NPREVTXCIgLyogQ09ORklHX0tFWV9DT0RFUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgY29uZmlnLmtleUNvZGVzIGhhcyBiZWVuIHJlbW92ZWQuIGAgK1xyXG4gICAgICAgICAgICBgSW4gVnVlIDMsIHlvdSBjYW4gZGlyZWN0bHkgdXNlIHRoZSBrZWJhYi1jYXNlIGtleSBuYW1lcyBhcyB2LW9uIG1vZGlmaWVycy5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24va2V5Y29kZS1tb2RpZmllcnMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT05GSUdfUFJPRFVDVElPTl9USVBcIiAvKiBDT05GSUdfUFJPRFVDVElPTl9USVAgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYGNvbmZpZy5wcm9kdWN0aW9uVGlwIGhhcyBiZWVuIHJlbW92ZWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2dsb2JhbC1hcGkuaHRtbCNjb25maWctcHJvZHVjdGlvbnRpcC1yZW1vdmVkYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19JR05PUkVEX0VMRU1FTlRTXCIgLyogQ09ORklHX0lHTk9SRURfRUxFTUVOVFMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbXNnID0gYGNvbmZpZy5pZ25vcmVkRWxlbWVudHMgaGFzIGJlZW4gcmVtb3ZlZC5gO1xyXG4gICAgICAgICAgICBpZiAoaXNSdW50aW1lT25seSgpKSB7XHJcbiAgICAgICAgICAgICAgICBtc2cgKz0gYCBQYXNzIHRoZSBcImlzQ3VzdG9tRWxlbWVudFwiIG9wdGlvbiB0byBAdnVlL2NvbXBpbGVyLWRvbSBpbnN0ZWFkLmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtc2cgKz0gYCBVc2UgY29uZmlnLmlzQ3VzdG9tRWxlbWVudCBpbnN0ZWFkLmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZ2xvYmFsLWFwaS5odG1sI2NvbmZpZy1pZ25vcmVkZWxlbWVudHMtaXMtbm93LWNvbmZpZy1pc2N1c3RvbWVsZW1lbnRgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09ORklHX1dISVRFU1BBQ0VcIiAvKiBDT05GSUdfV0hJVEVTUEFDRSAqL106IHtcclxuICAgICAgICAvLyB0aGlzIHdhcm5pbmcgaXMgb25seSByZWxldmFudCBpbiB0aGUgZnVsbCBidWlsZCB3aGVuIHVzaW5nIHJ1bnRpbWVcclxuICAgICAgICAvLyBjb21waWxhdGlvbiwgc28gaXQncyBwdXQgaW4gdGhlIHJ1bnRpbWUgY29tcGF0Q29uZmlnIGxpc3QuXHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZSAzIGNvbXBpbGVyJ3Mgd2hpdGVzcGFjZSBvcHRpb24gd2lsbCBkZWZhdWx0IHRvIFwiY29uZGVuc2VcIiBpbnN0ZWFkIG9mIGAgK1xyXG4gICAgICAgICAgICBgXCJwcmVzZXJ2ZVwiLiBUbyBzdXBwcmVzcyB0aGlzIHdhcm5pbmcsIHByb3ZpZGUgYW4gZXhwbGljaXQgdmFsdWUgZm9yIGAgK1xyXG4gICAgICAgICAgICBgXFxgY29uZmlnLmNvbXBpbGVyT3B0aW9ucy53aGl0ZXNwYWNlXFxgLmBcclxuICAgIH0sXHJcbiAgICBbXCJDT05GSUdfT1BUSU9OX01FUkdFX1NUUkFUU1wiIC8qIENPTkZJR19PUFRJT05fTUVSR0VfU1RSQVRTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzIG5vIGxvbmdlciBleHBvc2VzIGludGVybmFsIHN0cmF0ZWdpZXMuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIGN1c3RvbSBtZXJnZSBmdW5jdGlvbnMgaW5zdGVhZC5gXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfU0VUXCIgLyogSU5TVEFOQ0VfU0VUICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2bS4kc2V0KCkgaGFzIGJlZW4gcmVtb3ZlZCBhcyBpdCBpcyBubyBsb25nZXIgbmVlZGVkIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYFNpbXBseSB1c2UgbmF0aXZlIEphdmFTY3JpcHQgbXV0YXRpb25zLmBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9ERUxFVEVcIiAvKiBJTlNUQU5DRV9ERUxFVEUgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHZtLiRkZWxldGUoKSBoYXMgYmVlbiByZW1vdmVkIGFzIGl0IGlzIG5vIGxvbmdlciBuZWVkZWQgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgU2ltcGx5IHVzZSBuYXRpdmUgSmF2YVNjcmlwdCBtdXRhdGlvbnMuYFxyXG4gICAgfSxcclxuICAgIFtcIklOU1RBTkNFX0RFU1RST1lcIiAvKiBJTlNUQU5DRV9ERVNUUk9ZICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2bS4kZGVzdHJveSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhcHAudW5tb3VudCgpIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvYXBpL2FwcGxpY2F0aW9uLWFwaS5odG1sI3VubW91bnRgXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfRVZFTlRfRU1JVFRFUlwiIC8qIElOU1RBTkNFX0VWRU5UX0VNSVRURVIgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHZtLiRvbi8kb25jZS8kb2ZmKCkgaGF2ZSBiZWVuIHJlbW92ZWQuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIGFuIGV4dGVybmFsIGV2ZW50IGVtaXR0ZXIgbGlicmFyeSBpbnN0ZWFkLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9ldmVudHMtYXBpLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfRVZFTlRfSE9PS1NcIiAvKiBJTlNUQU5DRV9FVkVOVF9IT09LUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBldmVudCA9PiBgXCIke2V2ZW50fVwiIGxpZmVjeWNsZSBldmVudHMgYXJlIG5vIGxvbmdlciBzdXBwb3J0ZWQuIEZyb20gdGVtcGxhdGVzLCBgICtcclxuICAgICAgICAgICAgYHVzZSB0aGUgXCJ2bm9kZVwiIHByZWZpeCBpbnN0ZWFkIG9mIFwiaG9vazpcIi4gRm9yIGV4YW1wbGUsIEAke2V2ZW50fSBgICtcclxuICAgICAgICAgICAgYHNob3VsZCBiZSBjaGFuZ2VkIHRvIEB2bm9kZS0ke2V2ZW50LnNsaWNlKDUpfS4gYCArXHJcbiAgICAgICAgICAgIGBGcm9tIEphdmFTY3JpcHQsIHVzZSBDb21wb3NpdGlvbiBBUEkgdG8gZHluYW1pY2FsbHkgcmVnaXN0ZXIgbGlmZWN5Y2xlIGAgK1xyXG4gICAgICAgICAgICBgaG9va3MuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3Zub2RlLWxpZmVjeWNsZS1ldmVudHMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9DSElMRFJFTlwiIC8qIElOU1RBTkNFX0NISUxEUkVOICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2bS4kY2hpbGRyZW4gaGFzIGJlZW4gcmVtb3ZlZC4gQ29uc2lkZXIgcmVmYWN0b3JpbmcgeW91ciBsb2dpYyBgICtcclxuICAgICAgICAgICAgYHRvIGF2b2lkIHJlbHlpbmcgb24gZGlyZWN0IGFjY2VzcyB0byBjaGlsZCBjb21wb25lbnRzLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9jaGlsZHJlbi5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIklOU1RBTkNFX0xJU1RFTkVSU1wiIC8qIElOU1RBTkNFX0xJU1RFTkVSUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgdm0uJGxpc3RlbmVycyBoYXMgYmVlbiByZW1vdmVkLiBJbiBWdWUgMywgcGFyZW50IHYtb24gbGlzdGVuZXJzIGFyZSBgICtcclxuICAgICAgICAgICAgYGluY2x1ZGVkIGluIHZtLiRhdHRycyBhbmQgaXQgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSB0byBzZXBhcmF0ZWx5IHVzZSBgICtcclxuICAgICAgICAgICAgYHYtb249XCIkbGlzdGVuZXJzXCIgaWYgeW91IGFyZSBhbHJlYWR5IHVzaW5nIHYtYmluZD1cIiRhdHRyc1wiLiBgICtcclxuICAgICAgICAgICAgYChOb3RlOiB0aGUgVnVlIDMgYmVoYXZpb3Igb25seSBhcHBsaWVzIGlmIHRoaXMgY29tcGF0IGNvbmZpZyBpcyBkaXNhYmxlZClgLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vbGlzdGVuZXJzLXJlbW92ZWQuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9TQ09QRURfU0xPVFNcIiAvKiBJTlNUQU5DRV9TQ09QRURfU0xPVFMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHZtLiRzY29wZWRTbG90cyBoYXMgYmVlbiByZW1vdmVkLiBVc2Ugdm0uJHNsb3RzIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3Nsb3RzLXVuaWZpY2F0aW9uLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfQVRUUlNfQ0xBU1NfU1RZTEVcIiAvKiBJTlNUQU5DRV9BVFRSU19DTEFTU19TVFlMRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBjb21wb25lbnROYW1lID0+IGBDb21wb25lbnQgPCR7Y29tcG9uZW50TmFtZSB8fFxyXG4gICAgICAgICAgICAnQW5vbnltb3VzJ30+IGhhcyBcXGBpbmhlcml0QXR0cnM6IGZhbHNlXFxgIGJ1dCBpcyBgICtcclxuICAgICAgICAgICAgYHJlbHlpbmcgb24gY2xhc3Mvc3R5bGUgZmFsbHRocm91Z2ggZnJvbSBwYXJlbnQuIEluIFZ1ZSAzLCBjbGFzcy9zdHlsZSBgICtcclxuICAgICAgICAgICAgYGFyZSBub3cgaW5jbHVkZWQgaW4gJGF0dHJzIGFuZCB3aWxsIG5vIGxvbmdlciBmYWxsdGhyb3VnaCB3aGVuIGAgK1xyXG4gICAgICAgICAgICBgaW5oZXJpdEF0dHJzIGlzIGZhbHNlLiBJZiB5b3UgYXJlIGFscmVhZHkgdXNpbmcgdi1iaW5kPVwiJGF0dHJzXCIgb24gYCArXHJcbiAgICAgICAgICAgIGBjb21wb25lbnQgcm9vdCBpdCBzaG91bGQgcmVuZGVyIHRoZSBzYW1lIGVuZCByZXN1bHQuIGAgK1xyXG4gICAgICAgICAgICBgSWYgeW91IGFyZSBiaW5kaW5nICRhdHRycyB0byBhIG5vbi1yb290IGVsZW1lbnQgYW5kIGV4cGVjdGluZyBgICtcclxuICAgICAgICAgICAgYGNsYXNzL3N0eWxlIHRvIGZhbGx0aHJvdWdoIG9uIHJvb3QsIHlvdSB3aWxsIG5lZWQgdG8gbm93IG1hbnVhbGx5IGJpbmQgYCArXHJcbiAgICAgICAgICAgIGB0aGVtIG9uIHJvb3QgdmlhIDpjbGFzcz1cIiRhdHRycy5jbGFzc1wiLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9hdHRycy1pbmNsdWRlcy1jbGFzcy1zdHlsZS5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIk9QVElPTlNfREFUQV9GTlwiIC8qIE9QVElPTlNfREFUQV9GTiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVGhlIFwiZGF0YVwiIG9wdGlvbiBjYW4gbm8gbG9uZ2VyIGJlIGEgcGxhaW4gb2JqZWN0LiBgICtcclxuICAgICAgICAgICAgYEFsd2F5cyB1c2UgYSBmdW5jdGlvbi5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZGF0YS1vcHRpb24uaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJPUFRJT05TX0RBVEFfTUVSR0VcIiAvKiBPUFRJT05TX0RBVEFfTUVSR0UgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGtleSkgPT4gYERldGVjdGVkIGNvbmZsaWN0aW5nIGtleSBcIiR7a2V5fVwiIHdoZW4gbWVyZ2luZyBkYXRhIG9wdGlvbiB2YWx1ZXMuIGAgK1xyXG4gICAgICAgICAgICBgSW4gVnVlIDMsIGRhdGEga2V5cyBhcmUgbWVyZ2VkIHNoYWxsb3dseSBhbmQgd2lsbCBvdmVycmlkZSBvbmUgYW5vdGhlci5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZGF0YS1vcHRpb24uaHRtbCNtaXhpbi1tZXJnZS1iZWhhdmlvci1jaGFuZ2VgXHJcbiAgICB9LFxyXG4gICAgW1wiT1BUSU9OU19CRUZPUkVfREVTVFJPWVwiIC8qIE9QVElPTlNfQkVGT1JFX0RFU1RST1kgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFxcYGJlZm9yZURlc3Ryb3lcXGAgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBiZWZvcmVVbm1vdW50XFxgLmBcclxuICAgIH0sXHJcbiAgICBbXCJPUFRJT05TX0RFU1RST1lFRFwiIC8qIE9QVElPTlNfREVTVFJPWUVEICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBcXGBkZXN0cm95ZWRcXGAgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGB1bm1vdW50ZWRcXGAuYFxyXG4gICAgfSxcclxuICAgIFtcIldBVENIX0FSUkFZXCIgLyogV0FUQ0hfQVJSQVkgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFwid2F0Y2hcIiBvcHRpb24gb3Igdm0uJHdhdGNoIG9uIGFuIGFycmF5IHZhbHVlIHdpbGwgbm8gbG9uZ2VyIGAgK1xyXG4gICAgICAgICAgICBgdHJpZ2dlciBvbiBhcnJheSBtdXRhdGlvbiB1bmxlc3MgdGhlIFwiZGVlcFwiIG9wdGlvbiBpcyBzcGVjaWZpZWQuIGAgK1xyXG4gICAgICAgICAgICBgSWYgY3VycmVudCB1c2FnZSBpcyBpbnRlbmRlZCwgeW91IGNhbiBkaXNhYmxlIHRoZSBjb21wYXQgYmVoYXZpb3IgYW5kIGAgK1xyXG4gICAgICAgICAgICBgc3VwcHJlc3MgdGhpcyB3YXJuaW5nIHdpdGg6YCArXHJcbiAgICAgICAgICAgIGBcXG5cXG4gIGNvbmZpZ3VyZUNvbXBhdCh7ICR7XCJXQVRDSF9BUlJBWVwiIC8qIFdBVENIX0FSUkFZICovfTogZmFsc2UgfSlcXG5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vd2F0Y2guaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJQUk9QU19ERUZBVUxUX1RISVNcIiAvKiBQUk9QU19ERUZBVUxUX1RISVMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGtleSkgPT4gYHByb3BzIGRlZmF1bHQgdmFsdWUgZnVuY3Rpb24gbm8gbG9uZ2VyIGhhcyBhY2Nlc3MgdG8gXCJ0aGlzXCIuIFRoZSBjb21wYXQgYCArXHJcbiAgICAgICAgICAgIGBidWlsZCBvbmx5IG9mZmVycyBhY2Nlc3MgdG8gdGhpcy4kb3B0aW9ucy5gICtcclxuICAgICAgICAgICAgYChmb3VuZCBpbiBwcm9wIFwiJHtrZXl9XCIpYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3Byb3BzLWRlZmF1bHQtdGhpcy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNVU1RPTV9ESVJcIiAvKiBDVVNUT01fRElSICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IChsZWdhY3lIb29rLCBuZXdIb29rKSA9PiBgQ3VzdG9tIGRpcmVjdGl2ZSBob29rIFwiJHtsZWdhY3lIb29rfVwiIGhhcyBiZWVuIHJlbW92ZWQuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIFwiJHtuZXdIb29rfVwiIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2N1c3RvbS1kaXJlY3RpdmVzLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiVl9GT1JfUkVGXCIgLyogVl9GT1JfUkVGICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBSZWYgdXNhZ2Ugb24gdi1mb3Igbm8gbG9uZ2VyIGNyZWF0ZXMgYXJyYXkgcmVmIHZhbHVlcyBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBDb25zaWRlciB1c2luZyBmdW5jdGlvbiByZWZzIG9yIHJlZmFjdG9yIHRvIGF2b2lkIHJlZiB1c2FnZSBhbHRvZ2V0aGVyLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9hcnJheS1yZWZzLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiVl9PTl9LRVlDT0RFX01PRElGSUVSXCIgLyogVl9PTl9LRVlDT0RFX01PRElGSUVSICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBVc2luZyBrZXlDb2RlIGFzIHYtb24gbW9kaWZpZXIgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gYCArXHJcbiAgICAgICAgICAgIGBVc2Uga2ViYWItY2FzZSBrZXkgbmFtZSBtb2RpZmllcnMgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24va2V5Y29kZS1tb2RpZmllcnMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJBVFRSX0ZBTFNFX1ZBTFVFXCIgLyogQVRUUl9GQUxTRV9WQUxVRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiAobmFtZSkgPT4gYEF0dHJpYnV0ZSBcIiR7bmFtZX1cIiB3aXRoIHYtYmluZCB2YWx1ZSBcXGBmYWxzZVxcYCB3aWxsIHJlbmRlciBgICtcclxuICAgICAgICAgICAgYCR7bmFtZX09XCJmYWxzZVwiIGluc3RlYWQgb2YgcmVtb3ZpbmcgaXQgaW4gVnVlIDMuIFRvIHJlbW92ZSB0aGUgYXR0cmlidXRlLCBgICtcclxuICAgICAgICAgICAgYHVzZSBcXGBudWxsXFxgIG9yIFxcYHVuZGVmaW5lZFxcYCBpbnN0ZWFkLiBJZiB0aGUgdXNhZ2UgaXMgaW50ZW5kZWQsIGAgK1xyXG4gICAgICAgICAgICBgeW91IGNhbiBkaXNhYmxlIHRoZSBjb21wYXQgYmVoYXZpb3IgYW5kIHN1cHByZXNzIHRoaXMgd2FybmluZyB3aXRoOmAgK1xyXG4gICAgICAgICAgICBgXFxuXFxuICBjb25maWd1cmVDb21wYXQoeyAke1wiQVRUUl9GQUxTRV9WQUxVRVwiIC8qIEFUVFJfRkFMU0VfVkFMVUUgKi99OiBmYWxzZSB9KVxcbmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9hdHRyaWJ1dGUtY29lcmNpb24uaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJBVFRSX0VOVU1FUkFURURfQ09FUkNJT05cIiAvKiBBVFRSX0VOVU1FUkFURURfQ09FUkNJT04gKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKG5hbWUsIHZhbHVlLCBjb2VyY2VkKSA9PiBgRW51bWVyYXRlZCBhdHRyaWJ1dGUgXCIke25hbWV9XCIgd2l0aCB2LWJpbmQgdmFsdWUgXFxgJHt2YWx1ZX1cXGAgd2lsbCBgICtcclxuICAgICAgICAgICAgYCR7dmFsdWUgPT09IG51bGwgPyBgYmUgcmVtb3ZlZGAgOiBgcmVuZGVyIHRoZSB2YWx1ZSBhcy1pc2B9IGluc3RlYWQgb2YgY29lcmNpbmcgdGhlIHZhbHVlIHRvIFwiJHtjb2VyY2VkfVwiIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYEFsd2F5cyB1c2UgZXhwbGljaXQgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiIHZhbHVlcyBmb3IgZW51bWVyYXRlZCBhdHRyaWJ1dGVzLiBgICtcclxuICAgICAgICAgICAgYElmIHRoZSB1c2FnZSBpcyBpbnRlbmRlZCwgYCArXHJcbiAgICAgICAgICAgIGB5b3UgY2FuIGRpc2FibGUgdGhlIGNvbXBhdCBiZWhhdmlvciBhbmQgc3VwcHJlc3MgdGhpcyB3YXJuaW5nIHdpdGg6YCArXHJcbiAgICAgICAgICAgIGBcXG5cXG4gIGNvbmZpZ3VyZUNvbXBhdCh7ICR7XCJBVFRSX0VOVU1FUkFURURfQ09FUkNJT05cIiAvKiBBVFRSX0VOVU1FUkFURURfQ09FUkNJT04gKi99OiBmYWxzZSB9KVxcbmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9hdHRyaWJ1dGUtY29lcmNpb24uaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJUUkFOU0lUSU9OX0NMQVNTRVNcIiAvKiBUUkFOU0lUSU9OX0NMQVNTRVMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYGAgLy8gdGhpcyBmZWF0dXJlIGNhbm5vdCBiZSBydW50aW1lLWRldGVjdGVkXHJcbiAgICB9LFxyXG4gICAgW1wiVFJBTlNJVElPTl9HUk9VUF9ST09UXCIgLyogVFJBTlNJVElPTl9HUk9VUF9ST09UICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGA8VHJhbnNpdGlvbkdyb3VwPiBubyBsb25nZXIgcmVuZGVycyBhIHJvb3QgPHNwYW4+IGVsZW1lbnQgYnkgYCArXHJcbiAgICAgICAgICAgIGBkZWZhdWx0IGlmIG5vIFwidGFnXCIgcHJvcCBpcyBzcGVjaWZpZWQuIElmIHlvdSBkbyBub3QgcmVseSBvbiB0aGUgc3BhbiBgICtcclxuICAgICAgICAgICAgYGZvciBzdHlsaW5nLCB5b3UgY2FuIGRpc2FibGUgdGhlIGNvbXBhdCBiZWhhdmlvciBhbmQgc3VwcHJlc3MgdGhpcyBgICtcclxuICAgICAgICAgICAgYHdhcm5pbmcgd2l0aDpgICtcclxuICAgICAgICAgICAgYFxcblxcbiAgY29uZmlndXJlQ29tcGF0KHsgJHtcIlRSQU5TSVRJT05fR1JPVVBfUk9PVFwiIC8qIFRSQU5TSVRJT05fR1JPVVBfUk9PVCAqL306IGZhbHNlIH0pXFxuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3RyYW5zaXRpb24tZ3JvdXAuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QT05FTlRfQVNZTkNcIiAvKiBDT01QT05FTlRfQVNZTkMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGNvbXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoYEFzeW5jIGNvbXBvbmVudCR7bmFtZSA/IGAgPCR7bmFtZX0+YCA6IGBzYH0gc2hvdWxkIGJlIGV4cGxpY2l0bHkgY3JlYXRlZCB2aWEgXFxgZGVmaW5lQXN5bmNDb21wb25lbnQoKVxcYCBgICtcclxuICAgICAgICAgICAgICAgIGBpbiBWdWUgMy4gUGxhaW4gZnVuY3Rpb25zIHdpbGwgYmUgdHJlYXRlZCBhcyBmdW5jdGlvbmFsIGNvbXBvbmVudHMgaW4gYCArXHJcbiAgICAgICAgICAgICAgICBgbm9uLWNvbXBhdCBidWlsZC4gSWYgeW91IGhhdmUgYWxyZWFkeSBtaWdyYXRlZCBhbGwgYXN5bmMgY29tcG9uZW50IGAgK1xyXG4gICAgICAgICAgICAgICAgYHVzYWdlIGFuZCBpbnRlbmQgdG8gdXNlIHBsYWluIGZ1bmN0aW9ucyBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLCBgICtcclxuICAgICAgICAgICAgICAgIGB5b3UgY2FuIGRpc2FibGUgdGhlIGNvbXBhdCBiZWhhdmlvciBhbmQgc3VwcHJlc3MgdGhpcyBgICtcclxuICAgICAgICAgICAgICAgIGB3YXJuaW5nIHdpdGg6YCArXHJcbiAgICAgICAgICAgICAgICBgXFxuXFxuICBjb25maWd1cmVDb21wYXQoeyAke1wiQ09NUE9ORU5UX0FTWU5DXCIgLyogQ09NUE9ORU5UX0FTWU5DICovfTogZmFsc2UgfSlcXG5gKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vYXN5bmMtY29tcG9uZW50cy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBPTkVOVF9GVU5DVElPTkFMXCIgLyogQ09NUE9ORU5UX0ZVTkNUSU9OQUwgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGNvbXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoYEZ1bmN0aW9uYWwgY29tcG9uZW50JHtuYW1lID8gYCA8JHtuYW1lfT5gIDogYHNgfSBzaG91bGQgYmUgZGVmaW5lZCBhcyBhIHBsYWluIGZ1bmN0aW9uIGluIFZ1ZSAzLiBUaGUgXCJmdW5jdGlvbmFsXCIgYCArXHJcbiAgICAgICAgICAgICAgICBgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQuIE5PVEU6IEJlZm9yZSBtaWdyYXRpbmcgdG8gdXNlIHBsYWluIGAgK1xyXG4gICAgICAgICAgICAgICAgYGZ1bmN0aW9ucyBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLCBmaXJzdCBtYWtlIHN1cmUgdGhhdCBhbGwgYXN5bmMgYCArXHJcbiAgICAgICAgICAgICAgICBgY29tcG9uZW50cyB1c2FnZSBoYXZlIGJlZW4gbWlncmF0ZWQgYW5kIGl0cyBjb21wYXQgYmVoYXZpb3IgaGFzIGAgK1xyXG4gICAgICAgICAgICAgICAgYGJlZW4gZGlzYWJsZWQuYCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2Z1bmN0aW9uYWwtY29tcG9uZW50cy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBPTkVOVF9WX01PREVMXCIgLyogQ09NUE9ORU5UX1ZfTU9ERUwgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGNvbXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29uZmlnTXNnID0gYG9wdC1pbiB0byBgICtcclxuICAgICAgICAgICAgICAgIGBWdWUgMyBiZWhhdmlvciBvbiBhIHBlci1jb21wb25lbnQgYmFzaXMgd2l0aCBcXGBjb21wYXRDb25maWc6IHsgJHtcIkNPTVBPTkVOVF9WX01PREVMXCIgLyogQ09NUE9ORU5UX1ZfTU9ERUwgKi99OiBmYWxzZSB9XFxgLmA7XHJcbiAgICAgICAgICAgIGlmIChjb21wLnByb3BzICYmXHJcbiAgICAgICAgICAgICAgICAoaXNBcnJheShjb21wLnByb3BzKVxyXG4gICAgICAgICAgICAgICAgICAgID8gY29tcC5wcm9wcy5pbmNsdWRlcygnbW9kZWxWYWx1ZScpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBoYXNPd24oY29tcC5wcm9wcywgJ21vZGVsVmFsdWUnKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoYENvbXBvbmVudCBkZWxjYXJlcyBcIm1vZGVsVmFsdWVcIiBwcm9wLCB3aGljaCBpcyBWdWUgMyB1c2FnZSwgYnV0IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBpcyBydW5uaW5nIHVuZGVyIFZ1ZSAyIGNvbXBhdCB2LW1vZGVsIGJlaGF2aW9yLiBZb3UgY2FuICR7Y29uZmlnTXNnfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAoYHYtbW9kZWwgdXNhZ2Ugb24gY29tcG9uZW50IGhhcyBjaGFuZ2VkIGluIFZ1ZSAzLiBDb21wb25lbnQgdGhhdCBleHBlY3RzIGAgK1xyXG4gICAgICAgICAgICAgICAgYHRvIHdvcmsgd2l0aCB2LW1vZGVsIHNob3VsZCBub3cgdXNlIHRoZSBcIm1vZGVsVmFsdWVcIiBwcm9wIGFuZCBlbWl0IHRoZSBgICtcclxuICAgICAgICAgICAgICAgIGBcInVwZGF0ZTptb2RlbFZhbHVlXCIgZXZlbnQuIFlvdSBjYW4gdXBkYXRlIHRoZSB1c2FnZSBhbmQgdGhlbiAke2NvbmZpZ01zZ31gKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vdi1tb2RlbC5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIlJFTkRFUl9GVU5DVElPTlwiIC8qIFJFTkRFUl9GVU5DVElPTiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlIDMncyByZW5kZXIgZnVuY3Rpb24gQVBJIGhhcyBjaGFuZ2VkLiBgICtcclxuICAgICAgICAgICAgYFlvdSBjYW4gb3B0LWluIHRvIHRoZSBuZXcgQVBJIHdpdGg6YCArXHJcbiAgICAgICAgICAgIGBcXG5cXG4gIGNvbmZpZ3VyZUNvbXBhdCh7ICR7XCJSRU5ERVJfRlVOQ1RJT05cIiAvKiBSRU5ERVJfRlVOQ1RJT04gKi99OiBmYWxzZSB9KVxcbmAgK1xyXG4gICAgICAgICAgICBgXFxuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIHBlci1jb21wb25lbnQgdmlhIHRoZSBcImNvbXBhdENvbmZpZ1wiIG9wdGlvbi4pYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3JlbmRlci1mdW5jdGlvbi1hcGkuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJGSUxURVJTXCIgLyogRklMVEVSUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgZmlsdGVycyBoYXZlIGJlZW4gcmVtb3ZlZCBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBUaGUgXCJ8XCIgc3ltYm9sIHdpbGwgYmUgdHJlYXRlZCBhcyBuYXRpdmUgSmF2YVNjcmlwdCBiaXR3aXNlIE9SIG9wZXJhdG9yLiBgICtcclxuICAgICAgICAgICAgYFVzZSBtZXRob2QgY2FsbHMgb3IgY29tcHV0ZWQgcHJvcGVydGllcyBpbnN0ZWFkLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9maWx0ZXJzLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiUFJJVkFURV9BUElTXCIgLyogUFJJVkFURV9BUElTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IG5hbWUgPT4gYFwiJHtuYW1lfVwiIGlzIGEgVnVlIDIgcHJpdmF0ZSBBUEkgdGhhdCBubyBsb25nZXIgZXhpc3RzIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYElmIHlvdSBhcmUgc2VlaW5nIHRoaXMgd2FybmluZyBvbmx5IGR1ZSB0byBhIGRlcGVuZGVuY3ksIHlvdSBjYW4gYCArXHJcbiAgICAgICAgICAgIGBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgdmlhIHsgUFJJVkFURV9BUElTOiAnc3VwcmVzcy13YXJuaW5nJyB9LmBcclxuICAgIH1cclxufTtcclxuY29uc3QgaW5zdGFuY2VXYXJuZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5jb25zdCB3YXJuQ291bnQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5mdW5jdGlvbiB3YXJuRGVwcmVjYXRpb24oa2V5LCBpbnN0YW5jZSwgLi4uYXJncykge1xyXG4gICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpbnN0YW5jZSA9IGluc3RhbmNlIHx8IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgLy8gY2hlY2sgdXNlciBjb25maWdcclxuICAgIGNvbnN0IGNvbmZpZyA9IGdldENvbXBhdENvbmZpZ0ZvcktleShrZXksIGluc3RhbmNlKTtcclxuICAgIGlmIChjb25maWcgPT09ICdzdXBwcmVzcy13YXJuaW5nJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGR1cEtleSA9IGtleSArIGFyZ3Muam9pbignJyk7XHJcbiAgICBsZXQgY29tcElkID0gaW5zdGFuY2UgJiYgZm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSk7XHJcbiAgICBpZiAoY29tcElkID09PSAnQW5vbnltb3VzJyAmJiBpbnN0YW5jZSkge1xyXG4gICAgICAgIGNvbXBJZCA9IGluc3RhbmNlLnVpZDtcclxuICAgIH1cclxuICAgIC8vIHNraXAgaWYgdGhlIHNhbWUgd2FybmluZyBpcyBlbWl0dGVkIGZvciB0aGUgc2FtZSBjb21wb25lbnQgdHlwZVxyXG4gICAgY29uc3QgY29tcG9uZW50RHVwS2V5ID0gZHVwS2V5ICsgY29tcElkO1xyXG4gICAgaWYgKGNvbXBvbmVudER1cEtleSBpbiBpbnN0YW5jZVdhcm5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGluc3RhbmNlV2FybmVkW2NvbXBvbmVudER1cEtleV0gPSB0cnVlO1xyXG4gICAgLy8gc2FtZSB3YXJuaW5nLCBidXQgZGlmZmVyZW50IGNvbXBvbmVudC4gc2tpcCB0aGUgbG9uZyBtZXNzYWdlIGFuZCBqdXN0XHJcbiAgICAvLyBsb2cgdGhlIGtleSBhbmQgY291bnQuXHJcbiAgICBpZiAoZHVwS2V5IGluIHdhcm5Db3VudCkge1xyXG4gICAgICAgIHdhcm4oYChkZXByZWNhdGlvbiAke2tleX0pICgkeysrd2FybkNvdW50W2R1cEtleV0gKyAxfSlgKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB3YXJuQ291bnRbZHVwS2V5XSA9IDA7XHJcbiAgICBjb25zdCB7IG1lc3NhZ2UsIGxpbmsgfSA9IGRlcHJlY2F0aW9uRGF0YVtrZXldO1xyXG4gICAgd2FybihgKGRlcHJlY2F0aW9uICR7a2V5fSkgJHt0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyA/IG1lc3NhZ2UoLi4uYXJncykgOiBtZXNzYWdlfSR7bGluayA/IGBcXG4gIERldGFpbHM6ICR7bGlua31gIDogYGB9YCk7XHJcbiAgICBpZiAoIWlzQ29tcGF0RW5hYmxlZChrZXksIGluc3RhbmNlLCB0cnVlKSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYF4gVGhlIGFib3ZlIGRlcHJlY2F0aW9uJ3MgY29tcGF0IGJlaGF2aW9yIGlzIGRpc2FibGVkIGFuZCB3aWxsIGxpa2VseSBgICtcclxuICAgICAgICAgICAgYGxlYWQgdG8gcnVudGltZSBlcnJvcnMuYCk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgZ2xvYmFsQ29tcGF0Q29uZmlnID0ge1xyXG4gICAgTU9ERTogMlxyXG59O1xyXG5mdW5jdGlvbiBnZXRDb21wYXRDb25maWdGb3JLZXkoa2V5LCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgaW5zdGFuY2VDb25maWcgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLmNvbXBhdENvbmZpZztcclxuICAgIGlmIChpbnN0YW5jZUNvbmZpZyAmJiBrZXkgaW4gaW5zdGFuY2VDb25maWcpIHtcclxuICAgICAgICByZXR1cm4gaW5zdGFuY2VDb25maWdba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBnbG9iYWxDb21wYXRDb25maWdba2V5XTtcclxufVxyXG5mdW5jdGlvbiBpc0NvbXBhdEVuYWJsZWQoa2V5LCBpbnN0YW5jZSwgZW5hYmxlRm9yQnVpbHRJbiA9IGZhbHNlKSB7XHJcbiAgICAvLyBza2lwIGNvbXBhdCBmb3IgYnVpbHQtaW4gY29tcG9uZW50c1xyXG4gICAgaWYgKCFlbmFibGVGb3JCdWlsdEluICYmIGluc3RhbmNlICYmIGluc3RhbmNlLnR5cGUuX19pc0J1aWx0SW4pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYXdNb2RlID0gZ2V0Q29tcGF0Q29uZmlnRm9yS2V5KCdNT0RFJywgaW5zdGFuY2UpIHx8IDI7XHJcbiAgICBjb25zdCB2YWwgPSBnZXRDb21wYXRDb25maWdGb3JLZXkoa2V5LCBpbnN0YW5jZSk7XHJcbiAgICBjb25zdCBtb2RlID0gaXNGdW5jdGlvbiQxKHJhd01vZGUpXHJcbiAgICAgICAgPyByYXdNb2RlKGluc3RhbmNlICYmIGluc3RhbmNlLnR5cGUpXHJcbiAgICAgICAgOiByYXdNb2RlO1xyXG4gICAgaWYgKG1vZGUgPT09IDIpIHtcclxuICAgICAgICByZXR1cm4gdmFsICE9PSBmYWxzZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2YWwgPT09IHRydWUgfHwgdmFsID09PSAnc3VwcHJlc3Mtd2FybmluZyc7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZW1pdChpbnN0YW5jZSwgZXZlbnQsIC4uLnJhd0FyZ3MpIHtcclxuICAgIGNvbnN0IHByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IHsgZW1pdHNPcHRpb25zLCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICBpZiAoZW1pdHNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghKGV2ZW50IGluIGVtaXRzT3B0aW9ucykgJiZcclxuICAgICAgICAgICAgICAgICEoZmFsc2UgKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wc09wdGlvbnMgfHwgISh0b0hhbmRsZXJLZXkoZXZlbnQpIGluIHByb3BzT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgZW1pdHRlZCBldmVudCBcIiR7ZXZlbnR9XCIgYnV0IGl0IGlzIG5laXRoZXIgZGVjbGFyZWQgaW4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGB0aGUgZW1pdHMgb3B0aW9uIG5vciBhcyBhbiBcIiR7dG9IYW5kbGVyS2V5KGV2ZW50KX1cIiBwcm9wLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZW1pdHNPcHRpb25zW2V2ZW50XTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uJDEodmFsaWRhdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0b3IoLi4ucmF3QXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgZXZlbnQgYXJndW1lbnRzOiBldmVudCB2YWxpZGF0aW9uIGZhaWxlZCBmb3IgZXZlbnQgXCIke2V2ZW50fVwiLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBhcmdzID0gcmF3QXJncztcclxuICAgIGNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IGV2ZW50LnN0YXJ0c1dpdGgoJ3VwZGF0ZTonKTtcclxuICAgIC8vIGZvciB2LW1vZGVsIHVwZGF0ZTp4eHggZXZlbnRzLCBhcHBseSBtb2RpZmllcnMgb24gYXJnc1xyXG4gICAgY29uc3QgbW9kZWxBcmcgPSBpc01vZGVsTGlzdGVuZXIgJiYgZXZlbnQuc2xpY2UoNyk7XHJcbiAgICBpZiAobW9kZWxBcmcgJiYgbW9kZWxBcmcgaW4gcHJvcHMpIHtcclxuICAgICAgICBjb25zdCBtb2RpZmllcnNLZXkgPSBgJHttb2RlbEFyZyA9PT0gJ21vZGVsVmFsdWUnID8gJ21vZGVsJyA6IG1vZGVsQXJnfU1vZGlmaWVyc2A7XHJcbiAgICAgICAgY29uc3QgeyBudW1iZXIsIHRyaW0gfSA9IHByb3BzW21vZGlmaWVyc0tleV0gfHwgRU1QVFlfT0JKO1xyXG4gICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcChhID0+IGEudHJpbSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcCh0b051bWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEVtaXQoaW5zdGFuY2UsIGV2ZW50LCBhcmdzKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiBwcm9wc1t0b0hhbmRsZXJLZXkobG93ZXJDYXNlRXZlbnQpXSkge1xyXG4gICAgICAgICAgICB3YXJuKGBFdmVudCBcIiR7bG93ZXJDYXNlRXZlbnR9XCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgYCArXHJcbiAgICAgICAgICAgICAgICBgJHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICBgTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgYCArXHJcbiAgICAgICAgICAgICAgICBgdi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIGAgK1xyXG4gICAgICAgICAgICAgICAgYFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoZXZlbnQpfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBoYW5kbGVyTmFtZTtcclxuICAgIGxldCBoYW5kbGVyID0gcHJvcHNbKGhhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGV2ZW50KSldIHx8XHJcbiAgICAgICAgLy8gYWxzbyB0cnkgY2FtZWxDYXNlIGV2ZW50IGhhbmRsZXIgKCMyMjQ5KVxyXG4gICAgICAgIHByb3BzWyhoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpKV07XHJcbiAgICAvLyBmb3Igdi1tb2RlbCB1cGRhdGU6eHh4IGV2ZW50cywgYWxzbyB0cmlnZ2VyIGtlYmFiLWNhc2UgZXF1aXZhbGVudFxyXG4gICAgLy8gZm9yIHByb3BzIHBhc3NlZCB2aWEga2ViYWItY2FzZVxyXG4gICAgaWYgKCFoYW5kbGVyICYmIGlzTW9kZWxMaXN0ZW5lcikge1xyXG4gICAgICAgIGhhbmRsZXIgPSBwcm9wc1soaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoaHlwaGVuYXRlKGV2ZW50KSkpXTtcclxuICAgIH1cclxuICAgIGlmIChoYW5kbGVyKSB7XHJcbiAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaGFuZGxlciwgaW5zdGFuY2UsIDYgLyogQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVIgKi8sIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb25jZUhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSArIGBPbmNlYF07XHJcbiAgICBpZiAob25jZUhhbmRsZXIpIHtcclxuICAgICAgICBpZiAoIWluc3RhbmNlLmVtaXR0ZWQpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZW1pdHRlZCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdID0gdHJ1ZTtcclxuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhvbmNlSGFuZGxlciwgaW5zdGFuY2UsIDYgLyogQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVIgKi8sIGFyZ3MpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gYXBwQ29udGV4dC5lbWl0c0NhY2hlO1xyXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xyXG4gICAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJhdyA9IGNvbXAuZW1pdHM7XHJcbiAgICBsZXQgbm9ybWFsaXplZCA9IHt9O1xyXG4gICAgLy8gYXBwbHkgbWl4aW4vZXh0ZW5kcyBwcm9wc1xyXG4gICAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcclxuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uJDEoY29tcCkpIHtcclxuICAgICAgICBjb25zdCBleHRlbmRFbWl0cyA9IChyYXcpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEZyb21FeHRlbmQgPSBub3JtYWxpemVFbWl0c09wdGlvbnMocmF3LCBhcHBDb250ZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBub3JtYWxpemVkRnJvbUV4dGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLmV4dGVuZHMpIHtcclxuICAgICAgICAgICAgZXh0ZW5kRW1pdHMoY29tcC5leHRlbmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAubWl4aW5zKSB7XHJcbiAgICAgICAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XHJcbiAgICAgICAgY2FjaGUuc2V0KGNvbXAsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgIHJhdy5mb3JFYWNoKGtleSA9PiAobm9ybWFsaXplZFtrZXldID0gbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHJhdyk7XHJcbiAgICB9XHJcbiAgICBjYWNoZS5zZXQoY29tcCwgbm9ybWFsaXplZCk7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxufVxyXG4vLyBDaGVjayBpZiBhbiBpbmNvbWluZyBwcm9wIGtleSBpcyBhIGRlY2xhcmVkIGVtaXQgZXZlbnQgbGlzdGVuZXIuXHJcbi8vIGUuZy4gV2l0aCBgZW1pdHM6IHsgY2xpY2s6IG51bGwgfWAsIHByb3BzIG5hbWVkIGBvbkNsaWNrYCBhbmQgYG9uY2xpY2tgIGFyZVxyXG4vLyBib3RoIGNvbnNpZGVyZWQgbWF0Y2hlZCBsaXN0ZW5lcnMuXHJcbmZ1bmN0aW9uIGlzRW1pdExpc3RlbmVyKG9wdGlvbnMsIGtleSkge1xyXG4gICAgaWYgKCFvcHRpb25zIHx8ICFpc09uKGtleSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBrZXkgPSBrZXkuc2xpY2UoMikucmVwbGFjZSgvT25jZSQvLCAnJyk7XHJcbiAgICByZXR1cm4gKGhhc093bihvcHRpb25zLCBrZXlbMF0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgxKSkgfHxcclxuICAgICAgICBoYXNPd24ob3B0aW9ucywgaHlwaGVuYXRlKGtleSkpIHx8XHJcbiAgICAgICAgaGFzT3duKG9wdGlvbnMsIGtleSkpO1xyXG59XG5cbi8qKlxyXG4gKiBtYXJrIHRoZSBjdXJyZW50IHJlbmRlcmluZyBpbnN0YW5jZSBmb3IgYXNzZXQgcmVzb2x1dGlvbiAoZS5nLlxyXG4gKiByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlKSBkdXJpbmcgcmVuZGVyXHJcbiAqL1xyXG5sZXQgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcclxubGV0IGN1cnJlbnRTY29wZUlkID0gbnVsbDtcclxuLyoqXHJcbiAqIE5vdGU6IHJlbmRlcmluZyBjYWxscyBtYXliZSBuZXN0ZWQuIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSBwYXJlbnQgcmVuZGVyaW5nXHJcbiAqIGluc3RhbmNlIGlmIHByZXNlbnQsIHdoaWNoIHNob3VsZCBiZSByZXN0b3JlZCBhZnRlciB0aGUgcmVuZGVyIGlzIGRvbmU6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IHByZXYgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaSlcclxuICogLy8gLi4ucmVuZGVyXHJcbiAqIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KVxyXG4gKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgcHJldiA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgY3VycmVudFNjb3BlSWQgPSAoaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZS5fX3Njb3BlSWQpIHx8IG51bGw7XHJcbiAgICByZXR1cm4gcHJldjtcclxufVxyXG4vKipcclxuICogU2V0IHNjb3BlIGlkIHdoZW4gY3JlYXRpbmcgaG9pc3RlZCB2bm9kZXMuXHJcbiAqIEBwcml2YXRlIGNvbXBpbGVyIGhlbHBlclxyXG4gKi9cclxuZnVuY3Rpb24gcHVzaFNjb3BlSWQoaWQpIHtcclxuICAgIGN1cnJlbnRTY29wZUlkID0gaWQ7XHJcbn1cclxuLyoqXHJcbiAqIFRlY2huaWNhbGx5IHdlIG5vIGxvbmdlciBuZWVkIHRoaXMgYWZ0ZXIgMy4wLjggYnV0IHdlIG5lZWQgdG8ga2VlcCB0aGUgc2FtZVxyXG4gKiBBUEkgZm9yIGJhY2t3YXJkcyBjb21wYXQgdy8gY29kZSBnZW5lcmF0ZWQgYnkgY29tcGlsZXJzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcG9wU2NvcGVJZCgpIHtcclxuICAgIGN1cnJlbnRTY29wZUlkID0gbnVsbDtcclxufVxyXG4vKipcclxuICogT25seSBmb3IgYmFja3dhcmRzIGNvbXBhdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3Qgd2l0aFNjb3BlSWQgPSAoX2lkKSA9PiB3aXRoQ3R4O1xyXG4vKipcclxuICogV3JhcCBhIHNsb3QgZnVuY3Rpb24gdG8gbWVtb2l6ZSBjdXJyZW50IHJlbmRlcmluZyBpbnN0YW5jZVxyXG4gKiBAcHJpdmF0ZSBjb21waWxlciBoZWxwZXJcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhDdHgoZm4sIGN0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgaXNOb25TY29wZWRTbG90IC8vIGZhbHNlIG9ubHlcclxuKSB7XHJcbiAgICBpZiAoIWN0eClcclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICAvLyBhbHJlYWR5IG5vcm1hbGl6ZWRcclxuICAgIGlmIChmbi5fbikge1xyXG4gICAgICAgIHJldHVybiBmbjtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlbmRlckZuV2l0aENvbnRleHQgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIC8vIElmIGEgdXNlciBjYWxscyBhIGNvbXBpbGVkIHNsb3QgaW5zaWRlIGEgdGVtcGxhdGUgZXhwcmVzc2lvbiAoIzE3NDUpLCBpdFxyXG4gICAgICAgIC8vIGNhbiBtZXNzIHVwIGJsb2NrIHRyYWNraW5nLCBzbyBieSBkZWZhdWx0IHdlIGRpc2FibGUgYmxvY2sgdHJhY2tpbmcgYW5kXHJcbiAgICAgICAgLy8gZm9yY2UgYmFpbCBvdXQgd2hlbiBpbnZva2luZyBhIGNvbXBpbGVkIHNsb3QgKGluZGljYXRlZCBieSB0aGUgLl9kIGZsYWcpLlxyXG4gICAgICAgIC8vIFRoaXMgaXNuJ3QgbmVjZXNzYXJ5IGlmIHJlbmRlcmluZyBhIGNvbXBpbGVkIGA8c2xvdD5gLCBzbyB3ZSBmbGlwIHRoZVxyXG4gICAgICAgIC8vIC5fZCBmbGFnIG9mZiB3aGVuIGludm9raW5nIHRoZSB3cmFwcGVkIGZuIGluc2lkZSBgcmVuZGVyU2xvdGAuXHJcbiAgICAgICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcclxuICAgICAgICAgICAgc2V0QmxvY2tUcmFja2luZygtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByZXZJbnN0YW5jZSA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShjdHgpO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGZuKC4uLmFyZ3MpO1xyXG4gICAgICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2SW5zdGFuY2UpO1xyXG4gICAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XHJcbiAgICAgICAgICAgIHNldEJsb2NrVHJhY2tpbmcoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChjdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIC8vIG1hcmsgbm9ybWFsaXplZCB0byBhdm9pZCBkdXBsaWNhdGVkIHdyYXBwaW5nXHJcbiAgICByZW5kZXJGbldpdGhDb250ZXh0Ll9uID0gdHJ1ZTtcclxuICAgIC8vIG1hcmsgdGhpcyBhcyBjb21waWxlZCBieSBkZWZhdWx0XHJcbiAgICAvLyB0aGlzIGlzIHVzZWQgaW4gdm5vZGUudHMgLT4gbm9ybWFsaXplQ2hpbGRyZW4oKSB0byBzZXQgdGhlIHNsb3RcclxuICAgIC8vIHJlbmRlcmluZyBmbGFnLlxyXG4gICAgcmVuZGVyRm5XaXRoQ29udGV4dC5fYyA9IHRydWU7XHJcbiAgICAvLyBkaXNhYmxlIGJsb2NrIHRyYWNraW5nIGJ5IGRlZmF1bHRcclxuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX2QgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlbmRlckZuV2l0aENvbnRleHQ7XHJcbn1cblxuLyoqXHJcbiAqIGRldiBvbmx5IGZsYWcgdG8gdHJhY2sgd2hldGhlciAkYXR0cnMgd2FzIHVzZWQgZHVyaW5nIHJlbmRlci5cclxuICogSWYgJGF0dHJzIHdhcyB1c2VkIGR1cmluZyByZW5kZXIgdGhlbiB0aGUgd2FybmluZyBmb3IgZmFpbGVkIGF0dHJzXHJcbiAqIGZhbGx0aHJvdWdoIGNhbiBiZSBzdXBwcmVzc2VkLlxyXG4gKi9cclxubGV0IGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcclxuZnVuY3Rpb24gbWFya0F0dHJzQWNjZXNzZWQoKSB7XHJcbiAgICBhY2Nlc3NlZEF0dHJzID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCB7IHR5cGU6IENvbXBvbmVudCwgdm5vZGUsIHByb3h5LCB3aXRoUHJveHksIHByb3BzLCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdLCBzbG90cywgYXR0cnMsIGVtaXQsIHJlbmRlciwgcmVuZGVyQ2FjaGUsIGRhdGEsIHNldHVwU3RhdGUsIGN0eCwgaW5oZXJpdEF0dHJzIH0gPSBpbnN0YW5jZTtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICBjb25zdCBwcmV2ID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGxldCBmYWxsdGhyb3VnaEF0dHJzO1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAvLyB3aXRoUHJveHkgaXMgYSBwcm94eSB3aXRoIGEgZGlmZmVyZW50IGBoYXNgIHRyYXAgb25seSBmb3JcclxuICAgICAgICAgICAgLy8gcnVudGltZS1jb21waWxlZCByZW5kZXIgZnVuY3Rpb25zIHVzaW5nIGB3aXRoYCBibG9jay5cclxuICAgICAgICAgICAgY29uc3QgcHJveHlUb1VzZSA9IHdpdGhQcm94eSB8fCBwcm94eTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUocmVuZGVyLmNhbGwocHJveHlUb1VzZSwgcHJveHlUb1VzZSwgcmVuZGVyQ2FjaGUsIHByb3BzLCBzZXR1cFN0YXRlLCBkYXRhLCBjdHgpKTtcclxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGF0dHJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbFxyXG4gICAgICAgICAgICBjb25zdCByZW5kZXIgPSBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgIC8vIGluIGRldiwgbWFyayBhdHRycyBhY2Nlc3NlZCBpZiBvcHRpb25hbCBwcm9wcyAoYXR0cnMgPT09IHByb3BzKVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGF0dHJzID09PSBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShyZW5kZXIubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgPyByZW5kZXIocHJvcHMsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgYXR0cnMoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA6IHsgYXR0cnMsIHNsb3RzLCBlbWl0IH0pXHJcbiAgICAgICAgICAgICAgICA6IHJlbmRlcihwcm9wcywgbnVsbCAvKiB3ZSBrbm93IGl0IGRvZXNuJ3QgbmVlZCBpdCAqLykpO1xyXG4gICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gQ29tcG9uZW50LnByb3BzXHJcbiAgICAgICAgICAgICAgICA/IGF0dHJzXHJcbiAgICAgICAgICAgICAgICA6IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaChhdHRycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGF0dHIgbWVyZ2luZ1xyXG4gICAgICAgIC8vIGluIGRldiBtb2RlLCBjb21tZW50cyBhcmUgcHJlc2VydmVkLCBhbmQgaXQncyBwb3NzaWJsZSBmb3IgYSB0ZW1wbGF0ZVxyXG4gICAgICAgIC8vIHRvIGhhdmUgY29tbWVudHMgYWxvbmcgc2lkZSB0aGUgcm9vdCBlbGVtZW50IHdoaWNoIG1ha2VzIGl0IGEgZnJhZ21lbnRcclxuICAgICAgICBsZXQgcm9vdCA9IHJlc3VsdDtcclxuICAgICAgICBsZXQgc2V0Um9vdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHJlc3VsdC5wYXRjaEZsYWcgPiAwICYmXHJcbiAgICAgICAgICAgIHJlc3VsdC5wYXRjaEZsYWcgJiAyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgW3Jvb3QsIHNldFJvb3RdID0gZ2V0Q2hpbGRSb290KHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmYWxsdGhyb3VnaEF0dHJzICYmIGluaGVyaXRBdHRycyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZhbGx0aHJvdWdoQXR0cnMpO1xyXG4gICAgICAgICAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gcm9vdDtcclxuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHNPcHRpb25zICYmIGtleXMuc29tZShpc01vZGVsTGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGEgdi1tb2RlbCBsaXN0ZW5lciAob25VcGRhdGU6eHh4KSBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY2xhcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3AsIGl0IGluZGljYXRlcyB0aGlzIGNvbXBvbmVudCBleHBlY3RzIHRvIGhhbmRsZSB2LW1vZGVsIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgbm90IGZhbGx0aHJvdWdoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWxhdGVkOiAjMTU0MywgIzE2NDMsICMxOTg5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBmaWx0ZXJNb2RlbExpc3RlbmVycyhmYWxsdGhyb3VnaEF0dHJzLCBwcm9wc09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByb290ID0gY2xvbmVWTm9kZShyb290LCBmYWxsdGhyb3VnaEF0dHJzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhYWNjZXNzZWRBdHRycyAmJiByb290LnR5cGUgIT09IENvbW1lbnQkMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbEF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50QXR0cnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhbGxBdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYWxsQXR0cnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB2LW1vZGVsIGhhbmRsZXJzIHdoZW4gdGhleSBmYWlsIHRvIGZhbGx0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGBvbmAsIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgdG8gcmVmbGVjdCBldmVudCBjYXNpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2N1cmF0ZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRBdHRycy5wdXNoKGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cnMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYUF0dHJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBFeHRyYW5lb3VzIG5vbi1wcm9wcyBhdHRyaWJ1dGVzIChgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2V4dHJhQXR0cnMuam9pbignLCAnKX0pIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRXh0cmFuZW91cyBub24tZW1pdHMgZXZlbnQgbGlzdGVuZXJzIChgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2V2ZW50QXR0cnMuam9pbignLCAnKX0pIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB0aGUgbGlzdGVuZXIgaXMgaW50ZW5kZWQgdG8gYmUgYSBjb21wb25lbnQgY3VzdG9tIGV2ZW50IGxpc3RlbmVyIG9ubHksIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGRlY2xhcmUgaXQgdXNpbmcgdGhlIFwiZW1pdHNcIiBvcHRpb24uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmYWxzZSAmJlxyXG4gICAgICAgICAgICBpc0NvbXBhdEVuYWJsZWQoXCJJTlNUQU5DRV9BVFRSU19DTEFTU19TVFlMRVwiIC8qIElOU1RBTkNFX0FUVFJTX0NMQVNTX1NUWUxFICovLCBpbnN0YW5jZSkgJiZcclxuICAgICAgICAgICAgdm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8gJiZcclxuICAgICAgICAgICAgKHJvb3Quc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICByb290LnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSkgO1xyXG4gICAgICAgIC8vIGluaGVyaXQgZGlyZWN0aXZlc1xyXG4gICAgICAgIGlmICh2bm9kZS5kaXJzKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFJ1bnRpbWUgZGlyZWN0aXZlIHVzZWQgb24gY29tcG9uZW50IHdpdGggbm9uLWVsZW1lbnQgcm9vdCBub2RlLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm9vdC5kaXJzID0gcm9vdC5kaXJzID8gcm9vdC5kaXJzLmNvbmNhdCh2bm9kZS5kaXJzKSA6IHZub2RlLmRpcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluaGVyaXQgdHJhbnNpdGlvbiBkYXRhXHJcbiAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGluc2lkZSA8VHJhbnNpdGlvbj4gcmVuZGVycyBub24tZWxlbWVudCByb290IG5vZGUgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvb3QudHJhbnNpdGlvbiA9IHZub2RlLnRyYW5zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2V0Um9vdCkge1xyXG4gICAgICAgICAgICBzZXRSb290KHJvb3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcm9vdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgYmxvY2tTdGFjay5sZW5ndGggPSAwO1xyXG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEgLyogUkVOREVSX0ZVTkNUSU9OICovKTtcclxuICAgICAgICByZXN1bHQgPSBjcmVhdGVWTm9kZShDb21tZW50JDEpO1xyXG4gICAgfVxyXG4gICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXYpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICogSW4gZGV2IG1vZGUsIHRlbXBsYXRlIHJvb3QgbGV2ZWwgY29tbWVudHMgYXJlIHJlbmRlcmVkLCB3aGljaCB0dXJucyB0aGVcclxuICogdGVtcGxhdGUgaW50byBhIGZyYWdtZW50IHJvb3QsIGJ1dCB3ZSBuZWVkIHRvIGxvY2F0ZSB0aGUgc2luZ2xlIGVsZW1lbnRcclxuICogcm9vdCBmb3IgYXR0cnMgYW5kIHNjb3BlIGlkIHByb2Nlc3NpbmcuXHJcbiAqL1xyXG5jb25zdCBnZXRDaGlsZFJvb3QgPSAodm5vZGUpID0+IHtcclxuICAgIGNvbnN0IHJhd0NoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICBjb25zdCBkeW5hbWljQ2hpbGRyZW4gPSB2bm9kZS5keW5hbWljQ2hpbGRyZW47XHJcbiAgICBjb25zdCBjaGlsZFJvb3QgPSBmaWx0ZXJTaW5nbGVSb290KHJhd0NoaWxkcmVuKTtcclxuICAgIGlmICghY2hpbGRSb290KSB7XHJcbiAgICAgICAgcmV0dXJuIFt2bm9kZSwgdW5kZWZpbmVkXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGluZGV4ID0gcmF3Q2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpO1xyXG4gICAgY29uc3QgZHluYW1pY0luZGV4ID0gZHluYW1pY0NoaWxkcmVuID8gZHluYW1pY0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KSA6IC0xO1xyXG4gICAgY29uc3Qgc2V0Um9vdCA9ICh1cGRhdGVkUm9vdCkgPT4ge1xyXG4gICAgICAgIHJhd0NoaWxkcmVuW2luZGV4XSA9IHVwZGF0ZWRSb290O1xyXG4gICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW5bZHluYW1pY0luZGV4XSA9IHVwZGF0ZWRSb290O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHVwZGF0ZWRSb290LnBhdGNoRmxhZyA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IFsuLi5keW5hbWljQ2hpbGRyZW4sIHVwZGF0ZWRSb290XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gW25vcm1hbGl6ZVZOb2RlKGNoaWxkUm9vdCksIHNldFJvb3RdO1xyXG59O1xyXG5mdW5jdGlvbiBmaWx0ZXJTaW5nbGVSb290KGNoaWxkcmVuKSB7XHJcbiAgICBsZXQgc2luZ2xlUm9vdDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xyXG4gICAgICAgICAgICAvLyBpZ25vcmUgdXNlciBjb21tZW50XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSBDb21tZW50JDEgfHwgY2hpbGQuY2hpbGRyZW4gPT09ICd2LWlmJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZVJvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgbW9yZSB0aGFuIDEgbm9uLWNvbW1lbnQgY2hpbGQsIHJldHVybiBub3dcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVSb290ID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2luZ2xlUm9vdDtcclxufVxyXG5jb25zdCBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2ggPSAoYXR0cnMpID0+IHtcclxuICAgIGxldCByZXM7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnIHx8IGlzT24oa2V5KSkge1xyXG4gICAgICAgICAgICAocmVzIHx8IChyZXMgPSB7fSkpW2tleV0gPSBhdHRyc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcbmNvbnN0IGZpbHRlck1vZGVsTGlzdGVuZXJzID0gKGF0dHJzLCBwcm9wcykgPT4ge1xyXG4gICAgY29uc3QgcmVzID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkgfHwgIShrZXkuc2xpY2UoOSkgaW4gcHJvcHMpKSB7XHJcbiAgICAgICAgICAgIHJlc1trZXldID0gYXR0cnNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5jb25zdCBpc0VsZW1lbnRSb290ID0gKHZub2RlKSA9PiB7XHJcbiAgICByZXR1cm4gKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovIHx8XHJcbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgdm5vZGUudHlwZSA9PT0gQ29tbWVudCQxIC8vIHBvdGVudGlhbCB2LWlmIGJyYW5jaCBzd2l0Y2hcclxuICAgICk7XHJcbn07XHJcbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZUNvbXBvbmVudChwcmV2Vk5vZGUsIG5leHRWTm9kZSwgb3B0aW1pemVkKSB7XHJcbiAgICBjb25zdCB7IHByb3BzOiBwcmV2UHJvcHMsIGNoaWxkcmVuOiBwcmV2Q2hpbGRyZW4sIGNvbXBvbmVudCB9ID0gcHJldlZOb2RlO1xyXG4gICAgY29uc3QgeyBwcm9wczogbmV4dFByb3BzLCBjaGlsZHJlbjogbmV4dENoaWxkcmVuLCBwYXRjaEZsYWcgfSA9IG5leHRWTm9kZTtcclxuICAgIGNvbnN0IGVtaXRzID0gY29tcG9uZW50LmVtaXRzT3B0aW9ucztcclxuICAgIC8vIFBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24gd2FzIGhvdC11cGRhdGVkLiBTaW5jZSB0aGlzIG1heSBoYXZlXHJcbiAgICAvLyBjYXVzZWQgdGhlIGNoaWxkIGNvbXBvbmVudCdzIHNsb3RzIGNvbnRlbnQgdG8gaGF2ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvXHJcbiAgICAvLyBmb3JjZSB0aGUgY2hpbGQgdG8gdXBkYXRlIGFzIHdlbGwuXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBmb3JjZSBjaGlsZCB1cGRhdGUgZm9yIHJ1bnRpbWUgZGlyZWN0aXZlIG9yIHRyYW5zaXRpb24gb24gY29tcG9uZW50IHZub2RlLlxyXG4gICAgaWYgKG5leHRWTm9kZS5kaXJzIHx8IG5leHRWTm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW1pemVkICYmIHBhdGNoRmxhZyA+PSAwKSB7XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLykge1xyXG4gICAgICAgICAgICAvLyBzbG90IGNvbnRlbnQgdGhhdCByZWZlcmVuY2VzIHZhbHVlcyB0aGF0IG1pZ2h0IGhhdmUgY2hhbmdlZCxcclxuICAgICAgICAgICAgLy8gZS5nLiBpbiBhIHYtZm9yXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykge1xyXG4gICAgICAgICAgICBpZiAoIXByZXZQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHRoaXMgZmxhZyBpbmRpY2F0ZXMgcHJvcHMgYXJlIGFsd2F5cyBub24tbnVsbFxyXG4gICAgICAgICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGNoRmxhZyAmIDggLyogUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljUHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGR5bmFtaWNQcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiZcclxuICAgICAgICAgICAgICAgICAgICAhaXNFbWl0TGlzdGVuZXIoZW1pdHMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHRoaXMgcGF0aCBpcyBvbmx5IHRha2VuIGJ5IG1hbnVhbGx5IHdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9uc1xyXG4gICAgICAgIC8vIHNvIHByZXNlbmNlIG9mIGFueSBjaGlsZHJlbiBsZWFkcyB0byBhIGZvcmNlZCB1cGRhdGVcclxuICAgICAgICBpZiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoIW5leHRDaGlsZHJlbiB8fCAhbmV4dENoaWxkcmVuLiRzdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2UHJvcHMgPT09IG5leHRQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcHJldlByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFuZXh0UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzT3B0aW9ucykge1xyXG4gICAgY29uc3QgbmV4dEtleXMgPSBPYmplY3Qua2V5cyhuZXh0UHJvcHMpO1xyXG4gICAgaWYgKG5leHRLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJldlByb3BzKS5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXh0S2V5c1tpXTtcclxuICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmXHJcbiAgICAgICAgICAgICFpc0VtaXRMaXN0ZW5lcihlbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUhPQ0hvc3RFbCh7IHZub2RlLCBwYXJlbnQgfSwgZWwgLy8gSG9zdE5vZGVcclxuKSB7XHJcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xyXG4gICAgICAgICh2bm9kZSA9IHBhcmVudC52bm9kZSkuZWwgPSBlbDtcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IGlzU3VzcGVuc2UgPSAodHlwZSkgPT4gdHlwZS5fX2lzU3VzcGVuc2U7XHJcbi8vIFN1c3BlbnNlIGV4cG9zZXMgYSBjb21wb25lbnQtbGlrZSBBUEksIGFuZCBpcyB0cmVhdGVkIGxpa2UgYSBjb21wb25lbnRcclxuLy8gaW4gdGhlIGNvbXBpbGVyLCBidXQgaW50ZXJuYWxseSBpdCdzIGEgc3BlY2lhbCBidWlsdC1pbiB0eXBlIHRoYXQgaG9va3NcclxuLy8gZGlyZWN0bHkgaW50byB0aGUgcmVuZGVyZXIuXHJcbmNvbnN0IFN1c3BlbnNlSW1wbCA9IHtcclxuICAgIG5hbWU6ICdTdXNwZW5zZScsXHJcbiAgICAvLyBJbiBvcmRlciB0byBtYWtlIFN1c3BlbnNlIHRyZWUtc2hha2FibGUsIHdlIG5lZWQgdG8gYXZvaWQgaW1wb3J0aW5nIGl0XHJcbiAgICAvLyBkaXJlY3RseSBpbiB0aGUgcmVuZGVyZXIuIFRoZSByZW5kZXJlciBjaGVja3MgZm9yIHRoZSBfX2lzU3VzcGVuc2UgZmxhZ1xyXG4gICAgLy8gb24gYSB2bm9kZSdzIHR5cGUgYW5kIGNhbGxzIHRoZSBgcHJvY2Vzc2AgbWV0aG9kLCBwYXNzaW5nIGluIHJlbmRlcmVyXHJcbiAgICAvLyBpbnRlcm5hbHMuXHJcbiAgICBfX2lzU3VzcGVuc2U6IHRydWUsXHJcbiAgICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgXHJcbiAgICAvLyBwbGF0Zm9ybS1zcGVjaWZpYyBpbXBsIHBhc3NlZCBmcm9tIHJlbmRlcmVyXHJcbiAgICByZW5kZXJlckludGVybmFscykge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1vdW50U3VzcGVuc2UobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgaHlkcmF0ZTogaHlkcmF0ZVN1c3BlbnNlLFxyXG4gICAgY3JlYXRlOiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5LFxyXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuXHJcbn07XHJcbi8vIEZvcmNlLWNhc3RlZCBwdWJsaWMgdHlwaW5nIGZvciBoIGFuZCBUU1ggcHJvcHMgaW5mZXJlbmNlXHJcbmNvbnN0IFN1c3BlbnNlID0gKFN1c3BlbnNlSW1wbFxyXG4gICAgKTtcclxuZnVuY3Rpb24gdHJpZ2dlckV2ZW50KHZub2RlLCBuYW1lKSB7XHJcbiAgICBjb25zdCBldmVudExpc3RlbmVyID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHNbbmFtZV07XHJcbiAgICBpZiAoaXNGdW5jdGlvbiQxKGV2ZW50TGlzdGVuZXIpKSB7XHJcbiAgICAgICAgZXZlbnRMaXN0ZW5lcigpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2Uodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XHJcbiAgICBjb25zdCB7IHA6IHBhdGNoLCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgICBjb25zdCBoaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0gKHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykpO1xyXG4gICAgLy8gc3RhcnQgbW91bnRpbmcgdGhlIGNvbnRlbnQgc3VidHJlZSBpbiBhbiBvZmYtZG9tIGNvbnRhaW5lclxyXG4gICAgcGF0Y2gobnVsbCwgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQpLCBoaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgLy8gbm93IGNoZWNrIGlmIHdlIGhhdmUgZW5jb3VudGVyZWQgYW55IGFzeW5jIGRlcHNcclxuICAgIGlmIChzdXNwZW5zZS5kZXBzID4gMCkge1xyXG4gICAgICAgIC8vIGhhcyBhc3luY1xyXG4gICAgICAgIC8vIGludm9rZSBAZmFsbGJhY2sgZXZlbnRcclxuICAgICAgICB0cmlnZ2VyRXZlbnQodm5vZGUsICdvblBlbmRpbmcnKTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQodm5vZGUsICdvbkZhbGxiYWNrJyk7XHJcbiAgICAgICAgLy8gbW91bnQgdGhlIGZhbGxiYWNrIHRyZWVcclxuICAgICAgICBwYXRjaChudWxsLCB2bm9kZS5zc0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgdm5vZGUuc3NGYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBTdXNwZW5zZSBoYXMgbm8gYXN5bmMgZGVwcy4gSnVzdCByZXNvbHZlLlxyXG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSAobjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZSk7XHJcbiAgICBzdXNwZW5zZS52bm9kZSA9IG4yO1xyXG4gICAgbjIuZWwgPSBuMS5lbDtcclxuICAgIGNvbnN0IG5ld0JyYW5jaCA9IG4yLnNzQ29udGVudDtcclxuICAgIGNvbnN0IG5ld0ZhbGxiYWNrID0gbjIuc3NGYWxsYmFjaztcclxuICAgIGNvbnN0IHsgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBpc0luRmFsbGJhY2ssIGlzSHlkcmF0aW5nIH0gPSBzdXNwZW5zZTtcclxuICAgIGlmIChwZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcclxuICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgcGVuZGluZ0JyYW5jaCkpIHtcclxuICAgICAgICAgICAgLy8gc2FtZSByb290IHR5cGUgYnV0IGNvbnRlbnQgbWF5IGhhdmUgY2hhbmdlZC5cclxuICAgICAgICAgICAgcGF0Y2gocGVuZGluZ0JyYW5jaCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0luRmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3RmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRvZ2dsZWQgYmVmb3JlIHBlbmRpbmcgdHJlZSBpcyByZXNvbHZlZFxyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQrKztcclxuICAgICAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0b2dnbGVkIGJlZm9yZSBoeWRyYXRpb24gaXMgZmluaXNoZWQsIHRoZSBjdXJyZW50IERPTSB0cmVlIGlzXHJcbiAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgdmFsaWQuIHNldCBpdCBhcyB0aGUgYWN0aXZlIGJyYW5jaCBzbyBpdCB3aWxsIGJlIHVubW91bnRlZFxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiByZXNvbHZlZFxyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IHBlbmRpbmdCcmFuY2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBwZW5kaW5nIElELiB0aGlzIGlzIHVzZWQgdG8gaW52YWxpZGF0ZSBhc3luYyBjYWxsYmFja3NcclxuICAgICAgICAgICAgLy8gcmVzZXQgc3VzcGVuc2Ugc3RhdGVcclxuICAgICAgICAgICAgc3VzcGVuc2UuZGVwcyA9IDA7XHJcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgZWZmZWN0cyBmcm9tIHBlbmRpbmcgYnJhbmNoXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgLy8gZGlzY2FyZCBwcmV2aW91cyBjb250YWluZXJcclxuICAgICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGlmIChpc0luRmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgaW4gZmFsbGJhY2sgc3RhdGVcclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3RmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdG9nZ2xlZCBcImJhY2tcIiB0byBjdXJyZW50IGFjdGl2ZSBicmFuY2hcclxuICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3QnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHJlc29sdmVcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2hlZCB0byBhIDNyZCBicmFuY2hcclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xyXG4gICAgICAgICAgICAvLyByb290IGRpZCBub3QgY2hhbmdlLCBqdXN0IG5vcm1hbCBwYXRjaFxyXG4gICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3QnJhbmNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3Qgbm9kZSB0b2dnbGVkXHJcbiAgICAgICAgICAgIC8vIGludm9rZSBAcGVuZGluZyBldmVudFxyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQobjIsICdvblBlbmRpbmcnKTtcclxuICAgICAgICAgICAgLy8gbW91bnQgcGVuZGluZyBicmFuY2ggaW4gb2ZmLWRvbSBjb250YWluZXJcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XHJcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbmNvbWluZyBicmFuY2ggaGFzIG5vIGFzeW5jIGRlcHMsIHJlc29sdmUgbm93LlxyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB0aW1lb3V0LCBwZW5kaW5nSWQgfSA9IHN1c3BlbnNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nSWQgPT09IHBlbmRpbmdJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lb3V0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmxldCBoYXNXYXJuZWQgPSBmYWxzZTtcclxuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50LCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaGlkZGVuQ29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGlzSHlkcmF0aW5nID0gZmFsc2UpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZmFsc2UgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBgY29uc29sZS5pbmZvYCBjYW5ub3QgYmUgbnVsbCBlcnJvclxyXG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKGA8U3VzcGVuc2U+IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGFuZCBpdHMgQVBJIHdpbGwgbGlrZWx5IGNoYW5nZS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgcDogcGF0Y2gsIG06IG1vdmUsIHVtOiB1bm1vdW50LCBuOiBuZXh0LCBvOiB7IHBhcmVudE5vZGUsIHJlbW92ZSB9IH0gPSByZW5kZXJlckludGVybmFscztcclxuICAgIGNvbnN0IHRpbWVvdXQgPSB0b051bWJlcih2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50aW1lb3V0KTtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0ge1xyXG4gICAgICAgIHZub2RlLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgaXNTVkcsXHJcbiAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgIGhpZGRlbkNvbnRhaW5lcixcclxuICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgZGVwczogMCxcclxuICAgICAgICBwZW5kaW5nSWQ6IDAsXHJcbiAgICAgICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInID8gdGltZW91dCA6IC0xLFxyXG4gICAgICAgIGFjdGl2ZUJyYW5jaDogbnVsbCxcclxuICAgICAgICBwZW5kaW5nQnJhbmNoOiBudWxsLFxyXG4gICAgICAgIGlzSW5GYWxsYmFjazogdHJ1ZSxcclxuICAgICAgICBpc0h5ZHJhdGluZyxcclxuICAgICAgICBpc1VubW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgZWZmZWN0czogW10sXHJcbiAgICAgICAgcmVzb2x2ZShyZXN1bWUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VtZSAmJiAhc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCB3aXRob3V0IGEgcGVuZGluZyBicmFuY2guYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuaXNVbm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgb24gYW4gYWxyZWFkeSB1bm1vdW50ZWQgc3VzcGVuc2UgYm91bmRhcnkuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyB2bm9kZSwgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBwZW5kaW5nSWQsIGVmZmVjdHMsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyZXN1bWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBhY3RpdmVCcmFuY2ggJiZcclxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24ubW9kZSA9PT0gJ291dC1pbic7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nSWQgPT09IHN1c3BlbnNlLnBlbmRpbmdJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBFTlRFUiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBpbml0aWFsIGFuY2hvciBvbiBtb3VudFxyXG4gICAgICAgICAgICAgICAgbGV0IHsgYW5jaG9yIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgICAgIC8vIHVubW91bnQgY3VycmVudCBhY3RpdmUgdHJlZVxyXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUJyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmYWxsYmFjayB0cmVlIHdhcyBtb3VudGVkLCBpdCBtYXkgaGF2ZSBiZWVuIG1vdmVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgcGFydCBvZiBhIHBhcmVudCBzdXNwZW5zZS4gZ2V0IHRoZSBsYXRlc3QgYW5jaG9yIGZvciBpbnNlcnRpb25cclxuICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBjb250ZW50IGZyb20gb2ZmLWRvbSBjb250YWluZXIgdG8gYWN0dWFsIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogRU5URVIgKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBudWxsO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gZmx1c2ggYnVmZmVyZWQgZWZmZWN0c1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhIHBlbmRpbmcgcGFyZW50IHN1c3BlbnNlXHJcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzdXNwZW5zZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZSwgbWVyZ2UgYnVmZmVyZWQgcG9zdCBqb2JzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50byB0aGF0IHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5lZmZlY3RzLnB1c2goLi4uZWZmZWN0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbm8gcGVuZGluZyBwYXJlbnQgc3VzcGVuc2UsIGZsdXNoIGFsbCBqb2JzXHJcbiAgICAgICAgICAgIGlmICghaGFzVW5yZXNvbHZlZEFuY2VzdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMgPSBbXTtcclxuICAgICAgICAgICAgLy8gaW52b2tlIEByZXNvbHZlIGV2ZW50XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uUmVzb2x2ZScpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmFsbGJhY2soZmFsbGJhY2tWTm9kZSkge1xyXG4gICAgICAgICAgICBpZiAoIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IHZub2RlLCBhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBpc1NWRyB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgIC8vIGludm9rZSBAZmFsbGJhY2sgZXZlbnRcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25GYWxsYmFjaycpO1xyXG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdW50RmFsbGJhY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1c3BlbnNlLmlzSW5GYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdW50IHRoZSBmYWxsYmFjayB0cmVlXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBmYWxsYmFja1ZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgZmFsbGJhY2tWTm9kZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24gJiYgZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uLm1vZGUgPT09ICdvdXQtaW4nO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9IG1vdW50RmFsbGJhY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gdW5tb3VudCBjdXJyZW50IGFjdGl2ZSBicmFuY2hcclxuICAgICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gbm8gc3VzcGVuc2Ugc28gdW5tb3VudCBob29rcyBmaXJlIG5vd1xyXG4gICAgICAgICAgICB0cnVlIC8vIHNob3VsZFJlbW92ZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIG1vdW50RmFsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbW92ZShjb250YWluZXIsIGFuY2hvciwgdHlwZSkge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiZcclxuICAgICAgICAgICAgICAgIG1vdmUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgdHlwZSk7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiYgbmV4dChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzSW5QZW5kaW5nU3VzcGVuc2UgPSAhIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2g7XHJcbiAgICAgICAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5kZXBzKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaHlkcmF0ZWRFbCA9IGluc3RhbmNlLnZub2RlLmVsO1xyXG4gICAgICAgICAgICBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgLmFzeW5jRGVwLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAwIC8qIFNFVFVQX0ZVTkNUSU9OICovKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jU2V0dXBSZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0cnkgd2hlbiB0aGUgc2V0dXAoKSBwcm9taXNlIHJlc29sdmVzLlxyXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gdW5tb3VudGVkIGJlZm9yZSByZXNvbHZlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuaXNVbm1vdW50ZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgIT09IGluc3RhbmNlLnN1c3BlbnNlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZXRyeSBmcm9tIHRoaXMgY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5hc3luY1Jlc29sdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgYXN5bmNTZXR1cFJlc3VsdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGh5ZHJhdGVkRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBtYXkgaGF2ZSBiZWVuIHJlcGxhY2VkIGlmIGFuIHVwZGF0ZSBoYXBwZW5lZCBiZWZvcmUgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXN5bmMgZGVwIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmVsID0gaHlkcmF0ZWRFbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gIWh5ZHJhdGVkRWwgJiYgaW5zdGFuY2Uuc3ViVHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCB2bm9kZSwgXHJcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiBtb3ZlZCBiZWZvcmUgcmVzb2x2ZS5cclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgaHlkcmF0aW9uLCBpbnN0YW5jZS5zdWJUcmVlIHdpbGwgYmUgdGhlIGNvbW1lbnRcclxuICAgICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyLlxyXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZShoeWRyYXRlZEVsIHx8IGluc3RhbmNlLnN1YlRyZWUuZWwpLCBcclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXHJcbiAgICAgICAgICAgICAgICBoeWRyYXRlZEVsID8gbnVsbCA6IG5leHQoaW5zdGFuY2Uuc3ViVHJlZSksIHN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShwbGFjZWhvbGRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIHZub2RlLmVsKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25seSBkZWNyZWFzZSBkZXBzIGNvdW50IGlmIHN1c3BlbnNlIGlzIG5vdCBhbHJlYWR5IHJlc29sdmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSAmJiAtLXN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gc3VzcGVuc2U7XHJcbn1cclxuZnVuY3Rpb24gaHlkcmF0ZVN1c3BlbnNlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSkge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbiAgICBjb25zdCBzdXNwZW5zZSA9ICh2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudFN1c3BlbnNlLCBwYXJlbnRDb21wb25lbnQsIG5vZGUucGFyZW50Tm9kZSwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIG51bGwsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIHRydWUgLyogaHlkcmF0aW5nICovKSk7XHJcbiAgICAvLyB0aGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNjZW5hcmlvcyBmb3Igc2VydmVyLXJlbmRlcmVkIHN1c3BlbnNlOlxyXG4gICAgLy8gLSBzdWNjZXNzOiBzc3IgY29udGVudCBzaG91bGQgYmUgZnVsbHkgcmVzb2x2ZWRcclxuICAgIC8vIC0gZmFpbHVyZTogc3NyIGNvbnRlbnQgc2hvdWxkIGJlIHRoZSBmYWxsYmFjayBicmFuY2guXHJcbiAgICAvLyBob3dldmVyLCBvbiB0aGUgY2xpZW50IHdlIGRvbid0IHJlYWxseSBrbm93IGlmIGl0IGhhcyBmYWlsZWQgb3Igbm90XHJcbiAgICAvLyBhdHRlbXB0IHRvIGh5ZHJhdGUgdGhlIERPTSBhc3N1bWluZyBpdCBoYXMgc3VjY2VlZGVkLCBidXQgd2Ugc3RpbGxcclxuICAgIC8vIG5lZWQgdG8gY29uc3RydWN0IGEgc3VzcGVuc2UgYm91bmRhcnkgZmlyc3RcclxuICAgIGNvbnN0IHJlc3VsdCA9IGh5ZHJhdGVOb2RlKG5vZGUsIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50KSwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgaWYgKHN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuKHZub2RlKSB7XHJcbiAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xyXG4gICAgY29uc3QgaXNTbG90Q2hpbGRyZW4gPSBzaGFwZUZsYWcgJiAzMiAvKiBTTE9UU19DSElMRFJFTiAqLztcclxuICAgIHZub2RlLnNzQ29udGVudCA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChpc1Nsb3RDaGlsZHJlbiA/IGNoaWxkcmVuLmRlZmF1bHQgOiBjaGlsZHJlbik7XHJcbiAgICB2bm9kZS5zc0ZhbGxiYWNrID0gaXNTbG90Q2hpbGRyZW5cclxuICAgICAgICA/IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChjaGlsZHJlbi5mYWxsYmFjaylcclxuICAgICAgICA6IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChzKSB7XHJcbiAgICBsZXQgYmxvY2s7XHJcbiAgICBpZiAoaXNGdW5jdGlvbiQxKHMpKSB7XHJcbiAgICAgICAgY29uc3QgaXNDb21waWxlZFNsb3QgPSBzLl9jO1xyXG4gICAgICAgIGlmIChpc0NvbXBpbGVkU2xvdCkge1xyXG4gICAgICAgICAgICAvLyBkaXNhYmxlVHJhY2tpbmc6IGZhbHNlXHJcbiAgICAgICAgICAgIC8vIGFsbG93IGJsb2NrIHRyYWNraW5nIGZvciBjb21waWxlZCBzbG90c1xyXG4gICAgICAgICAgICAvLyAoc2VlIC4vY29tcG9uZW50UmVuZGVyQ29udGV4dC50cylcclxuICAgICAgICAgICAgcy5fZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBvcGVuQmxvY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcyA9IHMoKTtcclxuICAgICAgICBpZiAoaXNDb21waWxlZFNsb3QpIHtcclxuICAgICAgICAgICAgcy5fZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGJsb2NrID0gY3VycmVudEJsb2NrO1xyXG4gICAgICAgICAgICBjbG9zZUJsb2NrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkocykpIHtcclxuICAgICAgICBjb25zdCBzaW5nbGVDaGlsZCA9IGZpbHRlclNpbmdsZVJvb3Qocyk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhc2luZ2xlQ2hpbGQpIHtcclxuICAgICAgICAgICAgd2FybihgPFN1c3BlbnNlPiBzbG90cyBleHBlY3QgYSBzaW5nbGUgcm9vdCBub2RlLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzID0gc2luZ2xlQ2hpbGQ7XHJcbiAgICB9XHJcbiAgICBzID0gbm9ybWFsaXplVk5vZGUocyk7XHJcbiAgICBpZiAoYmxvY2spIHtcclxuICAgICAgICBzLmR5bmFtaWNDaGlsZHJlbiA9IGJsb2NrLmZpbHRlcihjID0+IGMgIT09IHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHM7XHJcbn1cclxuZnVuY3Rpb24gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoZm4sIHN1c3BlbnNlKSB7XHJcbiAgICBpZiAoc3VzcGVuc2UgJiYgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgIGlmIChpc0FycmF5KGZuKSkge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goLi4uZm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKGZuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGZuKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGJyYW5jaCkge1xyXG4gICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gYnJhbmNoO1xyXG4gICAgY29uc3QgeyB2bm9kZSwgcGFyZW50Q29tcG9uZW50IH0gPSBzdXNwZW5zZTtcclxuICAgIGNvbnN0IGVsID0gKHZub2RlLmVsID0gYnJhbmNoLmVsKTtcclxuICAgIC8vIGluIGNhc2Ugc3VzcGVuc2UgaXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNvbXBvbmVudCxcclxuICAgIC8vIHJlY3Vyc2l2ZWx5IHVwZGF0ZSB0aGUgSE9DIGVsXHJcbiAgICBpZiAocGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xyXG4gICAgICAgIHBhcmVudENvbXBvbmVudC52bm9kZS5lbCA9IGVsO1xyXG4gICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIGVsKTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcclxuICAgIGlmICghY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBwcm92aWRlKCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKS5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXM7XHJcbiAgICAgICAgLy8gYnkgZGVmYXVsdCBhbiBpbnN0YW5jZSBpbmhlcml0cyBpdHMgcGFyZW50J3MgcHJvdmlkZXMgb2JqZWN0XHJcbiAgICAgICAgLy8gYnV0IHdoZW4gaXQgbmVlZHMgdG8gcHJvdmlkZSB2YWx1ZXMgb2YgaXRzIG93biwgaXQgY3JlYXRlcyBpdHNcclxuICAgICAgICAvLyBvd24gcHJvdmlkZXMgb2JqZWN0IHVzaW5nIHBhcmVudCBwcm92aWRlcyBvYmplY3QgYXMgcHJvdG90eXBlLlxyXG4gICAgICAgIC8vIHRoaXMgd2F5IGluIGBpbmplY3RgIHdlIGNhbiBzaW1wbHkgbG9vayB1cCBpbmplY3Rpb25zIGZyb20gZGlyZWN0XHJcbiAgICAgICAgLy8gcGFyZW50IGFuZCBsZXQgdGhlIHByb3RvdHlwZSBjaGFpbiBkbyB0aGUgd29yay5cclxuICAgICAgICBjb25zdCBwYXJlbnRQcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQgJiYgY3VycmVudEluc3RhbmNlLnBhcmVudC5wcm92aWRlcztcclxuICAgICAgICBpZiAocGFyZW50UHJvdmlkZXMgPT09IHByb3ZpZGVzKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9sIGFzIGluZGV4IHR5cGVcclxuICAgICAgICBwcm92aWRlc1trZXldID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5qZWN0KGtleSwgZGVmYXVsdFZhbHVlLCB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgPSBmYWxzZSkge1xyXG4gICAgLy8gZmFsbGJhY2sgdG8gYGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZWAgc28gdGhhdCB0aGlzIGNhbiBiZSBjYWxsZWQgaW5cclxuICAgIC8vIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcclxuICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIC8vICMyNDAwXHJcbiAgICAgICAgLy8gdG8gc3VwcG9ydCBgYXBwLnVzZWAgcGx1Z2lucyxcclxuICAgICAgICAvLyBmYWxsYmFjayB0byBhcHBDb250ZXh0J3MgYHByb3ZpZGVzYCBpZiB0aGUgaW50YW5jZSBpcyBhdCByb290XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXMgPSBpbnN0YW5jZS5wYXJlbnQgPT0gbnVsbFxyXG4gICAgICAgICAgICA/IGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQgJiYgaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dC5wcm92aWRlc1xyXG4gICAgICAgICAgICA6IGluc3RhbmNlLnBhcmVudC5wcm92aWRlcztcclxuICAgICAgICBpZiAocHJvdmlkZXMgJiYga2V5IGluIHByb3ZpZGVzKSB7XHJcbiAgICAgICAgICAgIC8vIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9sIGFzIGluZGV4IHR5cGVcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbiQxKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UucHJveHkpXHJcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGluamVjdGlvbiBcIiR7U3RyaW5nKGtleSl9XCIgbm90IGZvdW5kLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYGluamVjdCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkgb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLmApO1xyXG4gICAgfVxyXG59XG5cbi8vIFNpbXBsZSBlZmZlY3QuXHJcbmZ1bmN0aW9uIHdhdGNoRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCBvcHRpb25zKTtcclxufVxyXG4vLyBpbml0aWFsIHZhbHVlIGZvciB3YXRjaGVycyB0byB0cmlnZ2VyIG9uIHVuZGVmaW5lZCBpbml0aWFsIHZhbHVlc1xyXG5jb25zdCBJTklUSUFMX1dBVENIRVJfVkFMVUUgPSB7fTtcclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNGdW5jdGlvbiQxKGNiKSkge1xyXG4gICAgICAgIHdhcm4oYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBgICtcclxuICAgICAgICAgICAgYFVzZSBcXGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pXFxgIGluc3RlYWQuIFxcYHdhdGNoXFxgIG5vdyBvbmx5IGAgK1xyXG4gICAgICAgICAgICBgc3VwcG9ydHMgXFxgd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIGRvV2F0Y2goc291cmNlLCBjYiwgeyBpbW1lZGlhdGUsIGRlZXAsIGZsdXNoLCBvblRyYWNrLCBvblRyaWdnZXIgfSA9IEVNUFRZX09CSiwgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNiKSB7XHJcbiAgICAgICAgaWYgKGltbWVkaWF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHdhdGNoKCkgXCJpbW1lZGlhdGVcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgYCArXHJcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlZXAgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuKGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBgICtcclxuICAgICAgICAgICAgICAgIGB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHdhcm5JbnZhbGlkU291cmNlID0gKHMpID0+IHtcclxuICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIHNvdXJjZTogYCwgcywgYEEgd2F0Y2ggc291cmNlIGNhbiBvbmx5IGJlIGEgZ2V0dGVyL2VmZmVjdCBmdW5jdGlvbiwgYSByZWYsIGAgK1xyXG4gICAgICAgICAgICBgYSByZWFjdGl2ZSBvYmplY3QsIG9yIGFuIGFycmF5IG9mIHRoZXNlIHR5cGVzLmApO1xyXG4gICAgfTtcclxuICAgIGxldCBnZXR0ZXI7XHJcbiAgICBsZXQgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XHJcbiAgICBsZXQgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xyXG4gICAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XHJcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gISFzb3VyY2UuX3NoYWxsb3c7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2U7XHJcbiAgICAgICAgZGVlcCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgICBpc011bHRpU291cmNlID0gdHJ1ZTtcclxuICAgICAgICBmb3JjZVRyaWdnZXIgPSBzb3VyY2Uuc29tZShpc1JlYWN0aXZlKTtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKHMgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNSZWYocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZShzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uJDEocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsV2l0aEVycm9ySGFuZGxpbmcocywgaW5zdGFuY2UsIDIgLyogV0FUQ0hfR0VUVEVSICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbiQxKHNvdXJjZSkpIHtcclxuICAgICAgICBpZiAoY2IpIHtcclxuICAgICAgICAgICAgLy8gZ2V0dGVyIHdpdGggY2JcclxuICAgICAgICAgICAgZ2V0dGVyID0gKCkgPT4gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHNvdXJjZSwgaW5zdGFuY2UsIDIgLyogV0FUQ0hfR0VUVEVSICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG5vIGNiIC0+IHNpbXBsZSBlZmZlY3RcclxuICAgICAgICAgICAgZ2V0dGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLmlzVW5tb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFudXApIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoc291cmNlLCBpbnN0YW5jZSwgMyAvKiBXQVRDSF9DQUxMQkFDSyAqLywgW29uSW52YWxpZGF0ZV0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldHRlciA9IE5PT1A7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5JbnZhbGlkU291cmNlKHNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY2IgJiYgZGVlcCkge1xyXG4gICAgICAgIGNvbnN0IGJhc2VHZXR0ZXIgPSBnZXR0ZXI7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpKTtcclxuICAgIH1cclxuICAgIGxldCBjbGVhbnVwO1xyXG4gICAgbGV0IG9uSW52YWxpZGF0ZSA9IChmbikgPT4ge1xyXG4gICAgICAgIGNsZWFudXAgPSBydW5uZXIub3B0aW9ucy5vblN0b3AgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIDQgLyogV0FUQ0hfQ0xFQU5VUCAqLyk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBsZXQgb2xkVmFsdWUgPSBpc011bHRpU291cmNlID8gW10gOiBJTklUSUFMX1dBVENIRVJfVkFMVUU7XHJcbiAgICBjb25zdCBqb2IgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFydW5uZXIuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIC8vIHdhdGNoKHNvdXJjZSwgY2IpXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcnVubmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChkZWVwIHx8XHJcbiAgICAgICAgICAgICAgICBmb3JjZVRyaWdnZXIgfHxcclxuICAgICAgICAgICAgICAgIChpc011bHRpU291cmNlXHJcbiAgICAgICAgICAgICAgICAgICAgPyBuZXdWYWx1ZS5zb21lKCh2LCBpKSA9PiBoYXNDaGFuZ2VkKHYsIG9sZFZhbHVlW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICA6IGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkgfHxcclxuICAgICAgICAgICAgICAgIChmYWxzZSAgKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY2xlYW51cCBiZWZvcmUgcnVubmluZyBjYiBhZ2FpblxyXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFudXApIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhjYiwgaW5zdGFuY2UsIDMgLyogV0FUQ0hfQ0FMTEJBQ0sgKi8sIFtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBwYXNzIHVuZGVmaW5lZCBhcyB0aGUgb2xkIHZhbHVlIHdoZW4gaXQncyBjaGFuZ2VkIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUUgPyB1bmRlZmluZWQgOiBvbGRWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBvbkludmFsaWRhdGVcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gd2F0Y2hFZmZlY3RcclxuICAgICAgICAgICAgcnVubmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGltcG9ydGFudDogbWFyayB0aGUgam9iIGFzIGEgd2F0Y2hlciBjYWxsYmFjayBzbyB0aGF0IHNjaGVkdWxlciBrbm93c1xyXG4gICAgLy8gaXQgaXMgYWxsb3dlZCB0byBzZWxmLXRyaWdnZXIgKCMxNzI3KVxyXG4gICAgam9iLmFsbG93UmVjdXJzZSA9ICEhY2I7XHJcbiAgICBsZXQgc2NoZWR1bGVyO1xyXG4gICAgaWYgKGZsdXNoID09PSAnc3luYycpIHtcclxuICAgICAgICBzY2hlZHVsZXIgPSBqb2I7IC8vIHRoZSBzY2hlZHVsZXIgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgZGlyZWN0bHlcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcpIHtcclxuICAgICAgICBzY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3Qoam9iLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBkZWZhdWx0OiAncHJlJ1xyXG4gICAgICAgIHNjaGVkdWxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFpbnN0YW5jZSB8fCBpbnN0YW5jZS5pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlUHJlRmx1c2hDYihqb2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gd2l0aCAncHJlJyBvcHRpb24sIHRoZSBmaXJzdCBjYWxsIG11c3QgaGFwcGVuIGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIHNvIGl0IGlzIGNhbGxlZCBzeW5jaHJvbm91c2x5LlxyXG4gICAgICAgICAgICAgICAgam9iKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgcnVubmVyID0gZWZmZWN0KGdldHRlciwge1xyXG4gICAgICAgIGxhenk6IHRydWUsXHJcbiAgICAgICAgb25UcmFjayxcclxuICAgICAgICBvblRyaWdnZXIsXHJcbiAgICAgICAgc2NoZWR1bGVyXHJcbiAgICB9KTtcclxuICAgIHJlY29yZEluc3RhbmNlQm91bmRFZmZlY3QocnVubmVyLCBpbnN0YW5jZSk7XHJcbiAgICAvLyBpbml0aWFsIHJ1blxyXG4gICAgaWYgKGNiKSB7XHJcbiAgICAgICAgaWYgKGltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgICBqb2IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9sZFZhbHVlID0gcnVubmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmx1c2ggPT09ICdwb3N0Jykge1xyXG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChydW5uZXIsIGluc3RhbmNlICYmIGluc3RhbmNlLnN1c3BlbnNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJ1bm5lcigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBzdG9wKHJ1bm5lcik7XHJcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZShpbnN0YW5jZS5lZmZlY3RzLCBydW5uZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLy8gdGhpcy4kd2F0Y2hcclxuZnVuY3Rpb24gaW5zdGFuY2VXYXRjaChzb3VyY2UsIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBwdWJsaWNUaGlzID0gdGhpcy5wcm94eTtcclxuICAgIGNvbnN0IGdldHRlciA9IGlzU3RyaW5nKHNvdXJjZSlcclxuICAgICAgICA/IHNvdXJjZS5pbmNsdWRlcygnLicpXHJcbiAgICAgICAgICAgID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBzb3VyY2UpXHJcbiAgICAgICAgICAgIDogKCkgPT4gcHVibGljVGhpc1tzb3VyY2VdXHJcbiAgICAgICAgOiBzb3VyY2UuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcclxuICAgIGxldCBjYjtcclxuICAgIGlmIChpc0Z1bmN0aW9uJDEodmFsdWUpKSB7XHJcbiAgICAgICAgY2IgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNiID0gdmFsdWUuaGFuZGxlcjtcclxuICAgICAgICBvcHRpb25zID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9XYXRjaChnZXR0ZXIsIGNiLmJpbmQocHVibGljVGhpcyksIG9wdGlvbnMsIHRoaXMpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVBhdGhHZXR0ZXIoY3R4LCBwYXRoKSB7XHJcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgbGV0IGN1ciA9IGN0eDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xyXG4gICAgICAgICAgICBjdXIgPSBjdXJbc2VnbWVudHNbaV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VyO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgc2VlbiA9IG5ldyBTZXQoKSkge1xyXG4gICAgaWYgKCFpc09iamVjdCQxKHZhbHVlKSB8fCB2YWx1ZVtcIl9fdl9za2lwXCIgLyogU0tJUCAqL10pIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZWVuID0gc2VlbiB8fCBuZXcgU2V0KCk7XHJcbiAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2Vlbi5hZGQodmFsdWUpO1xyXG4gICAgaWYgKGlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgIHRyYXZlcnNlKHZhbHVlLnZhbHVlLCBzZWVuKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZVtpXSwgc2Vlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTZXQodmFsdWUpIHx8IGlzTWFwKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHtcclxuICAgICAgICAgICAgdHJhdmVyc2Uodiwgc2Vlbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIHNlZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxuXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdGUoKSB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IHtcclxuICAgICAgICBpc01vdW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzTGVhdmluZzogZmFsc2UsXHJcbiAgICAgICAgaXNVbm1vdW50aW5nOiBmYWxzZSxcclxuICAgICAgICBsZWF2aW5nVk5vZGVzOiBuZXcgTWFwKClcclxuICAgIH07XHJcbiAgICBvbk1vdW50ZWQoKCkgPT4ge1xyXG4gICAgICAgIHN0YXRlLmlzTW91bnRlZCA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XHJcbiAgICAgICAgc3RhdGUuaXNVbm1vdW50aW5nID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbmNvbnN0IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yID0gW0Z1bmN0aW9uLCBBcnJheV07XHJcbmNvbnN0IEJhc2VUcmFuc2l0aW9uSW1wbCA9IHtcclxuICAgIG5hbWU6IGBCYXNlVHJhbnNpdGlvbmAsXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIG1vZGU6IFN0cmluZyxcclxuICAgICAgICBhcHBlYXI6IEJvb2xlYW4sXHJcbiAgICAgICAgcGVyc2lzdGVkOiBCb29sZWFuLFxyXG4gICAgICAgIC8vIGVudGVyXHJcbiAgICAgICAgb25CZWZvcmVFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25FbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BZnRlckVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkVudGVyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICAvLyBsZWF2ZVxyXG4gICAgICAgIG9uQmVmb3JlTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQWZ0ZXJMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25MZWF2ZUNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgLy8gYXBwZWFyXHJcbiAgICAgICAgb25CZWZvcmVBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFmdGVyQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFwcGVhckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3JcclxuICAgIH0sXHJcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xyXG4gICAgICAgIGxldCBwcmV2VHJhbnNpdGlvbktleTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50IG9yIGNvbXBvbmVudC4gVXNlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbmVlZCB0byB0cmFjayByZWFjdGl2aXR5IGZvciB0aGVzZSBwcm9wcyBzbyB1c2UgdGhlIHJhd1xyXG4gICAgICAgICAgICAvLyBwcm9wcyBmb3IgYSBiaXQgYmV0dGVyIHBlcmZcclxuICAgICAgICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbW9kZSB9ID0gcmF3UHJvcHM7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIG1vZGVcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBtb2RlICYmICFbJ2luLW91dCcsICdvdXQtaW4nLCAnZGVmYXVsdCddLmluY2x1ZGVzKG1vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAke21vZGV9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCBjaGlsZHJlbiBoYXMgYSBndWFyYW50ZWVkIGxlbmd0aCBvZiAxLlxyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNMZWF2aW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgPHRyYW5zaXRpb24+PGtlZXAtYWxpdmUvPjwvdHJhbnNpdGlvbj4sIHdlIG5lZWQgdG9cclxuICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgdHlwZSBvZiB0aGUga2VwdC1hbGl2ZSBjaGlsZHJlbi5cclxuICAgICAgICAgICAgY29uc3QgaW5uZXJDaGlsZCA9IGdldEtlZXBBbGl2ZUNoaWxkKGNoaWxkKTtcclxuICAgICAgICAgICAgaWYgKCFpbm5lckNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZW50ZXJIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoaW5uZXJDaGlsZCwgcmF3UHJvcHMsIHN0YXRlLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCBlbnRlckhvb2tzKTtcclxuICAgICAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBpbnN0YW5jZS5zdWJUcmVlO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRJbm5lckNoaWxkID0gb2xkQ2hpbGQgJiYgZ2V0S2VlcEFsaXZlQ2hpbGQob2xkQ2hpbGQpO1xyXG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbktleUNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgeyBnZXRUcmFuc2l0aW9uS2V5IH0gPSBpbm5lckNoaWxkLnR5cGU7XHJcbiAgICAgICAgICAgIGlmIChnZXRUcmFuc2l0aW9uS2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBnZXRUcmFuc2l0aW9uS2V5KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlRyYW5zaXRpb25LZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZUcmFuc2l0aW9uS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSBwcmV2VHJhbnNpdGlvbktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZUcmFuc2l0aW9uS2V5ID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25LZXlDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBoYW5kbGUgbW9kZVxyXG4gICAgICAgICAgICBpZiAob2xkSW5uZXJDaGlsZCAmJlxyXG4gICAgICAgICAgICAgICAgb2xkSW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50JDEgJiZcclxuICAgICAgICAgICAgICAgICghaXNTYW1lVk5vZGVUeXBlKGlubmVyQ2hpbGQsIG9sZElubmVyQ2hpbGQpIHx8IHRyYW5zaXRpb25LZXlDaGFuZ2VkKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVhdmluZ0hvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhvbGRJbm5lckNoaWxkLCByYXdQcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBvbGQgdHJlZSdzIGhvb2tzIGluIGNhc2Ugb2YgZHluYW1pYyB0cmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgbGVhdmluZ0hvb2tzKTtcclxuICAgICAgICAgICAgICAgIC8vIHN3aXRjaGluZyBiZXR3ZWVuIGRpZmZlcmVudCB2aWV3c1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcclxuICAgICAgICAgICAgICAgICAgICBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcgJiYgaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50JDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWF2aW5nSG9va3MuZGVsYXlMZWF2ZSA9IChlbCwgZWFybHlSZW1vdmUsIGRlbGF5ZWRMZWF2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCBvbGRJbm5lckNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW1N0cmluZyhvbGRJbm5lckNoaWxkLmtleSldID0gb2xkSW5uZXJDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFybHkgcmVtb3ZhbCBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhcmx5UmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXJIb29rcy5kZWxheWVkTGVhdmUgPSBkZWxheWVkTGVhdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuLy8gZXhwb3J0IHRoZSBwdWJsaWMgdHlwZSBmb3IgaC90c3ggaW5mZXJlbmNlXHJcbi8vIGFsc28gdG8gYXZvaWQgaW5saW5lIGltcG9ydCgpIGluIGdlbmVyYXRlZCBkLnRzIGZpbGVzXHJcbmNvbnN0IEJhc2VUcmFuc2l0aW9uID0gQmFzZVRyYW5zaXRpb25JbXBsO1xyXG5mdW5jdGlvbiBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSkge1xyXG4gICAgY29uc3QgeyBsZWF2aW5nVk5vZGVzIH0gPSBzdGF0ZTtcclxuICAgIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcclxuICAgIGlmICghbGVhdmluZ1ZOb2Rlc0NhY2hlKSB7XHJcbiAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlYXZpbmdWTm9kZXNDYWNoZTtcclxufVxyXG4vLyBUaGUgdHJhbnNpdGlvbiBob29rcyBhcmUgYXR0YWNoZWQgdG8gdGhlIHZub2RlIGFzIHZub2RlLnRyYW5zaXRpb25cclxuLy8gYW5kIHdpbGwgYmUgY2FsbGVkIGF0IGFwcHJvcHJpYXRlIHRpbWluZyBpbiB0aGUgcmVuZGVyZXIuXHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgYXBwZWFyLCBtb2RlLCBwZXJzaXN0ZWQgPSBmYWxzZSwgb25CZWZvcmVFbnRlciwgb25FbnRlciwgb25BZnRlckVudGVyLCBvbkVudGVyQ2FuY2VsbGVkLCBvbkJlZm9yZUxlYXZlLCBvbkxlYXZlLCBvbkFmdGVyTGVhdmUsIG9uTGVhdmVDYW5jZWxsZWQsIG9uQmVmb3JlQXBwZWFyLCBvbkFwcGVhciwgb25BZnRlckFwcGVhciwgb25BcHBlYXJDYW5jZWxsZWQgfSA9IHByb3BzO1xyXG4gICAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XHJcbiAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSk7XHJcbiAgICBjb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzKSA9PiB7XHJcbiAgICAgICAgaG9vayAmJlxyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOSAvKiBUUkFOU0lUSU9OX0hPT0sgKi8sIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGhvb2tzID0ge1xyXG4gICAgICAgIG1vZGUsXHJcbiAgICAgICAgcGVyc2lzdGVkLFxyXG4gICAgICAgIGJlZm9yZUVudGVyKGVsKSB7XHJcbiAgICAgICAgICAgIGxldCBob29rID0gb25CZWZvcmVFbnRlcjtcclxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcHBlYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBob29rID0gb25CZWZvcmVBcHBlYXIgfHwgb25CZWZvcmVFbnRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmb3Igc2FtZSBlbGVtZW50ICh2LXNob3cpXHJcbiAgICAgICAgICAgIGlmIChlbC5fbGVhdmVDYikge1xyXG4gICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IodHJ1ZSAvKiBjYW5jZWxsZWQgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZvciB0b2dnbGVkIGVsZW1lbnQgd2l0aCBzYW1lIGtleSAodi1pZilcclxuICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2RlID0gbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV07XHJcbiAgICAgICAgICAgIGlmIChsZWF2aW5nVk5vZGUgJiZcclxuICAgICAgICAgICAgICAgIGlzU2FtZVZOb2RlVHlwZSh2bm9kZSwgbGVhdmluZ1ZOb2RlKSAmJlxyXG4gICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2RlLmVsLl9sZWF2ZUNiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSBlYXJseSByZW1vdmFsIChub3QgY2FuY2VsbGVkKVxyXG4gICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2RlLmVsLl9sZWF2ZUNiKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbEhvb2soaG9vaywgW2VsXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnRlcihlbCkge1xyXG4gICAgICAgICAgICBsZXQgaG9vayA9IG9uRW50ZXI7XHJcbiAgICAgICAgICAgIGxldCBhZnRlckhvb2sgPSBvbkFmdGVyRW50ZXI7XHJcbiAgICAgICAgICAgIGxldCBjYW5jZWxIb29rID0gb25FbnRlckNhbmNlbGxlZDtcclxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcHBlYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBob29rID0gb25BcHBlYXIgfHwgb25FbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICBhZnRlckhvb2sgPSBvbkFmdGVyQXBwZWFyIHx8IG9uQWZ0ZXJFbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxIb29rID0gb25BcHBlYXJDYW5jZWxsZWQgfHwgb25FbnRlckNhbmNlbGxlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSAoZWwuX2VudGVyQ2IgPSAoY2FuY2VsbGVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2soY2FuY2VsSG9vaywgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGhvb2tzLmRlbGF5ZWRMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLmRlbGF5ZWRMZWF2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWwuX2VudGVyQ2IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaG9vaykge1xyXG4gICAgICAgICAgICAgICAgaG9vayhlbCwgZG9uZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG9vay5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGVhdmUoZWwsIHJlbW92ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcclxuICAgICAgICAgICAgaWYgKGVsLl9lbnRlckNiKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5fZW50ZXJDYih0cnVlIC8qIGNhbmNlbGxlZCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXRlLmlzVW5tb3VudGluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uQmVmb3JlTGVhdmUsIFtlbF0pO1xyXG4gICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSAoZWwuX2xlYXZlQ2IgPSAoY2FuY2VsbGVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKG9uQWZ0ZXJMZWF2ZSwgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmIChsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XSA9PT0gdm5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XSA9IHZub2RlO1xyXG4gICAgICAgICAgICBpZiAob25MZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgb25MZWF2ZShlbCwgZG9uZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAob25MZWF2ZS5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xvbmUodm5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gaG9va3M7XHJcbn1cclxuLy8gdGhlIHBsYWNlaG9sZGVyIHJlYWxseSBvbmx5IGhhbmRsZXMgb25lIHNwZWNpYWwgY2FzZTogS2VlcEFsaXZlXHJcbi8vIGluIHRoZSBjYXNlIG9mIGEgS2VlcEFsaXZlIGluIGEgbGVhdmUgcGhhc2Ugd2UgbmVlZCB0byByZXR1cm4gYSBLZWVwQWxpdmVcclxuLy8gcGxhY2Vob2xkZXIgd2l0aCBlbXB0eSBjb250ZW50IHRvIGF2b2lkIHRoZSBLZWVwQWxpdmUgaW5zdGFuY2UgZnJvbSBiZWluZ1xyXG4vLyB1bm1vdW50ZWQuXHJcbmZ1bmN0aW9uIGVtcHR5UGxhY2Vob2xkZXIodm5vZGUpIHtcclxuICAgIGlmIChpc0tlZXBBbGl2ZSh2bm9kZSkpIHtcclxuICAgICAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gICAgICAgIHZub2RlLmNoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0S2VlcEFsaXZlQ2hpbGQodm5vZGUpIHtcclxuICAgIHJldHVybiBpc0tlZXBBbGl2ZSh2bm9kZSlcclxuICAgICAgICA/IHZub2RlLmNoaWxkcmVuXHJcbiAgICAgICAgICAgID8gdm5vZGUuY2hpbGRyZW5bMF1cclxuICAgICAgICAgICAgOiB1bmRlZmluZWRcclxuICAgICAgICA6IHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgaG9va3MpIHtcclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLyAmJiB2bm9kZS5jb21wb25lbnQpIHtcclxuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGhvb2tzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgIHZub2RlLnNzQ29udGVudC50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NDb250ZW50KTtcclxuICAgICAgICB2bm9kZS5zc0ZhbGxiYWNrLnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0ZhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZub2RlLnRyYW5zaXRpb24gPSBob29rcztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGRyZW4sIGtlZXBDb21tZW50ID0gZmFsc2UpIHtcclxuICAgIGxldCByZXQgPSBbXTtcclxuICAgIGxldCBrZXllZEZyYWdtZW50Q291bnQgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgLy8gaGFuZGxlIGZyYWdtZW50IGNoaWxkcmVuIGNhc2UsIGUuZy4gdi1mb3JcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnBhdGNoRmxhZyAmIDEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqLylcclxuICAgICAgICAgICAgICAgIGtleWVkRnJhZ21lbnRDb3VudCsrO1xyXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwga2VlcENvbW1lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29tbWVudCBwbGFjZWhvbGRlcnMgc2hvdWxkIGJlIHNraXBwZWQsIGUuZy4gdi1pZlxyXG4gICAgICAgIGVsc2UgaWYgKGtlZXBDb21tZW50IHx8IGNoaWxkLnR5cGUgIT09IENvbW1lbnQkMSkge1xyXG4gICAgICAgICAgICByZXQucHVzaChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gIzExMjYgaWYgYSB0cmFuc2l0aW9uIGNoaWxkcmVuIGxpc3QgY29udGFpbnMgbXVsdGlwbGUgc3ViIGZyYWdtZW50cywgdGhlc2VcclxuICAgIC8vIGZyYWdtZW50cyB3aWxsIGJlIG1lcmdlZCBpbnRvIGEgZmxhdCBjaGlsZHJlbiBhcnJheS4gU2luY2UgZWFjaCB2LWZvclxyXG4gICAgLy8gZnJhZ21lbnQgbWF5IGNvbnRhaW4gZGlmZmVyZW50IHN0YXRpYyBiaW5kaW5ncyBpbnNpZGUsIHdlIG5lZWQgdG8gZGUtb3BcclxuICAgIC8vIHRoZXNlIGNoaWxkcmVuIHRvIGZvcmNlIGZ1bGwgZGlmZnMgdG8gZW5zdXJlIGNvcnJlY3QgYmVoYXZpb3IuXHJcbiAgICBpZiAoa2V5ZWRGcmFnbWVudENvdW50ID4gMSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXS5wYXRjaEZsYWcgPSAtMiAvKiBCQUlMICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cblxuLy8gaW1wbGVtZW50YXRpb24sIGNsb3NlIHRvIG5vLW9wXHJcbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbiQxKG9wdGlvbnMpID8geyBzZXR1cDogb3B0aW9ucywgbmFtZTogb3B0aW9ucy5uYW1lIH0gOiBvcHRpb25zO1xyXG59XG5cbmNvbnN0IGlzQXN5bmNXcmFwcGVyID0gKGkpID0+ICEhaS50eXBlLl9fYXN5bmNMb2FkZXI7XHJcbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24kMShzb3VyY2UpKSB7XHJcbiAgICAgICAgc291cmNlID0geyBsb2FkZXI6IHNvdXJjZSB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBsb2FkZXIsIGxvYWRpbmdDb21wb25lbnQsIGVycm9yQ29tcG9uZW50LCBkZWxheSA9IDIwMCwgdGltZW91dCwgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XHJcbiAgICBzdXNwZW5zaWJsZSA9IHRydWUsIG9uRXJyb3I6IHVzZXJPbkVycm9yIH0gPSBzb3VyY2U7XHJcbiAgICBsZXQgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgbGV0IHJlc29sdmVkQ29tcDtcclxuICAgIGxldCByZXRyaWVzID0gMDtcclxuICAgIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHJpZXMrKztcclxuICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIGxvYWQoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBsb2FkID0gKCkgPT4ge1xyXG4gICAgICAgIGxldCB0aGlzUmVxdWVzdDtcclxuICAgICAgICByZXR1cm4gKHBlbmRpbmdSZXF1ZXN0IHx8XHJcbiAgICAgICAgICAgICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID0gbG9hZGVyKClcclxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgZXJyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJPbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlclJldHJ5ID0gKCkgPT4gcmVzb2x2ZShyZXRyeSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlckZhaWwgPSAoKSA9PiByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlck9uRXJyb3IoZXJyLCB1c2VyUmV0cnksIHVzZXJGYWlsLCByZXRyaWVzICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbigoY29tcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNSZXF1ZXN0ICE9PSBwZW5kaW5nUmVxdWVzdCAmJiBwZW5kaW5nUmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNvbXApIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBc3luYyBjb21wb25lbnQgbG9hZGVyIHJlc29sdmVkIHRvIHVuZGVmaW5lZC4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB5b3UgYXJlIHVzaW5nIHJldHJ5KCksIG1ha2Ugc3VyZSB0byByZXR1cm4gaXRzIHJldHVybiB2YWx1ZS5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGludGVyb3AgbW9kdWxlIGRlZmF1bHRcclxuICAgICAgICAgICAgICAgIGlmIChjb21wICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGNvbXAuX19lc01vZHVsZSB8fCBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbXAgJiYgIWlzT2JqZWN0JDEoY29tcCkgJiYgIWlzRnVuY3Rpb24kMShjb21wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7Y29tcH1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmVkQ29tcCA9IGNvbXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcDtcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZGVmaW5lQ29tcG9uZW50KHtcclxuICAgICAgICBuYW1lOiAnQXN5bmNDb21wb25lbnRXcmFwcGVyJyxcclxuICAgICAgICBfX2FzeW5jTG9hZGVyOiBsb2FkLFxyXG4gICAgICAgIGdldCBfX2FzeW5jUmVzb2x2ZWQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZENvbXA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXR1cCgpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICAgICAgICAgIC8vIGFscmVhZHkgcmVzb2x2ZWRcclxuICAgICAgICAgICAgaWYgKHJlc29sdmVkQ29tcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMTMgLyogQVNZTkNfQ09NUE9ORU5UX0xPQURFUiAqLywgIWVycm9yQ29tcG9uZW50IC8qIGRvIG5vdCB0aHJvdyBpbiBkZXYgaWYgdXNlciBwcm92aWRlZCBlcnJvciBjb21wb25lbnQgKi8pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBzdXNwZW5zZS1jb250cm9sbGVkIG9yIFNTUi5cclxuICAgICAgICAgICAgaWYgKChzdXNwZW5zaWJsZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSkgfHxcclxuICAgICAgICAgICAgICAgIChmYWxzZSApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZCgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oY29tcCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChjb21wLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZXJyb3JDb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsb2FkZWQgPSByZWYoZmFsc2UpO1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHJlZigpO1xyXG4gICAgICAgICAgICBjb25zdCBkZWxheWVkID0gcmVmKCEhZGVsYXkpO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXkpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ZWQudmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZC52YWx1ZSAmJiAhZXJyb3IudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBBc3luYyBjb21wb25lbnQgdGltZWQgb3V0IGFmdGVyICR7dGltZW91dH1tcy5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2FkKClcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxvYWRlZC52YWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50ICYmIGlzS2VlcEFsaXZlKGluc3RhbmNlLnBhcmVudC52bm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJlbnQgaXMga2VlcC1hbGl2ZSwgZm9yY2UgdXBkYXRlIHNvIHRoZSBsb2FkZWQgY29tcG9uZW50J3NcclxuICAgICAgICAgICAgICAgICAgICAvLyBuYW1lIGlzIHRha2VuIGludG8gYWNjb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlSm9iKGluc3RhbmNlLnBhcmVudC51cGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9hZGVkLnZhbHVlICYmIHJlc29sdmVkQ29tcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvci52YWx1ZSAmJiBlcnJvckNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvYWRpbmdDb21wb25lbnQgJiYgIWRlbGF5ZWQudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUobG9hZGluZ0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW5uZXJDb21wKGNvbXAsIHsgdm5vZGU6IHsgcmVmLCBwcm9wcywgY2hpbGRyZW4gfSB9KSB7XHJcbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKGNvbXAsIHByb3BzLCBjaGlsZHJlbik7XHJcbiAgICAvLyBlbnN1cmUgaW5uZXIgY29tcG9uZW50IGluaGVyaXRzIHRoZSBhc3luYyB3cmFwcGVyJ3MgcmVmIG93bmVyXHJcbiAgICB2bm9kZS5yZWYgPSByZWY7XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cblxuY29uc3QgaXNLZWVwQWxpdmUgPSAodm5vZGUpID0+IHZub2RlLnR5cGUuX19pc0tlZXBBbGl2ZTtcclxuY29uc3QgS2VlcEFsaXZlSW1wbCA9IHtcclxuICAgIG5hbWU6IGBLZWVwQWxpdmVgLFxyXG4gICAgLy8gTWFya2VyIGZvciBzcGVjaWFsIGhhbmRsaW5nIGluc2lkZSB0aGUgcmVuZGVyZXIuIFdlIGFyZSBub3QgdXNpbmcgYSA9PT1cclxuICAgIC8vIGNoZWNrIGRpcmVjdGx5IG9uIEtlZXBBbGl2ZSBpbiB0aGUgcmVuZGVyZXIsIGJlY2F1c2UgaW1wb3J0aW5nIGl0IGRpcmVjdGx5XHJcbiAgICAvLyB3b3VsZCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgdHJlZS1zaGFrZW4uXHJcbiAgICBfX2lzS2VlcEFsaXZlOiB0cnVlLFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBpbmNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcclxuICAgICAgICBleGNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcclxuICAgICAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cclxuICAgIH0sXHJcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICAvLyBLZWVwQWxpdmUgY29tbXVuaWNhdGVzIHdpdGggdGhlIGluc3RhbnRpYXRlZCByZW5kZXJlciB2aWEgdGhlXHJcbiAgICAgICAgLy8gY3R4IHdoZXJlIHRoZSByZW5kZXJlciBwYXNzZXMgaW4gaXRzIGludGVybmFscyxcclxuICAgICAgICAvLyBhbmQgdGhlIEtlZXBBbGl2ZSBpbnN0YW5jZSBleHBvc2VzIGFjdGl2YXRlL2RlYWN0aXZhdGUgaW1wbGVtZW50YXRpb25zLlxyXG4gICAgICAgIC8vIFRoZSB3aG9sZSBwb2ludCBvZiB0aGlzIGlzIHRvIGF2b2lkIGltcG9ydGluZyBLZWVwQWxpdmUgZGlyZWN0bHkgaW4gdGhlXHJcbiAgICAgICAgLy8gcmVuZGVyZXIgdG8gZmFjaWxpdGF0ZSB0cmVlLXNoYWtpbmcuXHJcbiAgICAgICAgY29uc3Qgc2hhcmVkQ29udGV4dCA9IGluc3RhbmNlLmN0eDtcclxuICAgICAgICAvLyBpZiB0aGUgaW50ZXJuYWwgcmVuZGVyZXIgaXMgbm90IHJlZ2lzdGVyZWQsIGl0IGluZGljYXRlcyB0aGF0IHRoaXMgaXMgc2VydmVyLXNpZGUgcmVuZGVyaW5nLFxyXG4gICAgICAgIC8vIGZvciBLZWVwQWxpdmUsIHdlIGp1c3QgbmVlZCB0byByZW5kZXIgaXRzIGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKCFzaGFyZWRDb250ZXh0LnJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbG90cy5kZWZhdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5fX3ZfY2FjaGUgPSBjYWNoZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyZW50U3VzcGVuc2UgPSBpbnN0YW5jZS5zdXNwZW5zZTtcclxuICAgICAgICBjb25zdCB7IHJlbmRlcmVyOiB7IHA6IHBhdGNoLCBtOiBtb3ZlLCB1bTogX3VubW91bnQsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0gfSA9IHNoYXJlZENvbnRleHQ7XHJcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHNoYXJlZENvbnRleHQuYWN0aXZhdGUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBtb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBFTlRFUiAqLywgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAvLyBpbiBjYXNlIHByb3BzIGhhdmUgY2hhbmdlZFxyXG4gICAgICAgICAgICBwYXRjaChpbnN0YW5jZS52bm9kZSwgdm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCB2bm9kZS5zbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc0RlYWN0aXZhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlLmEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZU1vdW50ZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodm5vZGVIb29rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UucGFyZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjb21wb25lbnRzIHRyZWVcclxuICAgICAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzaGFyZWRDb250ZXh0LmRlYWN0aXZhdGUgPSAodm5vZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUsIHN0b3JhZ2VDb250YWluZXIsIG51bGwsIDEgLyogTEVBVkUgKi8sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5kYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlLmRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVVbm1vdW50ZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodm5vZGVIb29rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UucGFyZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc0RlYWN0aXZhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbXBvbmVudHMgdHJlZVxyXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZ1bmN0aW9uIHVubW91bnQodm5vZGUpIHtcclxuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIHNoYXBlRmxhZyBzbyBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkXHJcbiAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcclxuICAgICAgICAgICAgX3VubW91bnQodm5vZGUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGUoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGNhY2hlLmZvckVhY2goKHZub2RlLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHZub2RlLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgJiYgKCFmaWx0ZXIgfHwgIWZpbHRlcihuYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShrZXkpIHtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGlmICghY3VycmVudCB8fCBjYWNoZWQudHlwZSAhPT0gY3VycmVudC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNhY2hlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgaW5zdGFuY2Ugc2hvdWxkIG5vIGxvbmdlciBiZSBrZXB0LWFsaXZlLlxyXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgdW5tb3VudCBpdCBub3cgYnV0IGl0IG1pZ2h0IGJlIGxhdGVyLCBzbyByZXNldCBpdHMgZmxhZyBub3cuXHJcbiAgICAgICAgICAgICAgICByZXNldFNoYXBlRmxhZyhjdXJyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWNoZS5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcHJ1bmUgY2FjaGUgb24gaW5jbHVkZS9leGNsdWRlIHByb3AgY2hhbmdlXHJcbiAgICAgICAgd2F0Y2goKCkgPT4gW3Byb3BzLmluY2x1ZGUsIHByb3BzLmV4Y2x1ZGVdLCAoW2luY2x1ZGUsIGV4Y2x1ZGVdKSA9PiB7XHJcbiAgICAgICAgICAgIGluY2x1ZGUgJiYgcHJ1bmVDYWNoZShuYW1lID0+IG1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpO1xyXG4gICAgICAgICAgICBleGNsdWRlICYmIHBydW5lQ2FjaGUobmFtZSA9PiAhbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSk7XHJcbiAgICAgICAgfSwgXHJcbiAgICAgICAgLy8gcHJ1bmUgcG9zdC1yZW5kZXIgYWZ0ZXIgYGN1cnJlbnRgIGhhcyBiZWVuIHVwZGF0ZWRcclxuICAgICAgICB7IGZsdXNoOiAncG9zdCcsIGRlZXA6IHRydWUgfSk7XHJcbiAgICAgICAgLy8gY2FjaGUgc3ViIHRyZWUgYWZ0ZXIgcmVuZGVyXHJcbiAgICAgICAgbGV0IHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgY2FjaGVTdWJ0cmVlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBmaXggIzE2MjEsIHRoZSBwZW5kaW5nQ2FjaGVLZXkgY291bGQgYmUgMFxyXG4gICAgICAgICAgICBpZiAocGVuZGluZ0NhY2hlS2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlLnNldChwZW5kaW5nQ2FjaGVLZXksIGdldElubmVyQ2hpbGQoaW5zdGFuY2Uuc3ViVHJlZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBvbk1vdW50ZWQoY2FjaGVTdWJ0cmVlKTtcclxuICAgICAgICBvblVwZGF0ZWQoY2FjaGVTdWJ0cmVlKTtcclxuICAgICAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xyXG4gICAgICAgICAgICBjYWNoZS5mb3JFYWNoKGNhY2hlZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN1YlRyZWUsIHN1c3BlbnNlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChzdWJUcmVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQudHlwZSA9PT0gdm5vZGUudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgaW5zdGFuY2Ugd2lsbCBiZSB1bm1vdW50ZWQgYXMgcGFydCBvZiBrZWVwLWFsaXZlJ3MgdW5tb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgaW52b2tlIGl0cyBkZWFjdGl2YXRlZCBob29rIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYSA9IHZub2RlLmNvbXBvbmVudC5kYTtcclxuICAgICAgICAgICAgICAgICAgICBkYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZGEsIHN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNhY2hlZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghc2xvdHMuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhd1ZOb2RlID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ZOb2RlKHJhd1ZOb2RlKSB8fFxyXG4gICAgICAgICAgICAgICAgKCEocmF3Vk5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChyYXdWTm9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXAgPSB2bm9kZS50eXBlO1xyXG4gICAgICAgICAgICAvLyBmb3IgYXN5bmMgY29tcG9uZW50cywgbmFtZSBjaGVjayBzaG91bGQgYmUgYmFzZWQgaW4gaXRzIGxvYWRlZFxyXG4gICAgICAgICAgICAvLyBpbm5lciBjb21wb25lbnQgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGlzQXN5bmNXcmFwcGVyKHZub2RlKVxyXG4gICAgICAgICAgICAgICAgPyB2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCB8fCB7fVxyXG4gICAgICAgICAgICAgICAgOiBjb21wKTtcclxuICAgICAgICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlLCBtYXggfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBpZiAoKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcclxuICAgICAgICAgICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbCA/IGNvbXAgOiB2bm9kZS5rZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFZOb2RlID0gY2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIC8vIGNsb25lIHZub2RlIGlmIGl0J3MgcmV1c2VkIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIG11dGF0ZSBpdFxyXG4gICAgICAgICAgICBpZiAodm5vZGUuZWwpIHtcclxuICAgICAgICAgICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF3Vk5vZGUuc3NDb250ZW50ID0gdm5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gIzE1MTMgaXQncyBwb3NzaWJsZSBmb3IgdGhlIHJldHVybmVkIHZub2RlIHRvIGJlIGNsb25lZCBkdWUgdG8gYXR0clxyXG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaCBvciBzY29wZUlkLCBzbyB0aGUgdm5vZGUgaGVyZSBtYXkgbm90IGJlIHRoZSBmaW5hbCB2bm9kZVxyXG4gICAgICAgICAgICAvLyB0aGF0IGlzIG1vdW50ZWQuIEluc3RlYWQgb2YgY2FjaGluZyBpdCBkaXJlY3RseSwgd2Ugc3RvcmUgdGhlIHBlbmRpbmdcclxuICAgICAgICAgICAgLy8ga2V5IGFuZCBjYWNoZSBgaW5zdGFuY2Uuc3ViVHJlZWAgKHRoZSBub3JtYWxpemVkIHZub2RlKSBpblxyXG4gICAgICAgICAgICAvLyBiZWZvcmVNb3VudC9iZWZvcmVVcGRhdGUgaG9va3MuXHJcbiAgICAgICAgICAgIHBlbmRpbmdDYWNoZUtleSA9IGtleTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZFZOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb3B5IG92ZXIgbW91bnRlZCBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgdm5vZGUuZWwgPSBjYWNoZWRWTm9kZS5lbDtcclxuICAgICAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudCA9IGNhY2hlZFZOb2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIHRyYW5zaXRpb24gaG9va3Mgb24gc3ViVHJlZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgdm5vZGUudHJhbnNpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyBtb3VudGVkIGFzIGZyZXNoXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovO1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGlzIGtleSB0aGUgZnJlc2hlc3RcclxuICAgICAgICAgICAgICAgIGtleXMuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAga2V5cy5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxyXG4gICAgICAgICAgICAgICAgaWYgKG1heCAmJiBrZXlzLnNpemUgPiBwYXJzZUludChtYXgsIDEwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYXZvaWQgdm5vZGUgYmVpbmcgdW5tb3VudGVkXHJcbiAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gdm5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG4vLyBleHBvcnQgdGhlIHB1YmxpYyB0eXBlIGZvciBoL3RzeCBpbmZlcmVuY2VcclxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcclxuY29uc3QgS2VlcEFsaXZlID0gS2VlcEFsaXZlSW1wbDtcclxuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XHJcbiAgICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNvbWUoKHApID0+IG1hdGNoZXMocCwgbmFtZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcclxuICAgICAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhdHRlcm4udGVzdCkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIG9uQWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xyXG4gICAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiYVwiIC8qIEFDVElWQVRFRCAqLywgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiBvbkRlYWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xyXG4gICAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiZGFcIiAvKiBERUFDVElWQVRFRCAqLywgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgdHlwZSwgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICAvLyBjYWNoZSB0aGUgZGVhY3RpdmF0ZSBicmFuY2ggY2hlY2sgd3JhcHBlciBmb3IgaW5qZWN0ZWQgaG9va3Mgc28gdGhlIHNhbWVcclxuICAgIC8vIGhvb2sgY2FuIGJlIHByb3Blcmx5IGRlZHVwZWQgYnkgdGhlIHNjaGVkdWxlci4gXCJfX3dkY1wiIHN0YW5kcyBmb3IgXCJ3aXRoXHJcbiAgICAvLyBkZWFjdGl2YXRpb24gY2hlY2tcIi5cclxuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dkYyB8fFxyXG4gICAgICAgIChob29rLl9fd2RjID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBvbmx5IGZpcmUgdGhlIGhvb2sgaWYgdGhlIHRhcmdldCBpbnN0YW5jZSBpcyBOT1QgaW4gYSBkZWFjdGl2YXRlZCBicmFuY2guXHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuaXNEZWFjdGl2YXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob29rKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICBpbmplY3RIb29rKHR5cGUsIHdyYXBwZWRIb29rLCB0YXJnZXQpO1xyXG4gICAgLy8gSW4gYWRkaXRpb24gdG8gcmVnaXN0ZXJpbmcgaXQgb24gdGhlIHRhcmdldCBpbnN0YW5jZSwgd2Ugd2FsayB1cCB0aGUgcGFyZW50XHJcbiAgICAvLyBjaGFpbiBhbmQgcmVnaXN0ZXIgaXQgb24gYWxsIGFuY2VzdG9yIGluc3RhbmNlcyB0aGF0IGFyZSBrZWVwLWFsaXZlIHJvb3RzLlxyXG4gICAgLy8gVGhpcyBhdm9pZHMgdGhlIG5lZWQgdG8gd2FsayB0aGUgZW50aXJlIGNvbXBvbmVudCB0cmVlIHdoZW4gaW52b2tpbmcgdGhlc2VcclxuICAgIC8vIGhvb2tzLCBhbmQgbW9yZSBpbXBvcnRhbnRseSwgYXZvaWRzIHRoZSBuZWVkIHRvIHRyYWNrIGNoaWxkIGNvbXBvbmVudHMgaW5cclxuICAgIC8vIGFycmF5cy5cclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRhcmdldC5wYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGlzS2VlcEFsaXZlKGN1cnJlbnQucGFyZW50LnZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgaW5qZWN0VG9LZWVwQWxpdmVSb290KHdyYXBwZWRIb29rLCB0eXBlLCB0YXJnZXQsIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5qZWN0VG9LZWVwQWxpdmVSb290KGhvb2ssIHR5cGUsIHRhcmdldCwga2VlcEFsaXZlUm9vdCkge1xyXG4gICAgLy8gaW5qZWN0SG9vayB3cmFwcyB0aGUgb3JpZ2luYWwgZm9yIGVycm9yIGhhbmRsaW5nLCBzbyBtYWtlIHN1cmUgdG8gcmVtb3ZlXHJcbiAgICAvLyB0aGUgd3JhcHBlZCB2ZXJzaW9uLlxyXG4gICAgY29uc3QgaW5qZWN0ZWQgPSBpbmplY3RIb29rKHR5cGUsIGhvb2ssIGtlZXBBbGl2ZVJvb3QsIHRydWUgLyogcHJlcGVuZCAqLyk7XHJcbiAgICBvblVubW91bnRlZCgoKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlKGtlZXBBbGl2ZVJvb3RbdHlwZV0sIGluamVjdGVkKTtcclxuICAgIH0sIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRTaGFwZUZsYWcodm5vZGUpIHtcclxuICAgIGxldCBzaGFwZUZsYWcgPSB2bm9kZS5zaGFwZUZsYWc7XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xyXG4gICAgICAgIHNoYXBlRmxhZyAtPSAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovO1xyXG4gICAgfVxyXG4gICAgaWYgKHNoYXBlRmxhZyAmIDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLykge1xyXG4gICAgICAgIHNoYXBlRmxhZyAtPSA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XHJcbiAgICB9XHJcbiAgICB2bm9kZS5zaGFwZUZsYWcgPSBzaGFwZUZsYWc7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCh2bm9kZSkge1xyXG4gICAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLyA/IHZub2RlLnNzQ29udGVudCA6IHZub2RlO1xyXG59XG5cbmZ1bmN0aW9uIGluamVjdEhvb2sodHlwZSwgaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlLCBwcmVwZW5kID0gZmFsc2UpIHtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBob29rcyA9IHRhcmdldFt0eXBlXSB8fCAodGFyZ2V0W3R5cGVdID0gW10pO1xyXG4gICAgICAgIC8vIGNhY2hlIHRoZSBlcnJvciBoYW5kbGluZyB3cmFwcGVyIGZvciBpbmplY3RlZCBob29rcyBzbyB0aGUgc2FtZSBob29rXHJcbiAgICAgICAgLy8gY2FuIGJlIHByb3Blcmx5IGRlZHVwZWQgYnkgdGhlIHNjaGVkdWxlci4gXCJfX3dlaFwiIHN0YW5kcyBmb3IgXCJ3aXRoIGVycm9yXHJcbiAgICAgICAgLy8gaGFuZGxpbmdcIi5cclxuICAgICAgICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZWggfHxcclxuICAgICAgICAgICAgKGhvb2suX193ZWggPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdHJhY2tpbmcgaW5zaWRlIGFsbCBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgY2FuIHBvdGVudGlhbGx5IGJlIGNhbGxlZCBpbnNpZGUgZWZmZWN0cy5cclxuICAgICAgICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBjdXJyZW50SW5zdGFuY2UgZHVyaW5nIGhvb2sgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXNzdW1lcyB0aGUgaG9vayBkb2VzIG5vdCBzeW5jaHJvbm91c2x5IHRyaWdnZXIgb3RoZXIgaG9va3MsIHdoaWNoXHJcbiAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBiZSBmYWxzZSB3aGVuIHRoZSB1c2VyIGRvZXMgc29tZXRoaW5nIHJlYWxseSBmdW5reS5cclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgdGFyZ2V0LCB0eXBlLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcclxuICAgICAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChwcmVwZW5kKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnVuc2hpZnQod3JhcHBlZEhvb2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3cmFwcGVkSG9vaztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGFwaU5hbWUgPSB0b0hhbmRsZXJLZXkoRXJyb3JUeXBlU3RyaW5nc1t0eXBlXS5yZXBsYWNlKC8gaG9vayQvLCAnJykpO1xyXG4gICAgICAgIHdhcm4oYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBgICtcclxuICAgICAgICAgICAgYGFzc29jaWF0ZWQgd2l0aC4gYCArXHJcbiAgICAgICAgICAgIGBMaWZlY3ljbGUgaW5qZWN0aW9uIEFQSXMgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHNldHVwKCkuYCArXHJcbiAgICAgICAgICAgIChgIElmIHlvdSBhcmUgdXNpbmcgYXN5bmMgc2V0dXAoKSwgbWFrZSBzdXJlIHRvIHJlZ2lzdGVyIGxpZmVjeWNsZSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgaG9va3MgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdCBzdGF0ZW1lbnQuYFxyXG4gICAgICAgICAgICAgICAgKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgY3JlYXRlSG9vayA9IChsaWZlY3ljbGUpID0+IChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpID0+IFxyXG4vLyBwb3N0LWNyZWF0ZSBsaWZlY3ljbGUgcmVnaXN0cmF0aW9ucyBhcmUgbm9vcHMgZHVyaW5nIFNTUiAoZXhjZXB0IGZvciBzZXJ2ZXJQcmVmZXRjaClcclxuKCFpc0luU1NSQ29tcG9uZW50U2V0dXAgfHwgbGlmZWN5Y2xlID09PSBcInNwXCIgLyogU0VSVkVSX1BSRUZFVENIICovKSAmJlxyXG4gICAgaW5qZWN0SG9vayhsaWZlY3ljbGUsIGhvb2ssIHRhcmdldCk7XHJcbmNvbnN0IG9uQmVmb3JlTW91bnQgPSBjcmVhdGVIb29rKFwiYm1cIiAvKiBCRUZPUkVfTU9VTlQgKi8pO1xyXG5jb25zdCBvbk1vdW50ZWQgPSBjcmVhdGVIb29rKFwibVwiIC8qIE1PVU5URUQgKi8pO1xyXG5jb25zdCBvbkJlZm9yZVVwZGF0ZSA9IGNyZWF0ZUhvb2soXCJidVwiIC8qIEJFRk9SRV9VUERBVEUgKi8pO1xyXG5jb25zdCBvblVwZGF0ZWQgPSBjcmVhdGVIb29rKFwidVwiIC8qIFVQREFURUQgKi8pO1xyXG5jb25zdCBvbkJlZm9yZVVubW91bnQgPSBjcmVhdGVIb29rKFwiYnVtXCIgLyogQkVGT1JFX1VOTU9VTlQgKi8pO1xyXG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUhvb2soXCJ1bVwiIC8qIFVOTU9VTlRFRCAqLyk7XHJcbmNvbnN0IG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVIb29rKFwic3BcIiAvKiBTRVJWRVJfUFJFRkVUQ0ggKi8pO1xyXG5jb25zdCBvblJlbmRlclRyaWdnZXJlZCA9IGNyZWF0ZUhvb2soXCJydGdcIiAvKiBSRU5ERVJfVFJJR0dFUkVEICovKTtcclxuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlSG9vayhcInJ0Y1wiIC8qIFJFTkRFUl9UUkFDS0VEICovKTtcclxuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgaW5qZWN0SG9vayhcImVjXCIgLyogRVJST1JfQ0FQVFVSRUQgKi8sIGhvb2ssIHRhcmdldCk7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiAodHlwZSwga2V5KSA9PiB7XHJcbiAgICAgICAgaWYgKGNhY2hlW2tleV0pIHtcclxuICAgICAgICAgICAgd2FybihgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5sZXQgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xyXG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSk7XHJcbiAgICBjb25zdCBwdWJsaWNUaGlzID0gaW5zdGFuY2UucHJveHk7XHJcbiAgICBjb25zdCBjdHggPSBpbnN0YW5jZS5jdHg7XHJcbiAgICAvLyBkbyBub3QgY2FjaGUgcHJvcGVydHkgYWNjZXNzIG9uIHB1YmxpYyBwcm94eSBkdXJpbmcgc3RhdGUgaW5pdGlhbGl6YXRpb25cclxuICAgIHNob3VsZENhY2hlQWNjZXNzID0gZmFsc2U7XHJcbiAgICAvLyBjYWxsIGJlZm9yZUNyZWF0ZSBmaXJzdCBiZWZvcmUgYWNjZXNzaW5nIG90aGVyIG9wdGlvbnMgc2luY2VcclxuICAgIC8vIHRoZSBob29rIG1heSBtdXRhdGUgcmVzb2x2ZWQgb3B0aW9ucyAoIzI3OTEpXHJcbiAgICBpZiAob3B0aW9ucy5iZWZvcmVDcmVhdGUpIHtcclxuICAgICAgICBjYWxsSG9vayhvcHRpb25zLmJlZm9yZUNyZWF0ZSwgaW5zdGFuY2UsIFwiYmNcIiAvKiBCRUZPUkVfQ1JFQVRFICovKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgXHJcbiAgICAvLyBzdGF0ZVxyXG4gICAgZGF0YTogZGF0YU9wdGlvbnMsIGNvbXB1dGVkOiBjb21wdXRlZE9wdGlvbnMsIG1ldGhvZHMsIHdhdGNoOiB3YXRjaE9wdGlvbnMsIHByb3ZpZGU6IHByb3ZpZGVPcHRpb25zLCBpbmplY3Q6IGluamVjdE9wdGlvbnMsIFxyXG4gICAgLy8gbGlmZWN5Y2xlXHJcbiAgICBjcmVhdGVkLCBiZWZvcmVNb3VudCwgbW91bnRlZCwgYmVmb3JlVXBkYXRlLCB1cGRhdGVkLCBhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkLCBiZWZvcmVEZXN0cm95LCBiZWZvcmVVbm1vdW50LCBkZXN0cm95ZWQsIHVubW91bnRlZCwgcmVuZGVyLCByZW5kZXJUcmFja2VkLCByZW5kZXJUcmlnZ2VyZWQsIGVycm9yQ2FwdHVyZWQsIHNlcnZlclByZWZldGNoLCBcclxuICAgIC8vIHB1YmxpYyBBUElcclxuICAgIGV4cG9zZSwgaW5oZXJpdEF0dHJzLCBcclxuICAgIC8vIGFzc2V0c1xyXG4gICAgY29tcG9uZW50cywgZGlyZWN0aXZlcywgZmlsdGVycyB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSA6IG51bGw7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgW3Byb3BzT3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICAgICAgaWYgKHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wc09wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIlByb3BzXCIgLyogUFJPUFMgKi8sIGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBvcHRpb25zIGluaXRpYWxpemF0aW9uIG9yZGVyICh0byBiZSBjb25zaXN0ZW50IHdpdGggVnVlIDIpOlxyXG4gICAgLy8gLSBwcm9wcyAoYWxyZWFkeSBkb25lIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbilcclxuICAgIC8vIC0gaW5qZWN0XHJcbiAgICAvLyAtIG1ldGhvZHNcclxuICAgIC8vIC0gZGF0YSAoZGVmZXJyZWQgc2luY2UgaXQgcmVsaWVzIG9uIGB0aGlzYCBhY2Nlc3MpXHJcbiAgICAvLyAtIGNvbXB1dGVkXHJcbiAgICAvLyAtIHdhdGNoIChkZWZlcnJlZCBzaW5jZSBpdCByZWxpZXMgb24gYHRoaXNgIGFjY2VzcylcclxuICAgIGlmIChpbmplY3RPcHRpb25zKSB7XHJcbiAgICAgICAgcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1ldGhvZHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZEhhbmRsZXIgPSBtZXRob2RzW2tleV07XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uJDEobWV0aG9kSGFuZGxlcikpIHtcclxuICAgICAgICAgICAgICAgIC8vIEluIGRldiBtb2RlLCB3ZSB1c2UgdGhlIGBjcmVhdGVSZW5kZXJDb250ZXh0YCBmdW5jdGlvbiB0byBkZWZpbmUgbWV0aG9kcyB0byB0aGUgcHJveHkgdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIHRob3NlIGFyZSByZWFkLW9ubHkgYnV0IHJlY29uZmlndXJhYmxlLCBzbyBpdCBuZWVkcyB0byBiZSByZWRlZmluZWQgaGVyZVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHhba2V5XSA9IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJNZXRob2RzXCIgLyogTUVUSE9EUyAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgbWV0aG9kSGFuZGxlcn1cIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P2ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGRhdGFPcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNGdW5jdGlvbiQxKGRhdGFPcHRpb25zKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBUaGUgZGF0YSBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLiBgICtcclxuICAgICAgICAgICAgICAgIGBQbGFpbiBvYmplY3QgdXNhZ2UgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGRhdGFPcHRpb25zLmNhbGwocHVibGljVGhpcywgcHVibGljVGhpcyk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc1Byb21pc2UkMShkYXRhKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBkYXRhKCkgcmV0dXJuZWQgYSBQcm9taXNlIC0gbm90ZSBkYXRhKCkgY2Fubm90IGJlIGFzeW5jOyBJZiB5b3UgYCArXHJcbiAgICAgICAgICAgICAgICBgaW50ZW5kIHRvIHBlcmZvcm0gZGF0YSBmZXRjaGluZyBiZWZvcmUgY29tcG9uZW50IHJlbmRlcnMsIHVzZSBgICtcclxuICAgICAgICAgICAgICAgIGBhc3luYyBzZXR1cCgpICsgPFN1c3BlbnNlPi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc09iamVjdCQxKGRhdGEpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBkYXRhKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5kYXRhID0gcmVhY3RpdmUoZGF0YSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJEYXRhXCIgLyogREFUQSAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBleHBvc2UgZGF0YSBvbiBjdHggZHVyaW5nIGRldlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gIT09ICckJyAmJiBrZXlbMF0gIT09ICdfJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGRhdGFba2V5XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldDogTk9PUFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBzdGF0ZSBpbml0aWFsaXphdGlvbiBjb21wbGV0ZSBhdCB0aGlzIHBvaW50IC0gc3RhcnQgY2FjaGluZyBhY2Nlc3NcclxuICAgIHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcclxuICAgIGlmIChjb21wdXRlZE9wdGlvbnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0ID0gY29tcHV0ZWRPcHRpb25zW2tleV07XHJcbiAgICAgICAgICAgIGNvbnN0IGdldCA9IGlzRnVuY3Rpb24kMShvcHQpXHJcbiAgICAgICAgICAgICAgICA/IG9wdC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IGlzRnVuY3Rpb24kMShvcHQuZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgID8gb3B0LmdldC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBOT09QO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGdldCA9PT0gTk9PUCkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgQ29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBoYXMgbm8gZ2V0dGVyLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNldCA9ICFpc0Z1bmN0aW9uJDEob3B0KSAmJiBpc0Z1bmN0aW9uJDEob3B0LnNldClcclxuICAgICAgICAgICAgICAgID8gb3B0LnNldC5iaW5kKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgICAgID8gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIHJlYWRvbmx5LmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA6IE5PT1A7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjb21wdXRlZCh7XHJcbiAgICAgICAgICAgICAgICBnZXQsXHJcbiAgICAgICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gYy52YWx1ZSxcclxuICAgICAgICAgICAgICAgIHNldDogdiA9PiAoYy52YWx1ZSA9IHYpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJDb21wdXRlZFwiIC8qIENPTVBVVEVEICovLCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHdhdGNoT3B0aW9ucykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHdhdGNoT3B0aW9ucykge1xyXG4gICAgICAgICAgICBjcmVhdGVXYXRjaGVyKHdhdGNoT3B0aW9uc1trZXldLCBjdHgsIHB1YmxpY1RoaXMsIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHByb3ZpZGVPcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXMgPSBpc0Z1bmN0aW9uJDEocHJvdmlkZU9wdGlvbnMpXHJcbiAgICAgICAgICAgID8gcHJvdmlkZU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICA6IHByb3ZpZGVPcHRpb25zO1xyXG4gICAgICAgIFJlZmxlY3Qub3duS2V5cyhwcm92aWRlcykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBwcm92aWRlKGtleSwgcHJvdmlkZXNba2V5XSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY3JlYXRlZCkge1xyXG4gICAgICAgIGNhbGxIb29rKGNyZWF0ZWQsIGluc3RhbmNlLCBcImNcIiAvKiBDUkVBVEVEICovKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhyZWdpc3RlciwgaG9vaykge1xyXG4gICAgICAgIGlmIChpc0FycmF5KGhvb2spKSB7XHJcbiAgICAgICAgICAgIGhvb2suZm9yRWFjaChfaG9vayA9PiByZWdpc3RlcihfaG9vay5iaW5kKHB1YmxpY1RoaXMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhvb2spIHtcclxuICAgICAgICAgICAgcmVnaXN0ZXIoaG9vay5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVNb3VudCwgYmVmb3JlTW91bnQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uTW91bnRlZCwgbW91bnRlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVcGRhdGUsIGJlZm9yZVVwZGF0ZSk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25VcGRhdGVkLCB1cGRhdGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkFjdGl2YXRlZCwgYWN0aXZhdGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkRlYWN0aXZhdGVkLCBkZWFjdGl2YXRlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25FcnJvckNhcHR1cmVkLCBlcnJvckNhcHR1cmVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyYWNrZWQsIHJlbmRlclRyYWNrZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJpZ2dlcmVkLCByZW5kZXJUcmlnZ2VyZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVW5tb3VudCwgYmVmb3JlVW5tb3VudCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Vbm1vdW50ZWQsIHVubW91bnRlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25TZXJ2ZXJQcmVmZXRjaCwgc2VydmVyUHJlZmV0Y2gpO1xyXG4gICAgaWYgKGlzQXJyYXkoZXhwb3NlKSkge1xyXG4gICAgICAgIGlmIChleHBvc2UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cG9zZWQgPSBpbnN0YW5jZS5leHBvc2VkIHx8IChpbnN0YW5jZS5leHBvc2VkID0ge30pO1xyXG4gICAgICAgICAgICBleHBvc2UuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9zZWQsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gcHVibGljVGhpc1trZXldLFxyXG4gICAgICAgICAgICAgICAgICAgIHNldDogdmFsID0+IChwdWJsaWNUaGlzW2tleV0gPSB2YWwpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFpbnN0YW5jZS5leHBvc2VkKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmV4cG9zZWQgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBvcHRpb25zIHRoYXQgYXJlIGhhbmRsZWQgd2hlbiBjcmVhdGluZyB0aGUgaW5zdGFuY2UgYnV0IGFsc28gbmVlZCB0byBiZVxyXG4gICAgLy8gYXBwbGllZCBmcm9tIG1peGluc1xyXG4gICAgaWYgKHJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1ApIHtcclxuICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSByZW5kZXI7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5oZXJpdEF0dHJzICE9IG51bGwpIHtcclxuICAgICAgICBpbnN0YW5jZS5pbmhlcml0QXR0cnMgPSBpbmhlcml0QXR0cnM7XHJcbiAgICB9XHJcbiAgICAvLyBhc3NldCBvcHRpb25zLlxyXG4gICAgaWYgKGNvbXBvbmVudHMpXHJcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XHJcbiAgICBpZiAoZGlyZWN0aXZlcylcclxuICAgICAgICBpbnN0YW5jZS5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9IE5PT1ApIHtcclxuICAgIGlmIChpc0FycmF5KGluamVjdE9wdGlvbnMpKSB7XHJcbiAgICAgICAgaW5qZWN0T3B0aW9ucyA9IG5vcm1hbGl6ZUluamVjdChpbmplY3RPcHRpb25zKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIGluamVjdE9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0JDEob3B0KSkge1xyXG4gICAgICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIG9wdCkge1xyXG4gICAgICAgICAgICAgICAgY3R4W2tleV0gPSBpbmplY3Qob3B0LmZyb20gfHwga2V5LCBvcHQuZGVmYXVsdCwgdHJ1ZSAvKiB0cmVhdCBkZWZhdWx0IGZ1bmN0aW9uIGFzIGZhY3RvcnkgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3R4W2tleV0gPSBpbmplY3Qob3B0LmZyb20gfHwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3R4W2tleV0gPSBpbmplY3Qob3B0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJJbmplY3RcIiAvKiBJTkpFQ1QgKi8sIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNhbGxIb29rKGhvb2ssIGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhpc0FycmF5KGhvb2spXHJcbiAgICAgICAgPyBob29rLm1hcChoID0+IGguYmluZChpbnN0YW5jZS5wcm94eSkpXHJcbiAgICAgICAgOiBob29rLmJpbmQoaW5zdGFuY2UucHJveHkpLCBpbnN0YW5jZSwgdHlwZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcihyYXcsIGN0eCwgcHVibGljVGhpcywga2V5KSB7XHJcbiAgICBjb25zdCBnZXR0ZXIgPSBrZXkuaW5jbHVkZXMoJy4nKVxyXG4gICAgICAgID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBrZXkpXHJcbiAgICAgICAgOiAoKSA9PiBwdWJsaWNUaGlzW2tleV07XHJcbiAgICBpZiAoaXNTdHJpbmcocmF3KSkge1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBjdHhbcmF3XTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbiQxKGhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3fVwiYCwgaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbiQxKHJhdykpIHtcclxuICAgICAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0JDEocmF3KSkge1xyXG4gICAgICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgICAgICAgcmF3LmZvckVhY2gociA9PiBjcmVhdGVXYXRjaGVyKHIsIGN0eCwgcHVibGljVGhpcywga2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaXNGdW5jdGlvbiQxKHJhdy5oYW5kbGVyKVxyXG4gICAgICAgICAgICAgICAgPyByYXcuaGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICA6IGN0eFtyYXcuaGFuZGxlcl07XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uJDEoaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlciwgcmF3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXcuaGFuZGxlcn1cImAsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtrZXl9XCJgLCByYXcpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXNvbHZlIG1lcmdlZCBvcHRpb25zIGFuZCBjYWNoZSBpdCBvbiB0aGUgY29tcG9uZW50LlxyXG4gKiBUaGlzIGlzIGRvbmUgb25seSBvbmNlIHBlci1jb21wb25lbnQgc2luY2UgdGhlIG1lcmdpbmcgZG9lcyBub3QgaW52b2x2ZVxyXG4gKiBpbnN0YW5jZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgYmFzZSA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGJhc2U7XHJcbiAgICBjb25zdCB7IG1peGluczogZ2xvYmFsTWl4aW5zLCBvcHRpb25zQ2FjaGU6IGNhY2hlLCBjb25maWc6IHsgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzIH0gfSA9IGluc3RhbmNlLmFwcENvbnRleHQ7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoYmFzZSk7XHJcbiAgICBsZXQgcmVzb2x2ZWQ7XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgcmVzb2x2ZWQgPSBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucykge1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVzb2x2ZWQgPSBiYXNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc29sdmVkID0ge307XHJcbiAgICAgICAgaWYgKGdsb2JhbE1peGlucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZ2xvYmFsTWl4aW5zLmZvckVhY2gobSA9PiBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIG0sIG9wdGlvbk1lcmdlU3RyYXRlZ2llcywgdHJ1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIGJhc2UsIG9wdGlvbk1lcmdlU3RyYXRlZ2llcyk7XHJcbiAgICB9XHJcbiAgICBjYWNoZS5zZXQoYmFzZSwgcmVzb2x2ZWQpO1xyXG4gICAgcmV0dXJuIHJlc29sdmVkO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyh0bywgZnJvbSwgc3RyYXRzLCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gZnJvbTtcclxuICAgIGlmIChleHRlbmRzT3B0aW9ucykge1xyXG4gICAgICAgIG1lcmdlT3B0aW9ucyh0bywgZXh0ZW5kc09wdGlvbnMsIHN0cmF0cywgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAobWl4aW5zKSB7XHJcbiAgICAgICAgbWl4aW5zLmZvckVhY2goKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgc3RyYXRzLCB0cnVlKSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XHJcbiAgICAgICAgaWYgKGFzTWl4aW4gJiYga2V5ID09PSAnZXhwb3NlJykge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYFwiZXhwb3NlXCIgb3B0aW9uIGlzIGlnbm9yZWQgd2hlbiBkZWNsYXJlZCBpbiBtaXhpbnMgb3IgZXh0ZW5kcy4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYEl0IHNob3VsZCBvbmx5IGJlIGRlY2xhcmVkIGluIHRoZSBiYXNlIGNvbXBvbmVudCBpdHNlbGYuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzdHJhdCA9IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHNba2V5XSB8fCAoc3RyYXRzICYmIHN0cmF0c1trZXldKTtcclxuICAgICAgICAgICAgdG9ba2V5XSA9IHN0cmF0ID8gc3RyYXQodG9ba2V5XSwgZnJvbVtrZXldKSA6IGZyb21ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG87XHJcbn1cclxuY29uc3QgaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0cyA9IHtcclxuICAgIGRhdGE6IG1lcmdlRGF0YUZuLFxyXG4gICAgcHJvcHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIGVtaXRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICAvLyBvYmplY3RzXHJcbiAgICBtZXRob2RzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICBjb21wdXRlZDogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgLy8gbGlmZWN5Y2xlXHJcbiAgICBiZWZvcmVDcmVhdGU6IG1lcmdlQXNBcnJheSxcclxuICAgIGNyZWF0ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGJlZm9yZU1vdW50OiBtZXJnZUFzQXJyYXksXHJcbiAgICBtb3VudGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBiZWZvcmVVcGRhdGU6IG1lcmdlQXNBcnJheSxcclxuICAgIHVwZGF0ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGJlZm9yZURlc3Ryb3k6IG1lcmdlQXNBcnJheSxcclxuICAgIGRlc3Ryb3llZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICBkZWFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgZXJyb3JDYXB0dXJlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgc2VydmVyUHJlZmV0Y2g6IG1lcmdlQXNBcnJheSxcclxuICAgIC8vIGFzc2V0c1xyXG4gICAgY29tcG9uZW50czogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgZGlyZWN0aXZlczogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgLy8gd2F0Y2hcclxuICAgIHdhdGNoOiBtZXJnZVdhdGNoT3B0aW9ucyxcclxuICAgIC8vIHByb3ZpZGUgLyBpbmplY3RcclxuICAgIHByb3ZpZGU6IG1lcmdlRGF0YUZuLFxyXG4gICAgaW5qZWN0OiBtZXJnZUluamVjdFxyXG59O1xyXG5mdW5jdGlvbiBtZXJnZURhdGFGbih0bywgZnJvbSkge1xyXG4gICAgaWYgKCFmcm9tKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0bykge1xyXG4gICAgICAgIHJldHVybiBmcm9tO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbigpIHtcclxuICAgICAgICByZXR1cm4gKGV4dGVuZCkoaXNGdW5jdGlvbiQxKHRvKSA/IHRvLmNhbGwodGhpcywgdGhpcykgOiB0bywgaXNGdW5jdGlvbiQxKGZyb20pID8gZnJvbS5jYWxsKHRoaXMsIHRoaXMpIDogZnJvbSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlSW5qZWN0KHRvLCBmcm9tKSB7XHJcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RPcHRpb25zKG5vcm1hbGl6ZUluamVjdCh0byksIG5vcm1hbGl6ZUluamVjdChmcm9tKSk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0KHJhdykge1xyXG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc1tyYXdbaV1dID0gcmF3W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJhdztcclxufVxyXG5mdW5jdGlvbiBtZXJnZUFzQXJyYXkodG8sIGZyb20pIHtcclxuICAgIHJldHVybiB0byA/IFsuLi5uZXcgU2V0KFtdLmNvbmNhdCh0bywgZnJvbSkpXSA6IGZyb207XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VPYmplY3RPcHRpb25zKHRvLCBmcm9tKSB7XHJcbiAgICByZXR1cm4gdG8gPyBleHRlbmQoZXh0ZW5kKE9iamVjdC5jcmVhdGUobnVsbCksIHRvKSwgZnJvbSkgOiBmcm9tO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlV2F0Y2hPcHRpb25zKHRvLCBmcm9tKSB7XHJcbiAgICBpZiAoIXRvKVxyXG4gICAgICAgIHJldHVybiBmcm9tO1xyXG4gICAgaWYgKCFmcm9tKVxyXG4gICAgICAgIHJldHVybiB0bztcclxuICAgIGNvbnN0IG1lcmdlZCA9IGV4dGVuZChPYmplY3QuY3JlYXRlKG51bGwpLCB0byk7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XHJcbiAgICAgICAgbWVyZ2VkW2tleV0gPSBtZXJnZUFzQXJyYXkodG9ba2V5XSwgZnJvbVtrZXldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtZXJnZWQ7XHJcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgaXNTdGF0ZWZ1bCwgLy8gcmVzdWx0IG9mIGJpdHdpc2UgZmxhZyBjb21wYXJpc29uXHJcbmlzU1NSID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHByb3BzID0ge307XHJcbiAgICBjb25zdCBhdHRycyA9IHt9O1xyXG4gICAgZGVmKGF0dHJzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XHJcbiAgICBpbnN0YW5jZS5wcm9wc0RlZmF1bHRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycyk7XHJcbiAgICAvLyBlbnN1cmUgYWxsIGRlY2xhcmVkIHByb3Aga2V5cyBhcmUgcHJlc2VudFxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xyXG4gICAgICAgICAgICBwcm9wc1trZXldID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHZhbGlkYXRpb25cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU3RhdGVmdWwpIHtcclxuICAgICAgICAvLyBzdGF0ZWZ1bFxyXG4gICAgICAgIGluc3RhbmNlLnByb3BzID0gaXNTU1IgPyBwcm9wcyA6IHNoYWxsb3dSZWFjdGl2ZShwcm9wcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoIWluc3RhbmNlLnR5cGUucHJvcHMpIHtcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbCB3LyBvcHRpb25hbCBwcm9wcywgcHJvcHMgPT09IGF0dHJzXHJcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gYXR0cnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBmdW5jdGlvbmFsIHcvIGRlY2xhcmVkIHByb3BzXHJcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gcHJvcHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW5zdGFuY2UuYXR0cnMgPSBhdHRycztcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHJhd1ByZXZQcm9wcywgb3B0aW1pemVkKSB7XHJcbiAgICBjb25zdCB7IHByb3BzLCBhdHRycywgdm5vZGU6IHsgcGF0Y2hGbGFnIH0gfSA9IGluc3RhbmNlO1xyXG4gICAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgY29uc3QgW29wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xyXG4gICAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgaWYgKFxyXG4gICAgLy8gYWx3YXlzIGZvcmNlIGZ1bGwgZGlmZiBpbiBkZXZcclxuICAgIC8vIC0gIzE5NDIgaWYgaG1yIGlzIGVuYWJsZWQgd2l0aCBzZmMgY29tcG9uZW50XHJcbiAgICAvLyAtIHZpdGUjODcyIG5vbi1zZmMgY29tcG9uZW50IHVzZWQgYnkgc2ZjIGNvbXBvbmVudFxyXG4gICAgISgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAoaW5zdGFuY2UudHlwZS5fX2htcklkIHx8XHJcbiAgICAgICAgICAgIChpbnN0YW5jZS5wYXJlbnQgJiYgaW5zdGFuY2UucGFyZW50LnR5cGUuX19obXJJZCkpKSAmJlxyXG4gICAgICAgIChvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnID4gMCkgJiZcclxuICAgICAgICAhKHBhdGNoRmxhZyAmIDE2IC8qIEZVTExfUFJPUFMgKi8pKSB7XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDggLyogUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgLy8gQ29tcGlsZXItZ2VuZXJhdGVkIHByb3BzICYgbm8ga2V5cyBjaGFuZ2UsIGp1c3Qgc2V0IHRoZSB1cGRhdGVkXHJcbiAgICAgICAgICAgIC8vIHRoZSBwcm9wcy5cclxuICAgICAgICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IGluc3RhbmNlLnZub2RlLmR5bmFtaWNQcm9wcztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcclxuICAgICAgICAgICAgICAgIC8vIFBST1BTIGZsYWcgZ3VhcmFudGVlcyByYXdQcm9wcyB0byBiZSBub24tbnVsbFxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhdHRyIC8gcHJvcHMgc2VwYXJhdGlvbiB3YXMgZG9uZSBvbiBpbml0IGFuZCB3aWxsIGJlIGNvbnNpc3RlbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIGNvZGUgcGF0aCwgc28ganVzdCBjaGVjayBpZiBhdHRycyBoYXZlIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24oYXR0cnMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1tjYW1lbGl6ZWRLZXldID0gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCByYXdDdXJyZW50UHJvcHMsIGNhbWVsaXplZEtleSwgdmFsdWUsIGluc3RhbmNlLCBmYWxzZSAvKiBpc0Fic2VudCAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBmdWxsIHByb3BzIHVwZGF0ZS5cclxuICAgICAgICBpZiAoc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSkge1xyXG4gICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbiBjYXNlIG9mIGR5bmFtaWMgcHJvcHMsIGNoZWNrIGlmIHdlIG5lZWQgdG8gZGVsZXRlIGtleXMgZnJvbVxyXG4gICAgICAgIC8vIHRoZSBwcm9wcyBvYmplY3RcclxuICAgICAgICBsZXQga2ViYWJLZXk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmF3Q3VycmVudFByb3BzKSB7XHJcbiAgICAgICAgICAgIGlmICghcmF3UHJvcHMgfHxcclxuICAgICAgICAgICAgICAgIC8vIGZvciBjYW1lbENhc2VcclxuICAgICAgICAgICAgICAgICghaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGUgb3JpZ2luYWwgcHJvcHMgd2FzIHBhc3NlZCBpbiBhcyBrZWJhYi1jYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXHJcbiAgICAgICAgICAgICAgICAgICAgKChrZWJhYktleSA9IGh5cGhlbmF0ZShrZXkpKSA9PT0ga2V5IHx8ICFoYXNPd24ocmF3UHJvcHMsIGtlYmFiS2V5KSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGNhbWVsQ2FzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocmF3UHJldlByb3BzW2tleV0gIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGtlYmFiLWNhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1ByZXZQcm9wc1trZWJhYktleV0gIT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBrZXksIHVuZGVmaW5lZCwgaW5zdGFuY2UsIHRydWUgLyogaXNBYnNlbnQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIGZ1bmN0aW9uYWwgY29tcG9uZW50IHcvbyBwcm9wcyBkZWNsYXJhdGlvbiwgcHJvcHMgYW5kXHJcbiAgICAgICAgLy8gYXR0cnMgcG9pbnQgdG8gdGhlIHNhbWUgb2JqZWN0IHNvIGl0IHNob3VsZCBhbHJlYWR5IGhhdmUgYmVlbiB1cGRhdGVkLlxyXG4gICAgICAgIGlmIChhdHRycyAhPT0gcmF3Q3VycmVudFByb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJhd1Byb3BzIHx8ICFoYXNPd24ocmF3UHJvcHMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdHJpZ2dlciB1cGRhdGVzIGZvciAkYXR0cnMgaW4gY2FzZSBpdCdzIHVzZWQgaW4gY29tcG9uZW50IHNsb3RzXHJcbiAgICBpZiAoaGFzQXR0cnNDaGFuZ2VkKSB7XHJcbiAgICAgICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiAvKiBTRVQgKi8sICckYXR0cnMnKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykge1xyXG4gICAgY29uc3QgW29wdGlvbnMsIG5lZWRDYXN0S2V5c10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICBsZXQgcmF3Q2FzdFZhbHVlcztcclxuICAgIGlmIChyYXdQcm9wcykge1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiByYXdQcm9wcykge1xyXG4gICAgICAgICAgICAvLyBrZXksIHJlZiBhcmUgcmVzZXJ2ZWQgYW5kIG5ldmVyIHBhc3NlZCBkb3duXHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgIC8vIHByb3Agb3B0aW9uIG5hbWVzIGFyZSBjYW1lbGl6ZWQgZHVyaW5nIG5vcm1hbGl6YXRpb24sIHNvIHRvIHN1cHBvcnRcclxuICAgICAgICAgICAgLy8ga2ViYWIgLT4gY2FtZWwgY29udmVyc2lvbiBoZXJlIHdlIG5lZWQgdG8gY2FtZWxpemUgdGhlIGtleS5cclxuICAgICAgICAgICAgbGV0IGNhbWVsS2V5O1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgKGNhbWVsS2V5ID0gY2FtZWxpemUoa2V5KSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRDYXN0S2V5cyB8fCAhbmVlZENhc3RLZXlzLmluY2x1ZGVzKGNhbWVsS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzW2NhbWVsS2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKHJhd0Nhc3RWYWx1ZXMgfHwgKHJhd0Nhc3RWYWx1ZXMgPSB7fSkpW2NhbWVsS2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5lZWRDYXN0S2V5cykge1xyXG4gICAgICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICBjb25zdCBjYXN0VmFsdWVzID0gcmF3Q2FzdFZhbHVlcyB8fCBFTVBUWV9PQko7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkQ2FzdEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmVlZENhc3RLZXlzW2ldO1xyXG4gICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCByYXdDdXJyZW50UHJvcHMsIGtleSwgY2FzdFZhbHVlc1trZXldLCBpbnN0YW5jZSwgIWhhc093bihjYXN0VmFsdWVzLCBrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzQXR0cnNDaGFuZ2VkO1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcHJvcHMsIGtleSwgdmFsdWUsIGluc3RhbmNlLCBpc0Fic2VudCkge1xyXG4gICAgY29uc3Qgb3B0ID0gb3B0aW9uc1trZXldO1xyXG4gICAgaWYgKG9wdCAhPSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHQsICdkZWZhdWx0Jyk7XHJcbiAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZXNcclxuICAgICAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG9wdC5kZWZhdWx0O1xyXG4gICAgICAgICAgICBpZiAob3B0LnR5cGUgIT09IEZ1bmN0aW9uICYmIGlzRnVuY3Rpb24kMShkZWZhdWx0VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzRGVmYXVsdHMgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiBwcm9wc0RlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldID0gZGVmYXVsdFZhbHVlLmNhbGwobnVsbCwgcHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJvb2xlYW4gY2FzdGluZ1xyXG4gICAgICAgIGlmIChvcHRbMCAvKiBzaG91bGRDYXN0ICovXSkge1xyXG4gICAgICAgICAgICBpZiAoaXNBYnNlbnQgJiYgIWhhc0RlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0WzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dICYmXHJcbiAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQucHJvcHNDYWNoZTtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcclxuICAgIGNvbnN0IG5lZWRDYXN0S2V5cyA9IFtdO1xyXG4gICAgLy8gYXBwbHkgbWl4aW4vZXh0ZW5kcyBwcm9wc1xyXG4gICAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcclxuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uJDEoY29tcCkpIHtcclxuICAgICAgICBjb25zdCBleHRlbmRQcm9wcyA9IChyYXcpID0+IHtcclxuICAgICAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IFtwcm9wcywga2V5c10gPSBub3JtYWxpemVQcm9wc09wdGlvbnMocmF3LCBhcHBDb250ZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHByb3BzKTtcclxuICAgICAgICAgICAgaWYgKGtleXMpXHJcbiAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaCguLi5rZXlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLmV4dGVuZHMpIHtcclxuICAgICAgICAgICAgZXh0ZW5kUHJvcHMoY29tcC5leHRlbmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAubWl4aW5zKSB7XHJcbiAgICAgICAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XHJcbiAgICAgICAgY2FjaGUuc2V0KGNvbXAsIEVNUFRZX0FSUik7XHJcbiAgICAgICAgcmV0dXJuIEVNUFRZX0FSUjtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1N0cmluZyhyYXdbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguYCwgcmF3W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUocmF3W2ldKTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBFTVBUWV9PQko7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyYXcpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc09iamVjdCQxKHJhdykpIHtcclxuICAgICAgICAgICAgd2FybihgaW52YWxpZCBwcm9wcyBvcHRpb25zYCwgcmF3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmF3KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xyXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0ID0gcmF3W2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gKG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIGlzQXJyYXkob3B0KSB8fCBpc0Z1bmN0aW9uJDEob3B0KSA/IHsgdHlwZTogb3B0IH0gOiBvcHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcFswIC8qIHNob3VsZENhc3QgKi9dID0gYm9vbGVhbkluZGV4ID4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcFsxIC8qIHNob3VsZENhc3RUcnVlICovXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJvcCBuZWVkcyBib29sZWFuIGNhc3Rpbmcgb3IgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib29sZWFuSW5kZXggPiAtMSB8fCBoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXMgPSBbbm9ybWFsaXplZCwgbmVlZENhc3RLZXlzXTtcclxuICAgIGNhY2hlLnNldChjb21wLCByZXMpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xyXG4gICAgaWYgKGtleVswXSAhPT0gJyQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBJbnZhbGlkIHByb3AgbmFtZTogXCIke2tleX1cIiBpcyBhIHJlc2VydmVkIHByb3BlcnR5LmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8vIHVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayB0eXBlIGNvbnN0cnVjdG9yc1xyXG4vLyBzbyB0aGF0IGl0IHdvcmtzIGFjcm9zcyB2bXMgLyBpZnJhbWVzLlxyXG5mdW5jdGlvbiBnZXRUeXBlKGN0b3IpIHtcclxuICAgIGNvbnN0IG1hdGNoID0gY3RvciAmJiBjdG9yLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XHJcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FtZVR5cGUoYSwgYikge1xyXG4gICAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4KHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcclxuICAgIGlmIChpc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkVHlwZXMuZmluZEluZGV4KHQgPT4gaXNTYW1lVHlwZSh0LCB0eXBlKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uJDEoZXhwZWN0ZWRUeXBlcykpIHtcclxuICAgICAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMTtcclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMsIHByb3BzLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgcmVzb2x2ZWRWYWx1ZXMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICBjb25zdCBvcHRpb25zID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xyXG4gICAgICAgIGxldCBvcHQgPSBvcHRpb25zW2tleV07XHJcbiAgICAgICAgaWYgKG9wdCA9PSBudWxsKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB2YWxpZGF0ZVByb3Aoa2V5LCByZXNvbHZlZFZhbHVlc1trZXldLCBvcHQsICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgIWhhc093bihyYXdQcm9wcywgaHlwaGVuYXRlKGtleSkpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcChuYW1lLCB2YWx1ZSwgcHJvcCwgaXNBYnNlbnQpIHtcclxuICAgIGNvbnN0IHsgdHlwZSwgcmVxdWlyZWQsIHZhbGlkYXRvciB9ID0gcHJvcDtcclxuICAgIC8vIHJlcXVpcmVkIVxyXG4gICAgaWYgKHJlcXVpcmVkICYmIGlzQWJzZW50KSB7XHJcbiAgICAgICAgd2FybignTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gbWlzc2luZyBidXQgb3B0aW9uYWxcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gdHlwZSBjaGVja1xyXG4gICAgaWYgKHR5cGUgIT0gbnVsbCAmJiB0eXBlICE9PSB0cnVlKSB7XHJcbiAgICAgICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB0eXBlcyA9IGlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcclxuICAgICAgICAvLyB2YWx1ZSBpcyB2YWxpZCBhcyBsb25nIGFzIG9uZSBvZiB0aGUgc3BlY2lmaWVkIHR5cGVzIG1hdGNoXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGggJiYgIWlzVmFsaWQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB7IHZhbGlkLCBleHBlY3RlZFR5cGUgfSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVzW2ldKTtcclxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGV4cGVjdGVkVHlwZSB8fCAnJyk7XHJcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWxpZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBjdXN0b20gdmFsaWRhdG9yXHJcbiAgICBpZiAodmFsaWRhdG9yICYmICF2YWxpZGF0b3IodmFsdWUpKSB7XHJcbiAgICAgICAgd2FybignSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGlzU2ltcGxlVHlwZSA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnU3RyaW5nLE51bWJlcixCb29sZWFuLEZ1bmN0aW9uLFN5bWJvbCxCaWdJbnQnKTtcclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XHJcbiAgICBsZXQgdmFsaWQ7XHJcbiAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xyXG4gICAgaWYgKGlzU2ltcGxlVHlwZShleHBlY3RlZFR5cGUpKSB7XHJcbiAgICAgICAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcclxuICAgICAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXHJcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XHJcbiAgICAgICAgdmFsaWQgPSBpc09iamVjdCQxKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xyXG4gICAgICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsaWQsXHJcbiAgICAgICAgZXhwZWN0ZWRUeXBlXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJHtuYW1lfVwiLmAgK1xyXG4gICAgICAgIGAgRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpfWA7XHJcbiAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xyXG4gICAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcclxuICAgIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xyXG4gICAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XHJcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcclxuICAgIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXHJcbiAgICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcclxuICAgICAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke2V4cGVjdGVkVmFsdWV9YDtcclxuICAgIH1cclxuICAgIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xyXG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXHJcbiAgICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcclxuICAgICAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7cmVjZWl2ZWRWYWx1ZX0uYDtcclxuICAgIH1cclxuICAgIHJldHVybiBtZXNzYWdlO1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xyXG4gICAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gYCR7TnVtYmVyKHZhbHVlKX1gO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlfWA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUodHlwZSkge1xyXG4gICAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XHJcbiAgICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGVsZW0gPT4gdHlwZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtKTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGlzQm9vbGVhbiguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gYXJncy5zb21lKGVsZW0gPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbicpO1xyXG59XG5cbmNvbnN0IGlzSW50ZXJuYWxLZXkgPSAoa2V5KSA9PiBrZXlbMF0gPT09ICdfJyB8fCBrZXkgPT09ICckc3RhYmxlJztcclxuY29uc3Qgbm9ybWFsaXplU2xvdFZhbHVlID0gKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKVxyXG4gICAgPyB2YWx1ZS5tYXAobm9ybWFsaXplVk5vZGUpXHJcbiAgICA6IFtub3JtYWxpemVWTm9kZSh2YWx1ZSldO1xyXG5jb25zdCBub3JtYWxpemVTbG90ID0gKGtleSwgcmF3U2xvdCwgY3R4KSA9PiB7XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0gd2l0aEN0eCgocHJvcHMpID0+IHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB3YXJuKGBTbG90IFwiJHtrZXl9XCIgaW52b2tlZCBvdXRzaWRlIG9mIHRoZSByZW5kZXIgZnVuY3Rpb246IGAgK1xyXG4gICAgICAgICAgICAgICAgYHRoaXMgd2lsbCBub3QgdHJhY2sgZGVwZW5kZW5jaWVzIHVzZWQgaW4gdGhlIHNsb3QuIGAgK1xyXG4gICAgICAgICAgICAgICAgYEludm9rZSB0aGUgc2xvdCBmdW5jdGlvbiBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9ybWFsaXplU2xvdFZhbHVlKHJhd1Nsb3QocHJvcHMpKTtcclxuICAgIH0sIGN0eCk7XHJcbiAgICBub3JtYWxpemVkLl9jID0gZmFsc2U7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxufTtcclxuY29uc3Qgbm9ybWFsaXplT2JqZWN0U2xvdHMgPSAocmF3U2xvdHMsIHNsb3RzLCBpbnN0YW5jZSkgPT4ge1xyXG4gICAgY29uc3QgY3R4ID0gcmF3U2xvdHMuX2N0eDtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Nsb3RzKSB7XHJcbiAgICAgICAgaWYgKGlzSW50ZXJuYWxLZXkoa2V5KSlcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSByYXdTbG90c1trZXldO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uJDEodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHNsb3RzW2tleV0gPSBub3JtYWxpemVTbG90KGtleSwgdmFsdWUsIGN0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgIShmYWxzZSApKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIHNsb3QgXCIke2tleX1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICBzbG90c1trZXldID0gKCkgPT4gbm9ybWFsaXplZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IG5vcm1hbGl6ZVZOb2RlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgIWlzS2VlcEFsaXZlKGluc3RhbmNlLnZub2RlKSAmJlxyXG4gICAgICAgICEoZmFsc2UgKSkge1xyXG4gICAgICAgIHdhcm4oYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3IgZGVmYXVsdCBzbG90LiBgICtcclxuICAgICAgICAgICAgYFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZShjaGlsZHJlbik7XHJcbiAgICBpbnN0YW5jZS5zbG90cy5kZWZhdWx0ID0gKCkgPT4gbm9ybWFsaXplZDtcclxufTtcclxuY29uc3QgaW5pdFNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xyXG4gICAgaWYgKGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNMT1RTX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgLy8gdXNlcnMgY2FuIGdldCB0aGUgc2hhbGxvdyByZWFkb25seSB2ZXJzaW9uIG9mIHRoZSBzbG90cyBvYmplY3QgdGhyb3VnaCBgdGhpcy4kc2xvdHNgLFxyXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgYXZvaWQgdGhlIHByb3h5IG9iamVjdCBwb2xsdXRpbmcgdGhlIHNsb3RzIG9mIHRoZSBpbnRlcm5hbCBpbnN0YW5jZVxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zbG90cyA9IHRvUmF3KGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgLy8gbWFrZSBjb21waWxlciBtYXJrZXIgbm9uLWVudW1lcmFibGVcclxuICAgICAgICAgICAgZGVmKGNoaWxkcmVuLCAnXycsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIChpbnN0YW5jZS5zbG90cyA9IHt9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaW5zdGFuY2Uuc2xvdHMgPSB7fTtcclxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplVk5vZGVTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlZihpbnN0YW5jZS5zbG90cywgSW50ZXJuYWxPYmplY3RLZXksIDEpO1xyXG59O1xyXG5jb25zdCB1cGRhdGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xyXG4gICAgY29uc3QgeyB2bm9kZSwgc2xvdHMgfSA9IGluc3RhbmNlO1xyXG4gICAgbGV0IG5lZWREZWxldGlvbkNoZWNrID0gdHJ1ZTtcclxuICAgIGxldCBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBFTVBUWV9PQko7XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMzIgLyogU0xPVFNfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcclxuICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAvLyBjb21waWxlZCBzbG90cy5cclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBQYXJlbnQgd2FzIEhNUiB1cGRhdGVkIHNvIHNsb3QgY29udGVudCBtYXkgaGF2ZSBjaGFuZ2VkLlxyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgdXBkYXRlIHNsb3RzIGFuZCBtYXJrIGluc3RhbmNlIGZvciBobXIgYXMgd2VsbFxyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKHNsb3RzLCBjaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW1pemVkICYmIHR5cGUgPT09IDEgLyogU1RBQkxFICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlZCBBTkQgc3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byB1cGRhdGUsIGFuZCBza2lwIHN0YWxlIHNsb3RzIHJlbW92YWwuXHJcbiAgICAgICAgICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZWQgYnV0IGR5bmFtaWMgKHYtaWYvdi1mb3Igb24gc2xvdHMpIC0gdXBkYXRlIHNsb3RzLCBidXQgc2tpcFxyXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICAgIGV4dGVuZChzbG90cywgY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgLy8gIzI4OTNcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gcmVuZGVyaW5nIHRoZSBvcHRpbWl6ZWQgc2xvdHMgYnkgbWFudWFsbHkgd3JpdHRlbiByZW5kZXIgZnVuY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGUgYHNsb3RzLl9gIGZsYWcgaWYgbmVjZXNzYXJ5IHRvIG1ha2Ugc3Vic2VxdWVudCB1cGRhdGVzIHJlbGlhYmxlLFxyXG4gICAgICAgICAgICAgICAgLy8gaS5lLiBsZXQgdGhlIGByZW5kZXJTbG90YCBjcmVhdGUgdGhlIGJhaWxlZCBGcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSAvKiBTVEFCTEUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2xvdHMuXztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSAhY2hpbGRyZW4uJHN0YWJsZTtcclxuICAgICAgICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIHNsb3RzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gY2hpbGRyZW47XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgIC8vIG5vbiBzbG90IG9iamVjdCBjaGlsZHJlbiAoZGlyZWN0IHZhbHVlKSBwYXNzZWQgdG8gYSBjb21wb25lbnRcclxuICAgICAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XHJcbiAgICAgICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0geyBkZWZhdWx0OiAxIH07XHJcbiAgICB9XHJcbiAgICAvLyBkZWxldGUgc3RhbGUgc2xvdHNcclxuICAgIGlmIChuZWVkRGVsZXRpb25DaGVjaykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNJbnRlcm5hbEtleShrZXkpICYmICEoa2V5IGluIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzbG90c1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xuXG4vKipcclxuUnVudGltZSBoZWxwZXIgZm9yIGFwcGx5aW5nIGRpcmVjdGl2ZXMgdG8gYSB2bm9kZS4gRXhhbXBsZSB1c2FnZTpcclxuXG5jb25zdCBjb21wID0gcmVzb2x2ZUNvbXBvbmVudCgnY29tcCcpXHJcbmNvbnN0IGZvbyA9IHJlc29sdmVEaXJlY3RpdmUoJ2ZvbycpXHJcbmNvbnN0IGJhciA9IHJlc29sdmVEaXJlY3RpdmUoJ2JhcicpXHJcblxucmV0dXJuIHdpdGhEaXJlY3RpdmVzKGgoY29tcCksIFtcclxuICBbZm9vLCB0aGlzLnhdLFxyXG4gIFtiYXIsIHRoaXMueV1cclxuXSlcclxuKi9cclxuY29uc3QgaXNCdWlsdEluRGlyZWN0aXZlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdiaW5kLGNsb2FrLGVsc2UtaWYsZWxzZSxmb3IsaHRtbCxpZixtb2RlbCxvbixvbmNlLHByZSxzaG93LHNsb3QsdGV4dCcpO1xyXG5mdW5jdGlvbiB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSkge1xyXG4gICAgaWYgKGlzQnVpbHRJbkRpcmVjdGl2ZShuYW1lKSkge1xyXG4gICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gZGlyZWN0aXZlIGlkcyBhcyBjdXN0b20gZGlyZWN0aXZlIGlkOiAnICsgbmFtZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgZGlyZWN0aXZlcyB0byBhIFZOb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gd2l0aERpcmVjdGl2ZXModm5vZGUsIGRpcmVjdGl2ZXMpIHtcclxuICAgIGNvbnN0IGludGVybmFsSW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGB3aXRoRGlyZWN0aXZlcyBjYW4gb25seSBiZSB1c2VkIGluc2lkZSByZW5kZXIgZnVuY3Rpb25zLmApO1xyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGluc3RhbmNlID0gaW50ZXJuYWxJbnN0YW5jZS5wcm94eTtcclxuICAgIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycyB8fCAodm5vZGUuZGlycyA9IFtdKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyZWN0aXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBbZGlyLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMgPSBFTVBUWV9PQkpdID0gZGlyZWN0aXZlc1tpXTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbiQxKGRpcikpIHtcclxuICAgICAgICAgICAgZGlyID0ge1xyXG4gICAgICAgICAgICAgICAgbW91bnRlZDogZGlyLFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlZDogZGlyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXIuZGVlcCkge1xyXG4gICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJpbmRpbmdzLnB1c2goe1xyXG4gICAgICAgICAgICBkaXIsXHJcbiAgICAgICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcclxuICAgICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgICBtb2RpZmllcnNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZTtcclxufVxyXG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XHJcbiAgICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnM7XHJcbiAgICBjb25zdCBvbGRCaW5kaW5ncyA9IHByZXZWTm9kZSAmJiBwcmV2Vk5vZGUuZGlycztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XHJcbiAgICAgICAgaWYgKG9sZEJpbmRpbmdzKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcub2xkVmFsdWUgPSBvbGRCaW5kaW5nc1tpXS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGhvb2sgPSBiaW5kaW5nLmRpcltuYW1lXTtcclxuICAgICAgICBpZiAoaG9vaykge1xyXG4gICAgICAgICAgICAvLyBkaXNhYmxlIHRyYWNraW5nIGluc2lkZSBhbGwgbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgY2FuIHBvdGVudGlhbGx5IGJlIGNhbGxlZCBpbnNpZGUgZWZmZWN0cy5cclxuICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOCAvKiBESVJFQ1RJVkVfSE9PSyAqLywgW1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuZWwsXHJcbiAgICAgICAgICAgICAgICBiaW5kaW5nLFxyXG4gICAgICAgICAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgICAgICAgICBwcmV2Vk5vZGVcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXBwQ29udGV4dCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXBwOiBudWxsLFxyXG4gICAgICAgIGNvbmZpZzoge1xyXG4gICAgICAgICAgICBpc05hdGl2ZVRhZzogTk8sXHJcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcclxuICAgICAgICAgICAgZ2xvYmFsUHJvcGVydGllczoge30sXHJcbiAgICAgICAgICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczoge30sXHJcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB3YXJuSGFuZGxlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjb21waWxlck9wdGlvbnM6IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaXhpbnM6IFtdLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IHt9LFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IHt9LFxyXG4gICAgICAgIHByb3ZpZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICAgIG9wdGlvbnNDYWNoZTogbmV3IFdlYWtNYXAoKSxcclxuICAgICAgICBwcm9wc0NhY2hlOiBuZXcgV2Vha01hcCgpLFxyXG4gICAgICAgIGVtaXRzQ2FjaGU6IG5ldyBXZWFrTWFwKClcclxuICAgIH07XHJcbn1cclxubGV0IHVpZCA9IDA7XHJcbmZ1bmN0aW9uIGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcHAocm9vdENvbXBvbmVudCwgcm9vdFByb3BzID0gbnVsbCkge1xyXG4gICAgICAgIGlmIChyb290UHJvcHMgIT0gbnVsbCAmJiAhaXNPYmplY3QkMShyb290UHJvcHMpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGByb290IHByb3BzIHBhc3NlZCB0byBhcHAubW91bnQoKSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcclxuICAgICAgICAgICAgcm9vdFByb3BzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcclxuICAgICAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGxldCBpc01vdW50ZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBhcHAgPSAoY29udGV4dC5hcHAgPSB7XHJcbiAgICAgICAgICAgIF91aWQ6IHVpZCsrLFxyXG4gICAgICAgICAgICBfY29tcG9uZW50OiByb290Q29tcG9uZW50LFxyXG4gICAgICAgICAgICBfcHJvcHM6IHJvb3RQcm9wcyxcclxuICAgICAgICAgICAgX2NvbnRhaW5lcjogbnVsbCxcclxuICAgICAgICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXHJcbiAgICAgICAgICAgIF9pbnN0YW5jZTogbnVsbCxcclxuICAgICAgICAgICAgdmVyc2lvbixcclxuICAgICAgICAgICAgZ2V0IGNvbmZpZygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbmZpZztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0IGNvbmZpZyh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgYXBwLmNvbmZpZyBjYW5ub3QgYmUgcmVwbGFjZWQuIE1vZGlmeSBpbmRpdmlkdWFsIG9wdGlvbnMgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXNlKHBsdWdpbiwgLi4ub3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaGFzKHBsdWdpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGx1Z2luICYmIGlzRnVuY3Rpb24kMShwbHVnaW4uaW5zdGFsbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5pbnN0YWxsKGFwcCwgLi4ub3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uJDEocGx1Z2luKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luKGFwcCwgLi4ub3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBIHBsdWdpbiBtdXN0IGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCB3aXRoIGFuIFwiaW5zdGFsbFwiIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtaXhpbihtaXhpbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQubWl4aW5zLmluY2x1ZGVzKG1peGluKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1peGlucy5wdXNoKG1peGluKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ01peGluIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWl4aW4ubmFtZSA/IGA6ICR7bWl4aW4ubmFtZX1gIDogJycpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKCdNaXhpbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGJ1aWxkcyBzdXBwb3J0aW5nIE9wdGlvbnMgQVBJJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb21wb25lbnQobmFtZSwgY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbnRleHQuY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29udGV4dC5jb21wb25lbnRzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5jb21wb25lbnRzW25hbWVdID0gY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGlyZWN0aXZlKG5hbWUsIGRpcmVjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZGlyZWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRGlyZWN0aXZlIFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdID0gZGlyZWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbW91bnQocm9vdENvbnRhaW5lciwgaXNIeWRyYXRlLCBpc1NWRykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgYXBwIGNvbnRleHQgb24gdGhlIHJvb3QgVk5vZGUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGJlIHNldCBvbiB0aGUgcm9vdCBpbnN0YW5jZSBvbiBpbml0aWFsIG1vdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmFwcENvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhNUiByb290IHJlbG9hZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXIoY2xvbmVWTm9kZSh2bm9kZSksIHJvb3RDb250YWluZXIsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSHlkcmF0ZSAmJiBoeWRyYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGUodm5vZGUsIHJvb3RDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKHZub2RlLCByb290Q29udGFpbmVyLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBwLl9jb250YWluZXIgPSByb290Q29udGFpbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RDb250YWluZXIuX192dWVfYXBwX18gPSBhcHA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2bm9kZS5jb21wb25lbnQucHJveHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBBcHAgaGFzIGFscmVhZHkgYmVlbiBtb3VudGVkLlxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgSWYgeW91IHdhbnQgdG8gcmVtb3VudCB0aGUgc2FtZSBhcHAsIG1vdmUgeW91ciBhcHAgY3JlYXRpb24gbG9naWMgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpbnRvIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgY3JlYXRlIGZyZXNoIGFwcCBpbnN0YW5jZXMgZm9yIGVhY2ggYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBtb3VudCAtIGUuZy4gXFxgY29uc3QgY3JlYXRlTXlBcHAgPSAoKSA9PiBjcmVhdGVBcHAoQXBwKVxcYGApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1bm1vdW50KCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihudWxsLCBhcHAuX2NvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldnRvb2xzVW5tb3VudEFwcChhcHApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXBwLl9jb250YWluZXIuX192dWVfYXBwX187XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDYW5ub3QgdW5tb3VudCBhbiBhcHAgdGhhdCBpcyBub3QgbW91bnRlZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJvdmlkZShrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSBpbiBjb250ZXh0LnByb3ZpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXBwIGFscmVhZHkgcHJvdmlkZXMgcHJvcGVydHkgd2l0aCBrZXkgXCIke1N0cmluZyhrZXkpfVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYEl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCBkb2Vzbid0IGFsbG93IHN5bWJvbHMgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yNDU4N1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5wcm92aWRlc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgIH07XHJcbn1cblxubGV0IGhhc01pc21hdGNoID0gZmFsc2U7XHJcbmNvbnN0IGlzU1ZHQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gL3N2Zy8udGVzdChjb250YWluZXIubmFtZXNwYWNlVVJJKSAmJiBjb250YWluZXIudGFnTmFtZSAhPT0gJ2ZvcmVpZ25PYmplY3QnO1xyXG5jb25zdCBpc0NvbW1lbnQgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDT01NRU5UICovO1xyXG4vLyBOb3RlOiBoeWRyYXRpb24gaXMgRE9NLXNwZWNpZmljXHJcbi8vIEJ1dCB3ZSBoYXZlIHRvIHBsYWNlIGl0IGluIGNvcmUgZHVlIHRvIHRpZ2h0IGNvdXBsaW5nIHdpdGggY29yZSAtIHNwbGl0dGluZ1xyXG4vLyBpdCBvdXQgY3JlYXRlcyBhIHRvbiBvZiB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5LlxyXG4vLyBIeWRyYXRpb24gYWxzbyBkZXBlbmRzIG9uIHNvbWUgcmVuZGVyZXIgaW50ZXJuYWwgbG9naWMgd2hpY2ggbmVlZHMgdG8gYmVcclxuLy8gcGFzc2VkIGluIHZpYSBhcmd1bWVudHMuXHJcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xyXG4gICAgY29uc3QgeyBtdDogbW91bnRDb21wb25lbnQsIHA6IHBhdGNoLCBvOiB7IHBhdGNoUHJvcCwgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHJlbW92ZSwgaW5zZXJ0LCBjcmVhdGVDb21tZW50IH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xyXG4gICAgY29uc3QgaHlkcmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBoeWRyYXRlIGV4aXN0aW5nIG1hcmt1cCBidXQgY29udGFpbmVyIGlzIGVtcHR5LiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUGVyZm9ybWluZyBmdWxsIG1vdW50IGluc3RlYWQuYCk7XHJcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIpO1xyXG4gICAgICAgICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhc01pc21hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgaHlkcmF0ZU5vZGUoY29udGFpbmVyLmZpcnN0Q2hpbGQsIHZub2RlLCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xyXG4gICAgICAgIGlmIChoYXNNaXNtYXRjaCAmJiAhZmFsc2UpIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBlcnJvciBzaG91bGQgc2hvdyB1cCBpbiBwcm9kdWN0aW9uXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEh5ZHJhdGlvbiBjb21wbGV0ZWQgYnV0IGNvbnRhaW5zIG1pc21hdGNoZXMuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVOb2RlID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaXNGcmFnbWVudFN0YXJ0ID0gaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gJ1snO1xyXG4gICAgICAgIGNvbnN0IG9uTWlzbWF0Y2ggPSAoKSA9PiBoYW5kbGVNaXNtYXRjaChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBpc0ZyYWdtZW50U3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcgfSA9IHZub2RlO1xyXG4gICAgICAgIGNvbnN0IGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xyXG4gICAgICAgIHZub2RlLmVsID0gbm9kZTtcclxuICAgICAgICBsZXQgbmV4dE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFRleHQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMyAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhICE9PSB2bm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIHRleHQgbWlzbWF0Y2g6YCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcbi0gQ2xpZW50OiAke0pTT04uc3RyaW5naWZ5KG5vZGUuZGF0YSl9YCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcbi0gU2VydmVyOiAke0pTT04uc3RyaW5naWZ5KHZub2RlLmNoaWxkcmVuKX1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDb21tZW50JDE6XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBDT01NRU5UICovIHx8IGlzRnJhZ21lbnRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFN0YXRpYzpcclxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSBhbmNob3IsIGFkb3B0IGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXRpYyB2bm9kZSBoYXMgaXRzIGNvbnRlbnQgc3RyaXBwZWQgZHVyaW5nIGJ1aWxkLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkb3B0IGl0IGZyb20gdGhlIHNlcnZlci1yZW5kZXJlZCBIVE1MLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZWRUb0Fkb3B0Q29udGVudCA9ICF2bm9kZS5jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5zdGF0aWNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWVkVG9BZG9wdENvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlbiArPSBuZXh0Tm9kZS5vdXRlckhUTUw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSB2bm9kZS5zdGF0aWNDb3VudCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IG5leHROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dE5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBGcmFnbWVudDpcclxuICAgICAgICAgICAgICAgIGlmICghaXNGcmFnbWVudFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVGcmFnbWVudChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDEgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS50eXBlLnRvTG93ZXJDYXNlKCkgIT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUVsZW1lbnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gc2V0dGluZyB1cCB0aGUgcmVuZGVyIGVmZmVjdCwgaWYgdGhlIGluaXRpYWwgdm5vZGUgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyAuZWwgc2V0LCB0aGUgY29tcG9uZW50IHdpbGwgcGVyZm9ybSBoeWRyYXRpb24gaW5zdGVhZCBvZiBtb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGl0cyBzdWItdHJlZS5cclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudENvbXBvbmVudCh2bm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgYmUgYXN5bmMsIHNvIGluIHRoZSBjYXNlIG9mIGZyYWdtZW50cyB3ZSBjYW5ub3QgcmVseVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGNvbXBvbmVudCdzIHJlbmRlcmVkIG91dHB1dCB0byBkZXRlcm1pbmUgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkLCB3ZSBkbyBhIGxvb2thaGVhZCB0byBmaW5kIHRoZSBlbmQgYW5jaG9yIG5vZGUuXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBpc0ZyYWdtZW50U3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3Iobm9kZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAjMzc4N1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGNvbXBvbmVudCBpcyBhc3luYywgaXQgbWF5IGdldCBtb3ZlZCAvIHVubW91bnRlZCBiZWZvcmUgaXRzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5uZXIgY29tcG9uZW50IGlzIGxvYWRlZCwgc28gd2UgbmVlZCB0byBnaXZlIGl0IGEgcGxhY2Vob2xkZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSB0aGF0IG1hdGNoZXMgaXRzIGFkb3B0ZWQgRE9NLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN1YlRyZWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUgPSBjcmVhdGVWTm9kZShGcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlLmFuY2hvciA9IG5leHROb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXh0Tm9kZS5wcmV2aW91c1NpYmxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVUeXBlID09PSAzID8gY3JlYXRlVGV4dFZOb2RlKCcnKSA6IGNyZWF0ZVZOb2RlKCdkaXYnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlLmVsID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50LnN1YlRyZWUgPSBzdWJUcmVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDggLyogQ09NTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKHBhcmVudE5vZGUobm9kZSkpLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgSG9zdFZOb2RlIHR5cGU6JywgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0Tm9kZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlRWxlbWVudCA9IChlbCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHBhdGNoRmxhZywgc2hhcGVGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICAvLyAjNDAwNiBmb3IgZm9ybSBlbGVtZW50cyB3aXRoIG5vbi1zdHJpbmcgdi1tb2RlbCB2YWx1ZSBiaW5kaW5nc1xyXG4gICAgICAgIC8vIGUuZy4gPG9wdGlvbiA6dmFsdWU9XCJvYmpcIj4sIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiA6dHJ1ZS12YWx1ZT1cIjFcIj5cclxuICAgICAgICBjb25zdCBmb3JjZVBhdGNoVmFsdWUgPSAodHlwZSA9PT0gJ2lucHV0JyAmJiBkaXJzKSB8fCB0eXBlID09PSAnb3B0aW9uJztcclxuICAgICAgICAvLyBza2lwIHByb3BzICYgY2hpbGRyZW4gaWYgdGhpcyBpcyBob2lzdGVkIHN0YXRpYyBub2Rlc1xyXG4gICAgICAgIGlmIChmb3JjZVBhdGNoVmFsdWUgfHwgcGF0Y2hGbGFnICE9PSAtMSAvKiBIT0lTVEVEICovKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdjcmVhdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICAgICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2VQYXRjaFZhbHVlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIW9wdGltaXplZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChwYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyAmIDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZm9yY2VQYXRjaFZhbHVlICYmIGtleS5lbmRzV2l0aCgndmFsdWUnKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpc09uKGtleSkgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wcy5vbkNsaWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBjbGljayBsaXN0ZW5lcnMgKHdoaWNoIGlzIG1vc3Qgb2Z0ZW4pIHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0aW5nIHRocm91Z2ggcHJvcHMuXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hQcm9wKGVsLCAnb25DbGljaycsIG51bGwsIHByb3BzLm9uQ2xpY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHZub2RlIC8gZGlyZWN0aXZlIGhvb2tzXHJcbiAgICAgICAgICAgIGxldCB2bm9kZUhvb2tzO1xyXG4gICAgICAgICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rcywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2JlZm9yZU1vdW50Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8IGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZUhvb2tzICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ21vdW50ZWQnKTtcclxuICAgICAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjaGlsZHJlblxyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8gJiZcclxuICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgZWxlbWVudCBoYXMgaW5uZXJIVE1MIC8gdGV4dENvbnRlbnRcclxuICAgICAgICAgICAgICAgICEocHJvcHMgJiYgKHByb3BzLmlubmVySFRNTCB8fCBwcm9wcy50ZXh0Q29udGVudCkpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihlbC5maXJzdENoaWxkLCB2bm9kZSwgZWwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBTU1JlZCBET00gY29udGFpbnMgbW9yZSBub2RlcyB0aGFuIGl0IHNob3VsZC4gUmVtb3ZlIHRoZW0uXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyID0gbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUoY3VyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC50ZXh0Q29udGVudCAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiB0ZXh0IGNvbnRlbnQgbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OlxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYC0gQ2xpZW50OiAke2VsLnRleHRDb250ZW50fVxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYC0gU2VydmVyOiAke3Zub2RlLmNoaWxkcmVufWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsLm5leHRTaWJsaW5nO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVDaGlsZHJlbiA9IChub2RlLCBwYXJlbnRWTm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXBhcmVudFZOb2RlLmR5bmFtaWNDaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFZOb2RlLmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IGwgPSBjaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZub2RlID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNoaWxkcmVuW2ldXHJcbiAgICAgICAgICAgICAgICA6IChjaGlsZHJlbltpXSA9IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gaHlkcmF0ZU5vZGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBUZXh0ICYmICF2bm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXNXYXJuZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggaW4gPCR7Y29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+OiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIGZld2VyIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBTU1JlZCBET00gZGlkbid0IGNvbnRhaW4gZW5vdWdoIG5vZGVzLiBNb3VudCB0aGUgbWlzc2luZyBvbmVzLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIoY29udGFpbmVyKSwgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlRnJhZ21lbnQgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBzbG90U2NvcGVJZHM6IGZyYWdtZW50U2xvdFNjb3BlSWRzIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzXHJcbiAgICAgICAgICAgICAgICA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpXHJcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgICAgIGNvbnN0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4obmV4dFNpYmxpbmcobm9kZSksIHZub2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICBpZiAobmV4dCAmJiBpc0NvbW1lbnQobmV4dCkgJiYgbmV4dC5kYXRhID09PSAnXScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKCh2bm9kZS5hbmNob3IgPSBuZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBmcmFnbWVudCBkaWRuJ3QgaHlkcmF0ZSBzdWNjZXNzZnVsbHksIHNpbmNlIHdlIGRpZG4ndCBnZXQgYSBlbmQgYW5jaG9yXHJcbiAgICAgICAgICAgIC8vIGJhY2suIFRoaXMgc2hvdWxkIGhhdmUgbGVkIHRvIG5vZGUvY2hpbGRyZW4gbWlzbWF0Y2ggd2FybmluZ3MuXHJcbiAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhlIGFuY2hvciBpcyBtaXNzaW5nLCB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmUgYW5kIGluc2VydCBpdFxyXG4gICAgICAgICAgICBpbnNlcnQoKHZub2RlLmFuY2hvciA9IGNyZWF0ZUNvbW1lbnQoYF1gKSksIGNvbnRhaW5lciwgbmV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBoYW5kbGVNaXNtYXRjaCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBpc0ZyYWdtZW50KSA9PiB7XHJcbiAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gbm9kZSBtaXNtYXRjaDpcXG4tIENsaWVudCB2bm9kZTpgLCB2bm9kZS50eXBlLCBgXFxuLSBTZXJ2ZXIgcmVuZGVyZWQgRE9NOmAsIG5vZGUsIG5vZGUubm9kZVR5cGUgPT09IDMgLyogVEVYVCAqL1xyXG4gICAgICAgICAgICAgICAgPyBgKHRleHQpYFxyXG4gICAgICAgICAgICAgICAgOiBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSAnWydcclxuICAgICAgICAgICAgICAgICAgICA/IGAoc3RhcnQgb2YgZnJhZ21lbnQpYFxyXG4gICAgICAgICAgICAgICAgICAgIDogYGApO1xyXG4gICAgICAgIHZub2RlLmVsID0gbnVsbDtcclxuICAgICAgICBpZiAoaXNGcmFnbWVudCkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgZXhjZXNzaXZlIGZyYWdtZW50IG5vZGVzXHJcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvcihub2RlKTtcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShuZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgICAgIHJlbW92ZShub2RlKTtcclxuICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBuZXh0LCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvciA9IChub2RlKSA9PiB7XHJcbiAgICAgICAgbGV0IG1hdGNoID0gMDtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlICYmIGlzQ29tbWVudChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gJ1snKVxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoKys7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSAnXScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gtLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV07XHJcbn1cblxubGV0IHN1cHBvcnRlZDtcclxubGV0IHBlcmY7XHJcbmZ1bmN0aW9uIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICBwZXJmLm1hcmsoYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWApO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICBkZXZ0b29sc1BlcmZTdGFydChpbnN0YW5jZSwgdHlwZSwgc3VwcG9ydGVkID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGVuZE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRUYWcgPSBgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YDtcclxuICAgICAgICBjb25zdCBlbmRUYWcgPSBzdGFydFRhZyArIGA6ZW5kYDtcclxuICAgICAgICBwZXJmLm1hcmsoZW5kVGFnKTtcclxuICAgICAgICBwZXJmLm1lYXN1cmUoYDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfT4gJHt0eXBlfWAsIHN0YXJ0VGFnLCBlbmRUYWcpO1xyXG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XHJcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGRldnRvb2xzUGVyZkVuZChpbnN0YW5jZSwgdHlwZSwgc3VwcG9ydGVkID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xyXG4gICAgaWYgKHN1cHBvcnRlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcclxuICAgIH1cclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xyXG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxuICAgIHJldHVybiBzdXBwb3J0ZWQ7XHJcbn1cblxuLyoqXHJcbiAqIFRoaXMgaXMgb25seSBjYWxsZWQgaW4gZXNtLWJ1bmRsZXIgYnVpbGRzLlxyXG4gKiBJdCBpcyBjYWxsZWQgd2hlbiBhIHJlbmRlcmVyIGlzIGNyZWF0ZWQsIGluIGBiYXNlQ3JlYXRlUmVuZGVyZXJgIHNvIHRoYXRcclxuICogaW1wb3J0aW5nIHJ1bnRpbWUtY29yZSBpcyBzaWRlLWVmZmVjdHMgZnJlZS5cclxuICpcclxuICogaXN0YW5idWwtaWdub3JlLW5leHRcclxuICovXHJcbmZ1bmN0aW9uIGluaXRGZWF0dXJlRmxhZ3MoKSB7XHJcbiAgICBsZXQgbmVlZFdhcm4gPSBmYWxzZTtcclxuICAgIGlmICh0eXBlb2YgX19WVUVfT1BUSU9OU19BUElfXyAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgbmVlZFdhcm4gPSB0cnVlO1xyXG4gICAgICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9PUFRJT05TX0FQSV9fID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICBuZWVkV2FybiA9IHRydWU7XHJcbiAgICAgICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX1BST0RfREVWVE9PTFNfXyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBuZWVkV2Fybikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgWW91IGFyZSBydW5uaW5nIHRoZSBlc20tYnVuZGxlciBidWlsZCBvZiBWdWUuIEl0IGlzIHJlY29tbWVuZGVkIHRvIGAgK1xyXG4gICAgICAgICAgICBgY29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBleHBsaWNpdGx5IHJlcGxhY2UgZmVhdHVyZSBmbGFnIGdsb2JhbHMgYCArXHJcbiAgICAgICAgICAgIGB3aXRoIGJvb2xlYW4gbGl0ZXJhbHMgdG8gZ2V0IHByb3BlciB0cmVlLXNoYWtpbmcgaW4gdGhlIGZpbmFsIGJ1bmRsZS4gYCArXHJcbiAgICAgICAgICAgIGBTZWUgaHR0cDovL2xpbmsudnVlanMub3JnL2ZlYXR1cmUtZmxhZ3MgZm9yIG1vcmUgZGV0YWlscy5gKTtcclxuICAgIH1cclxufVxuXG5jb25zdCBwcm9kRWZmZWN0T3B0aW9ucyA9IHtcclxuICAgIHNjaGVkdWxlcjogcXVldWVKb2IsXHJcbiAgICAvLyAjMTgwMSwgIzIwNDMgY29tcG9uZW50IHJlbmRlciBlZmZlY3RzIHNob3VsZCBhbGxvdyByZWN1cnNpdmUgdXBkYXRlc1xyXG4gICAgYWxsb3dSZWN1cnNlOiB0cnVlXHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZURldkVmZmVjdE9wdGlvbnMoaW5zdGFuY2UpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2NoZWR1bGVyOiBxdWV1ZUpvYixcclxuICAgICAgICBhbGxvd1JlY3Vyc2U6IHRydWUsXHJcbiAgICAgICAgb25UcmFjazogaW5zdGFuY2UucnRjID8gZSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGMsIGUpIDogdm9pZCAwLFxyXG4gICAgICAgIG9uVHJpZ2dlcjogaW5zdGFuY2UucnRnID8gZSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGcsIGUpIDogdm9pZCAwXHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IHF1ZXVlUG9zdFJlbmRlckVmZmVjdCA9IHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlXHJcbiAgICA7XHJcbmNvbnN0IHNldFJlZiA9IChyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQgPSBmYWxzZSkgPT4ge1xyXG4gICAgaWYgKGlzQXJyYXkocmF3UmVmKSkge1xyXG4gICAgICAgIHJhd1JlZi5mb3JFYWNoKChyLCBpKSA9PiBzZXRSZWYociwgb2xkUmF3UmVmICYmIChpc0FycmF5KG9sZFJhd1JlZikgPyBvbGRSYXdSZWZbaV0gOiBvbGRSYXdSZWYpLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIGlzVW5tb3VudCkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkgJiYgIWlzVW5tb3VudCkge1xyXG4gICAgICAgIC8vIHdoZW4gbW91bnRpbmcgYXN5bmMgY29tcG9uZW50cywgbm90aGluZyBuZWVkcyB0byBiZSBkb25lLFxyXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIHRlbXBsYXRlIHJlZiBpcyBmb3J3YXJkZWQgdG8gaW5uZXIgY29tcG9uZW50XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVmVmFsdWUgPSB2bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgID8gZ2V0RXhwb3NlUHJveHkodm5vZGUuY29tcG9uZW50KSB8fCB2bm9kZS5jb21wb25lbnQucHJveHlcclxuICAgICAgICA6IHZub2RlLmVsO1xyXG4gICAgY29uc3QgdmFsdWUgPSBpc1VubW91bnQgPyBudWxsIDogcmVmVmFsdWU7XHJcbiAgICBjb25zdCB7IGk6IG93bmVyLCByOiByZWYgfSA9IHJhd1JlZjtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIW93bmVyKSB7XHJcbiAgICAgICAgd2FybihgTWlzc2luZyByZWYgb3duZXIgY29udGV4dC4gcmVmIGNhbm5vdCBiZSB1c2VkIG9uIGhvaXN0ZWQgdm5vZGVzLiBgICtcclxuICAgICAgICAgICAgYEEgdm5vZGUgd2l0aCByZWYgbXVzdCBiZSBjcmVhdGVkIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uLmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFJlZiA9IG9sZFJhd1JlZiAmJiBvbGRSYXdSZWYucjtcclxuICAgIGNvbnN0IHJlZnMgPSBvd25lci5yZWZzID09PSBFTVBUWV9PQkogPyAob3duZXIucmVmcyA9IHt9KSA6IG93bmVyLnJlZnM7XHJcbiAgICBjb25zdCBzZXR1cFN0YXRlID0gb3duZXIuc2V0dXBTdGF0ZTtcclxuICAgIC8vIGR5bmFtaWMgcmVmIGNoYW5nZWQuIHVuc2V0IG9sZCByZWZcclxuICAgIGlmIChvbGRSZWYgIT0gbnVsbCAmJiBvbGRSZWYgIT09IHJlZikge1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhvbGRSZWYpKSB7XHJcbiAgICAgICAgICAgIHJlZnNbb2xkUmVmXSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd24oc2V0dXBTdGF0ZSwgb2xkUmVmKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtvbGRSZWZdID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1JlZihvbGRSZWYpKSB7XHJcbiAgICAgICAgICAgIG9sZFJlZi52YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzU3RyaW5nKHJlZikpIHtcclxuICAgICAgICBjb25zdCBkb1NldCA9ICgpID0+IHtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVmc1tyZWZdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gIzE3ODk6IGZvciBub24tbnVsbCB2YWx1ZXMsIHNldCB0aGVtIGFmdGVyIHJlbmRlclxyXG4gICAgICAgIC8vIG51bGwgdmFsdWVzIG1lYW5zIHRoaXMgaXMgdW5tb3VudCBhbmQgaXQgc2hvdWxkIG5vdCBvdmVyd3JpdGUgYW5vdGhlclxyXG4gICAgICAgIC8vIHJlZiB3aXRoIHRoZSBzYW1lIGtleVxyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBkb1NldC5pZCA9IC0xO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvU2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWYocmVmKSkge1xyXG4gICAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBkb1NldC5pZCA9IC0xO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvU2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbiQxKHJlZikpIHtcclxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcocmVmLCBvd25lciwgMTIgLyogRlVOQ1RJT05fUkVGICovLCBbdmFsdWUsIHJlZnNdKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oJ0ludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6JywgdmFsdWUsIGAoJHt0eXBlb2YgdmFsdWV9KWApO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogVGhlIGNyZWF0ZVJlbmRlcmVyIGZ1bmN0aW9uIGFjY2VwdHMgdHdvIGdlbmVyaWMgYXJndW1lbnRzOlxyXG4gKiBIb3N0Tm9kZSBhbmQgSG9zdEVsZW1lbnQsIGNvcnJlc3BvbmRpbmcgdG8gTm9kZSBhbmQgRWxlbWVudCB0eXBlcyBpbiB0aGVcclxuICogaG9zdCBlbnZpcm9ubWVudC4gRm9yIGV4YW1wbGUsIGZvciBydW50aW1lLWRvbSwgSG9zdE5vZGUgd291bGQgYmUgdGhlIERPTVxyXG4gKiBgTm9kZWAgaW50ZXJmYWNlIGFuZCBIb3N0RWxlbWVudCB3b3VsZCBiZSB0aGUgRE9NIGBFbGVtZW50YCBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIEN1c3RvbSByZW5kZXJlcnMgY2FuIHBhc3MgaW4gdGhlIHBsYXRmb3JtIHNwZWNpZmljIHR5cGVzIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgIGpzXHJcbiAqIGNvbnN0IHsgcmVuZGVyLCBjcmVhdGVBcHAgfSA9IGNyZWF0ZVJlbmRlcmVyPE5vZGUsIEVsZW1lbnQ+KHtcclxuICogICBwYXRjaFByb3AsXHJcbiAqICAgLi4ubm9kZU9wc1xyXG4gKiB9KVxyXG4gKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucyk7XHJcbn1cclxuLy8gU2VwYXJhdGUgQVBJIGZvciBjcmVhdGluZyBoeWRyYXRpb24tZW5hYmxlZCByZW5kZXJlci5cclxuLy8gSHlkcmF0aW9uIGxvZ2ljIGlzIG9ubHkgdXNlZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiwgbWFraW5nIGl0XHJcbi8vIHRyZWUtc2hha2FibGUuXHJcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKTtcclxufVxyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRm5zKSB7XHJcbiAgICAvLyBjb21waWxlLXRpbWUgZmVhdHVyZSBmbGFncyBjaGVja1xyXG4gICAge1xyXG4gICAgICAgIGluaXRGZWF0dXJlRmxhZ3MoKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0R2xvYmFsVGhpcygpO1xyXG4gICAgICAgIHRhcmdldC5fX1ZVRV9fID0gdHJ1ZTtcclxuICAgICAgICBzZXREZXZ0b29sc0hvb2sodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBpbnNlcnQ6IGhvc3RJbnNlcnQsIHJlbW92ZTogaG9zdFJlbW92ZSwgcGF0Y2hQcm9wOiBob3N0UGF0Y2hQcm9wLCBmb3JjZVBhdGNoUHJvcDogaG9zdEZvcmNlUGF0Y2hQcm9wLCBjcmVhdGVFbGVtZW50OiBob3N0Q3JlYXRlRWxlbWVudCwgY3JlYXRlVGV4dDogaG9zdENyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQ6IGhvc3RDcmVhdGVDb21tZW50LCBzZXRUZXh0OiBob3N0U2V0VGV4dCwgc2V0RWxlbWVudFRleHQ6IGhvc3RTZXRFbGVtZW50VGV4dCwgcGFyZW50Tm9kZTogaG9zdFBhcmVudE5vZGUsIG5leHRTaWJsaW5nOiBob3N0TmV4dFNpYmxpbmcsIHNldFNjb3BlSWQ6IGhvc3RTZXRTY29wZUlkID0gTk9PUCwgY2xvbmVOb2RlOiBob3N0Q2xvbmVOb2RlLCBpbnNlcnRTdGF0aWNDb250ZW50OiBob3N0SW5zZXJ0U3RhdGljQ29udGVudCB9ID0gb3B0aW9ucztcclxuICAgIC8vIE5vdGU6IGZ1bmN0aW9ucyBpbnNpZGUgdGhpcyBjbG9zdXJlIHNob3VsZCB1c2UgYGNvbnN0IHh4eCA9ICgpID0+IHt9YFxyXG4gICAgLy8gc3R5bGUgaW4gb3JkZXIgdG8gcHJldmVudCBiZWluZyBpbmxpbmVkIGJ5IG1pbmlmaWVycy5cclxuICAgIGNvbnN0IHBhdGNoID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IgPSBudWxsLCBwYXJlbnRDb21wb25lbnQgPSBudWxsLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwsIGlzU1ZHID0gZmFsc2UsIHNsb3RTY29wZUlkcyA9IG51bGwsIG9wdGltaXplZCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nID8gZmFsc2UgOiAhIW4yLmR5bmFtaWNDaGlsZHJlbikgPT4ge1xyXG4gICAgICAgIC8vIHBhdGNoaW5nICYgbm90IHNhbWUgdHlwZSwgdW5tb3VudCBvbGQgdHJlZVxyXG4gICAgICAgIGlmIChuMSAmJiAhaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgYW5jaG9yID0gZ2V0TmV4dEhvc3ROb2RlKG4xKTtcclxuICAgICAgICAgICAgdW5tb3VudChuMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIG4xID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4yLnBhdGNoRmxhZyA9PT0gLTIgLyogQkFJTCAqLykge1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbjIuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVGV4dDpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWVudCQxOlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGljOlxyXG4gICAgICAgICAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudFN0YXRpY05vZGUobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaFN0YXRpY05vZGUobjEsIG4yLCBjb250YWluZXIsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEZyYWdtZW50OlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZyYWdtZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRWxlbWVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQ29tcG9uZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUucHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldCByZWZcclxuICAgICAgICBpZiAocmVmICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG4xICYmIG4xLnJlZiwgcGFyZW50U3VzcGVuc2UsIG4yIHx8IG4xLCAhbjIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzVGV4dCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydCgobjIuZWwgPSBob3N0Q3JlYXRlVGV4dChuMi5jaGlsZHJlbikpLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBlbCA9IChuMi5lbCA9IG4xLmVsKTtcclxuICAgICAgICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaG9zdFNldFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzQ29tbWVudE5vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZUNvbW1lbnQobjIuY2hpbGRyZW4gfHwgJycpKSwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBzdXBwb3J0IGZvciBkeW5hbWljIGNvbW1lbnRzXHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50U3RhdGljTm9kZSA9IChuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQobjIuY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXYgLyBITVIgb25seVxyXG4gICAgICovXHJcbiAgICBjb25zdCBwYXRjaFN0YXRpY05vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgLy8gc3RhdGljIG5vZGVzIGFyZSBvbmx5IHBhdGNoZWQgZHVyaW5nIGRldiBmb3IgSE1SXHJcbiAgICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBob3N0TmV4dFNpYmxpbmcobjEuYW5jaG9yKTtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXHJcbiAgICAgICAgICAgIHJlbW92ZVN0YXRpY05vZGUobjEpO1xyXG4gICAgICAgICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0sIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpID0+IHtcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcclxuICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XHJcbiAgICAgICAgICAgIGVsID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdEluc2VydChhbmNob3IsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0pID0+IHtcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZShlbCk7XHJcbiAgICAgICAgICAgIGVsID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NFbGVtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgbjIudHlwZSA9PT0gJ3N2Zyc7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgbW91bnRFbGVtZW50KG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoRWxlbWVudChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50RWxlbWVudCA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGxldCBlbDtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHNoYXBlRmxhZywgdHJhbnNpdGlvbiwgcGF0Y2hGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB2bm9kZS5lbCAmJlxyXG4gICAgICAgICAgICBob3N0Q2xvbmVOb2RlICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID09PSAtMSAvKiBIT0lTVEVEICovKSB7XHJcbiAgICAgICAgICAgIC8vIElmIGEgdm5vZGUgaGFzIG5vbi1udWxsIGVsLCBpdCBtZWFucyBpdCdzIGJlaW5nIHJldXNlZC5cclxuICAgICAgICAgICAgLy8gT25seSBzdGF0aWMgdm5vZGVzIGNhbiBiZSByZXVzZWQsIHNvIGl0cyBtb3VudGVkIERPTSBub2RlcyBzaG91bGQgYmVcclxuICAgICAgICAgICAgLy8gZXhhY3RseSB0aGUgc2FtZSwgYW5kIHdlIGNhbiBzaW1wbHkgZG8gYSBjbG9uZSBoZXJlLlxyXG4gICAgICAgICAgICAvLyBvbmx5IGRvIHRoaXMgaW4gcHJvZHVjdGlvbiBzaW5jZSBjbG9uZWQgdHJlZXMgY2Fubm90IGJlIEhNUiB1cGRhdGVkLlxyXG4gICAgICAgICAgICBlbCA9IHZub2RlLmVsID0gaG9zdENsb25lTm9kZSh2bm9kZS5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbCA9IHZub2RlLmVsID0gaG9zdENyZWF0ZUVsZW1lbnQodm5vZGUudHlwZSwgaXNTVkcsIHByb3BzICYmIHByb3BzLmlzLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIC8vIG1vdW50IGNoaWxkcmVuIGZpcnN0LCBzaW5jZSBzb21lIHByb3BzIG1heSByZWx5IG9uIGNoaWxkIGNvbnRlbnRcclxuICAgICAgICAgICAgLy8gYmVpbmcgYWxyZWFkeSByZW5kZXJlZCwgZS5nLiBgPHNlbGVjdCB2YWx1ZT5gXHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudENoaWxkcmVuKHZub2RlLmNoaWxkcmVuLCBlbCwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcgJiYgdHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2NyZWF0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNjb3BlSWRcclxuICAgICAgICAgICAgc2V0U2NvcGVJZChlbCwgdm5vZGUsIHZub2RlLnNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCAnX192bm9kZScsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2bm9kZSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdfX3Z1ZVBhcmVudENvbXBvbmVudCcsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gIzE1ODMgRm9yIGluc2lkZSBzdXNwZW5zZSArIHN1c3BlbnNlIG5vdCByZXNvbHZlZCBjYXNlLCBlbnRlciBob29rIHNob3VsZCBjYWxsIHdoZW4gc3VzcGVuc2UgcmVzb2x2ZWRcclxuICAgICAgICAvLyAjMTY4OSBGb3IgaW5zaWRlIHN1c3BlbnNlICsgc3VzcGVuc2UgcmVzb2x2ZWQgY2FzZSwganVzdCBjYWxsIGl0XHJcbiAgICAgICAgY29uc3QgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSAoIXBhcmVudFN1c3BlbnNlIHx8IChwYXJlbnRTdXNwZW5zZSAmJiAhcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkpICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xyXG4gICAgICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8XHJcbiAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzIHx8XHJcbiAgICAgICAgICAgIGRpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdtb3VudGVkJyk7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKHNjb3BlSWQpIHtcclxuICAgICAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNjb3BlSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2xvdFNjb3BlSWRzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xvdFNjb3BlSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2xvdFNjb3BlSWRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHN1YlRyZWUucGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJUcmVlID1cclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJTaW5nbGVSb290KHN1YlRyZWUuY2hpbGRyZW4pIHx8IHN1YlRyZWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZub2RlID09PSBzdWJUcmVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRWTm9kZSA9IHBhcmVudENvbXBvbmVudC52bm9kZTtcclxuICAgICAgICAgICAgICAgIHNldFNjb3BlSWQoZWwsIHBhcmVudFZOb2RlLCBwYXJlbnRWTm9kZS5zY29wZUlkLCBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudC5wYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHN0YXJ0ID0gMCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gKGNoaWxkcmVuW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGNoaWxkcmVuW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSkpO1xyXG4gICAgICAgICAgICBwYXRjaChudWxsLCBjaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoRWxlbWVudCA9IChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsID0gKG4yLmVsID0gbjEuZWwpO1xyXG4gICAgICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBkaXJzIH0gPSBuMjtcclxuICAgICAgICAvLyAjMTQyNiB0YWtlIHRoZSBvbGQgdm5vZGUncyBwYXRjaCBmbGFnIGludG8gYWNjb3VudCBzaW5jZSB1c2VyIG1heSBjbG9uZSBhXHJcbiAgICAgICAgLy8gY29tcGlsZXItZ2VuZXJhdGVkIHZub2RlLCB3aGljaCBkZS1vcHRzIHRvIEZVTExfUFJPUFNcclxuICAgICAgICBwYXRjaEZsYWcgfD0gbjEucGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLztcclxuICAgICAgICBjb25zdCBvbGRQcm9wcyA9IG4xLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkpIHtcclxuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVXBkYXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9IDA7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICAvLyB0aGUgcHJlc2VuY2Ugb2YgYSBwYXRjaEZsYWcgbWVhbnMgdGhpcyBlbGVtZW50J3MgcmVuZGVyIGNvZGUgd2FzXHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIgYW5kIGNhbiB0YWtlIHRoZSBmYXN0IHBhdGguXHJcbiAgICAgICAgICAgIC8vIGluIHRoaXMgcGF0aCBvbGQgbm9kZSBhbmQgbmV3IG5vZGUgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZVxyXG4gICAgICAgICAgICAvLyAoaS5lLiBhdCB0aGUgZXhhY3Qgc2FtZSBwb3NpdGlvbiBpbiB0aGUgc291cmNlIHRlbXBsYXRlKVxyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBwcm9wcyBjb250YWluIGR5bmFtaWMga2V5cywgZnVsbCBkaWZmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgcGF0Y2hQcm9wcyhlbCwgbjIsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2xhc3NcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgY2xhc3MgYmluZGluZ3MuXHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMiAvKiBDTEFTUyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRQcm9wcy5jbGFzcyAhPT0gbmV3UHJvcHMuY2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ2NsYXNzJywgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzdHlsZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBzdHlsZSBiaW5kaW5nc1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDQgLyogU1RZTEUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAnc3R5bGUnLCBvbGRQcm9wcy5zdHlsZSwgbmV3UHJvcHMuc3R5bGUsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkeW5hbWljIHByb3AvYXR0ciBiaW5kaW5nc1xyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdGhhbiBjbGFzcyBhbmQgc3R5bGUuIFRoZSBrZXlzIG9mIGR5bmFtaWMgcHJvcC9hdHRycyBhcmUgc2F2ZWQgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0ZXIgaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZSBkeW5hbWljIGtleXMgbGlrZSA6W2Zvb109XCJiYXJcIiB3aWxsIGNhdXNlIHRoaXMgb3B0aW1pemF0aW9uIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBiYWlsIG91dCBhbmQgZ28gdGhyb3VnaCBhIGZ1bGwgZGlmZiBiZWNhdXNlIHdlIG5lZWQgdG8gdW5zZXQgdGhlIG9sZCBrZXlcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZsYWcgaXMgcHJlc2VudCB0aGVuIGR5bmFtaWNQcm9wcyBtdXN0IGJlIG5vbi1udWxsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IG4yLmR5bmFtaWNQcm9wcztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGhvc3RGb3JjZVBhdGNoUHJvcCAmJiBob3N0Rm9yY2VQYXRjaFByb3AoZWwsIGtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIGlzU1ZHLCBuMS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0ZXh0XHJcbiAgICAgICAgICAgIC8vIFRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIG9ubHkgZHluYW1pYyB0ZXh0IGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMSAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobjEuY2hpbGRyZW4gIT09IG4yLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCAmJiBkeW5hbWljQ2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyB1bm9wdGltaXplZCwgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoUHJvcHMoZWwsIG4yLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJlQ2hpbGRyZW5TVkcgPSBpc1NWRyAmJiBuMi50eXBlICE9PSAnZm9yZWlnbk9iamVjdCc7XHJcbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGVsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBhcmVDaGlsZHJlblNWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcclxuICAgICAgICAgICAgLy8gZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBlbCwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgYXJlQ2hpbGRyZW5TVkcsIHNsb3RTY29wZUlkcywgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVVcGRhdGVkKSB8fCBkaXJzKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xyXG4gICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAndXBkYXRlZCcpO1xyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRoZSBmYXN0IHBhdGggZm9yIGJsb2Nrcy5cclxuICAgIGNvbnN0IHBhdGNoQmxvY2tDaGlsZHJlbiA9IChvbGRDaGlsZHJlbiwgbmV3Q2hpbGRyZW4sIGZhbGxiYWNrQ29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWTm9kZSA9IG5ld0NoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGNvbnRhaW5lciAocGFyZW50IGVsZW1lbnQpIGZvciB0aGUgcGF0Y2guXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IFxyXG4gICAgICAgICAgICAvLyBvbGRWTm9kZSBtYXkgYmUgYW4gZXJyb3JlZCBhc3luYyBzZXR1cCgpIGNvbXBvbmVudCBpbnNpZGUgU3VzcGVuc2VcclxuICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBub3QgaGF2ZSBhIG1vdW50ZWQgZWxlbWVudFxyXG4gICAgICAgICAgICBvbGRWTm9kZS5lbCAmJlxyXG4gICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIEZyYWdtZW50LCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGFjdHVhbCBwYXJlbnRcclxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBGcmFnbWVudCBpdHNlbGYgc28gaXQgY2FuIG1vdmUgaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgKG9sZFZOb2RlLnR5cGUgPT09IEZyYWdtZW50IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBhbHNvIHJlcXVpcmVzIHRoZSBjb3JyZWN0IHBhcmVudCBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAhaXNTYW1lVk5vZGVUeXBlKG9sZFZOb2RlLCBuZXdWTm9kZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGEgY29tcG9uZW50LCBpdCBjb3VsZCBjb250YWluIGFueXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZOb2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVk5vZGUuc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pXHJcbiAgICAgICAgICAgICAgICA/IGhvc3RQYXJlbnROb2RlKG9sZFZOb2RlLmVsKVxyXG4gICAgICAgICAgICAgICAgOiAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHBhc3MgdGhlIGJsb2NrIGVsZW1lbnQgaGVyZSB0byBhdm9pZCBhIERPTSBwYXJlbnROb2RlIGNhbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tDb250YWluZXI7XHJcbiAgICAgICAgICAgIHBhdGNoKG9sZFZOb2RlLCBuZXdWTm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hQcm9wcyA9IChlbCwgdm5vZGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpID0+IHtcclxuICAgICAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaXMgbm90IHZhbGlkIHByb3BcclxuICAgICAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSBwcmV2IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGhvc3RGb3JjZVBhdGNoUHJvcCAmJiBob3N0Rm9yY2VQYXRjaFByb3AoZWwsIGtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9sZFByb3BzICE9PSBFTVBUWV9PQkopIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpICYmICEoa2V5IGluIG5ld1Byb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIG9sZFByb3BzW2tleV0sIG51bGwsIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0ZyYWdtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50U3RhcnRBbmNob3IgPSAobjIuZWwgPSBuMSA/IG4xLmVsIDogaG9zdENyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudEVuZEFuY2hvciA9IChuMi5hbmNob3IgPSBuMSA/IG4xLmFuY2hvciA6IGhvc3RDcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IG4yO1xyXG4gICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIHNsb3QgZnJhZ21lbnQgd2l0aCA6c2xvdHRlZCBzY29wZSBpZHNcclxuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzXHJcbiAgICAgICAgICAgICAgICA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpXHJcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgLy8gSE1SIHVwZGF0ZWQsIGZvcmNlIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaEZsYWcgPSAwO1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydChmcmFnbWVudFN0YXJ0QW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRFbmRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgLy8gYSBmcmFnbWVudCBjYW4gb25seSBoYXZlIGFycmF5IGNoaWxkcmVuXHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgYXJlIGVpdGhlciBnZW5lcmF0ZWQgYnkgdGhlIGNvbXBpbGVyLCBvciBpbXBsaWNpdGx5IGNyZWF0ZWRcclxuICAgICAgICAgICAgLy8gZnJvbSBhcnJheXMuXHJcbiAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4objIuY2hpbGRyZW4sIGNvbnRhaW5lciwgZnJhZ21lbnRFbmRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnICYgNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgLy8gb2YgcmVuZGVyU2xvdCgpIHdpdGggbm8gdmFsaWQgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gYSBzdGFibGUgZnJhZ21lbnQgKHRlbXBsYXRlIHJvb3Qgb3IgPHRlbXBsYXRlIHYtZm9yPikgZG9lc24ndCBuZWVkIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBwYXRjaCBjaGlsZHJlbiBvcmRlciwgYnV0IGl0IG1heSBjb250YWluIGR5bmFtaWNDaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgIC8vICMyMDgwIGlmIHRoZSBzdGFibGUgZnJhZ21lbnQgaGFzIGEga2V5LCBpdCdzIGEgPHRlbXBsYXRlIHYtZm9yPiB0aGF0IG1heVxyXG4gICAgICAgICAgICAgICAgLy8gIGdldCBtb3ZlZCBhcm91bmQuIE1ha2Ugc3VyZSBhbGwgcm9vdCBsZXZlbCB2bm9kZXMgaW5oZXJpdCBlbC5cclxuICAgICAgICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxyXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlIGNvbXBvbmVudCBpcyBiZWluZyBtb3ZlZC5cclxuICAgICAgICAgICAgICAgIG4yLmtleSAhPSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHBhcmVudENvbXBvbmVudCAmJiBuMiA9PT0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUgLyogc2hhbGxvdyAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBrZXllZCAvIHVua2V5ZWQsIG9yIG1hbnVhbCBmcmFnbWVudHMuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3Iga2V5ZWQgJiB1bmtleWVkLCBzaW5jZSB0aGV5IGFyZSBjb21waWxlciBnZW5lcmF0ZWQgZnJvbSB2LWZvcixcclxuICAgICAgICAgICAgICAgIC8vIGVhY2ggY2hpbGQgaXMgZ3VhcmFudGVlZCB0byBiZSBhIGJsb2NrIHNvIHRoZSBmcmFnbWVudCB3aWxsIG5ldmVyXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGR5bmFtaWNDaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NDb21wb25lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbjIuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChuMi5zaGFwZUZsYWcgJiA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudC5jdHguYWN0aXZhdGUobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1vdW50Q29tcG9uZW50KG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50Q29tcG9uZW50ID0gKGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IChpbml0aWFsVk5vZGUuY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UoaW5pdGlhbFZOb2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgcmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChpbml0aWFsVk5vZGUpO1xyXG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmplY3QgcmVuZGVyZXIgaW50ZXJuYWxzIGZvciBrZWVwQWxpdmVcclxuICAgICAgICBpZiAoaXNLZWVwQWxpdmUoaW5pdGlhbFZOb2RlKSkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5jdHgucmVuZGVyZXIgPSBpbnRlcm5hbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlc29sdmUgcHJvcHMgYW5kIHNsb3RzIGZvciBzZXR1cCBjb250ZXh0XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0dXBDb21wb25lbnQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldHVwKCkgaXMgYXN5bmMuIFRoaXMgY29tcG9uZW50IHJlbGllcyBvbiBhc3luYyBsb2dpYyB0byBiZSByZXNvbHZlZFxyXG4gICAgICAgIC8vIGJlZm9yZSBwcm9jZWVkaW5nXHJcbiAgICAgICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XHJcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCk7XHJcbiAgICAgICAgICAgIC8vIEdpdmUgaXQgYSBwbGFjZWhvbGRlciBpZiB0aGlzIGlzIG5vdCBoeWRyYXRpb25cclxuICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgc2VsZi1kZWZpbmVkIGZhbGxiYWNrXHJcbiAgICAgICAgICAgIGlmICghaW5pdGlhbFZOb2RlLmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IChpbnN0YW5jZS5zdWJUcmVlID0gY3JlYXRlVk5vZGUoQ29tbWVudCQxKSk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobnVsbCwgcGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXBkYXRlQ29tcG9uZW50ID0gKG4xLCBuMiwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAobjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50KTtcclxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKSkge1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXAgJiZcclxuICAgICAgICAgICAgICAgICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3luYyAmIHN0aWxsIHBlbmRpbmcgLSBqdXN0IHVwZGF0ZSBwcm9wcyBhbmQgc2xvdHNcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjb21wb25lbnQncyByZWFjdGl2ZSBlZmZlY3QgZm9yIHJlbmRlciBpc24ndCBzZXQtdXAgeWV0XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG4yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbCB1cGRhdGVcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLm5leHQgPSBuMjtcclxuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGNoaWxkIGNvbXBvbmVudCBpcyBhbHNvIHF1ZXVlZCwgcmVtb3ZlIGl0IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUgdXBkYXRpbmcgdGhlIHNhbWUgY2hpbGQgY29tcG9uZW50IGluIHRoZSBzYW1lIGZsdXNoLlxyXG4gICAgICAgICAgICAgICAgaW52YWxpZGF0ZUpvYihpbnN0YW5jZS51cGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UudXBkYXRlIGlzIHRoZSByZWFjdGl2ZSBlZmZlY3QgcnVubmVyLlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG5vIHVwZGF0ZSBuZWVkZWQuIGp1c3QgY29weSBvdmVyIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgbjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBpbnN0YW5jZS52bm9kZSA9IG4yO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBzZXR1cFJlbmRlckVmZmVjdCA9IChpbnN0YW5jZSwgaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICAvLyBjcmVhdGUgcmVhY3RpdmUgZWZmZWN0IGZvciByZW5kZXJpbmdcclxuICAgICAgICBpbnN0YW5jZS51cGRhdGUgPSBlZmZlY3QoZnVuY3Rpb24gY29tcG9uZW50RWZmZWN0KCkge1xyXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJtLCBtLCBwYXJlbnQgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlTW91bnQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKGJtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoYm0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZUJlZm9yZU1vdW50XHJcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIGluaXRpYWxWTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgaHlkcmF0ZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBoYXMgYWRvcHRlZCBob3N0IG5vZGUgLSBwZXJmb3JtIGh5ZHJhdGlvbiBpbnN0ZWFkIG9mIG1vdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVTdWJUcmVlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZU5vZGUoZWwsIGluc3RhbmNlLnN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcihpbml0aWFsVk5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZS50eXBlLl9fYXN5bmNMb2FkZXIoKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiB3ZSBhcmUgbW92aW5nIHRoZSByZW5kZXIgY2FsbCBpbnRvIGFuIGFzeW5jIGNhbGxiYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBtZWFucyBpdCB3b24ndCB0cmFjayBkZXBlbmRlbmNpZXMgLSBidXQgaXQncyBvayBiZWNhdXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgc2VydmVyLXJlbmRlcmVkIGFzeW5jIHdyYXBwZXIgaXMgYWxyZWFkeSBpbiByZXNvbHZlZCBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaXQgd2lsbCBuZXZlciBuZWVkIHRvIGNoYW5nZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4gIWluc3RhbmNlLmlzVW5tb3VudGVkICYmIGh5ZHJhdGVTdWJUcmVlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZVN1YlRyZWUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJUcmVlID0gKGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZS5lbCA9IHN1YlRyZWUuZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudGVkIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVNb3VudGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBzY29wZWRJbml0aWFsVk5vZGUpLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmF0ZWQgaG9vayBmb3Iga2VlcC1hbGl2ZSByb290cy5cclxuICAgICAgICAgICAgICAgIC8vICMxNzQyIGFjdGl2YXRlZCBob29rIG11c3QgYmUgYWNjZXNzZWQgYWZ0ZXIgZmlyc3QgcmVuZGVyXHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgaG9vayBtYXkgYmUgaW5qZWN0ZWQgYnkgYSBjaGlsZCBrZWVwLWFsaXZlXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFZOb2RlLnNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChpbnN0YW5jZS5hLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vICMyNDU4OiBkZWZlcmVuY2UgbW91bnQtb25seSBvYmplY3QgcGFyYW1ldGVycyB0byBwcmV2ZW50IG1lbWxlYWtzXHJcbiAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlQ29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRyaWdnZXJlZCBieSBtdXRhdGlvbiBvZiBjb21wb25lbnQncyBvd24gc3RhdGUgKG5leHQ6IG51bGwpXHJcbiAgICAgICAgICAgICAgICAvLyBPUiBwYXJlbnQgY2FsbGluZyBwcm9jZXNzQ29tcG9uZW50IChuZXh0OiBWTm9kZSlcclxuICAgICAgICAgICAgICAgIGxldCB7IG5leHQsIGJ1LCB1LCBwYXJlbnQsIHZub2RlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuZXh0LCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHZub2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlVXBkYXRlIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmIChidSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVCZWZvcmVVcGRhdGVcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IG5leHRUcmVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXRjaChwcmV2VHJlZSwgbmV4dFRyZWUsIFxyXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIHRlbGVwb3J0XHJcbiAgICAgICAgICAgICAgICBob3N0UGFyZW50Tm9kZShwcmV2VHJlZS5lbCksIFxyXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yIG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIGZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICBnZXROZXh0SG9zdE5vZGUocHJldlRyZWUpLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5OZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VsZi10cmlnZ2VyZWQgdXBkYXRlLiBJbiBjYXNlIG9mIEhPQywgdXBkYXRlIHBhcmVudCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBlbC4gSE9DIGlzIGluZGljYXRlZCBieSBwYXJlbnQgaW5zdGFuY2UncyBzdWJUcmVlIHBvaW50aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gY2hpbGQgY29tcG9uZW50J3Mgdm5vZGVcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZWQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKHUpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZVVwZGF0ZWRcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVVcGRhdGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjcmVhdGVEZXZFZmZlY3RPcHRpb25zKGluc3RhbmNlKSA6IHByb2RFZmZlY3RPcHRpb25zKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlLm93bmVySW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyID0gKGluc3RhbmNlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcclxuICAgICAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcclxuICAgICAgICBpbnN0YW5jZS52bm9kZSA9IG5leHRWTm9kZTtcclxuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcclxuICAgICAgICB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgbmV4dFZOb2RlLnByb3BzLCBwcmV2UHJvcHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgdXBkYXRlU2xvdHMoaW5zdGFuY2UsIG5leHRWTm9kZS5jaGlsZHJlbiwgb3B0aW1pemVkKTtcclxuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgLy8gcHJvcHMgdXBkYXRlIG1heSBoYXZlIHRyaWdnZXJlZCBwcmUtZmx1c2ggd2F0Y2hlcnMuXHJcbiAgICAgICAgLy8gZmx1c2ggdGhlbSBiZWZvcmUgdGhlIHJlbmRlciB1cGRhdGUuXHJcbiAgICAgICAgZmx1c2hQcmVGbHVzaENicyh1bmRlZmluZWQsIGluc3RhbmNlLnVwZGF0ZSk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoQ2hpbGRyZW4gPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCBjMSA9IG4xICYmIG4xLmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XHJcbiAgICAgICAgY29uc3QgYzIgPSBuMi5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCB7IHBhdGNoRmxhZywgc2hhcGVGbGFnIH0gPSBuMjtcclxuICAgICAgICAvLyBmYXN0IHBhdGhcclxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGVpdGhlciBmdWxseS1rZXllZCBvciBtaXhlZCAoc29tZSBrZXllZCBzb21lIG5vdClcclxuICAgICAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHBhdGNoRmxhZyBtZWFucyBjaGlsZHJlbiBhcmUgZ3VhcmFudGVlZCB0byBiZSBhcnJheXNcclxuICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhdGNoRmxhZyAmIDI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1bmtleWVkXHJcbiAgICAgICAgICAgICAgICBwYXRjaFVua2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoaWxkcmVuIGhhcyAzIHBvc3NpYmlsaXRpZXM6IHRleHQsIGFycmF5IG9yIG5vIGNoaWxkcmVuLlxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgLy8gdGV4dCBjaGlsZHJlbiBmYXN0IHBhdGhcclxuICAgICAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYzIgIT09IGMxKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCBjMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHByZXYgY2hpbGRyZW4gd2FzIGFycmF5XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0d28gYXJyYXlzLCBjYW5ub3QgYXNzdW1lIGFueXRoaW5nLCBkbyBmdWxsIGRpZmZcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG5ldyBjaGlsZHJlbiwganVzdCB1bm1vdW50IG9sZFxyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmV2IGNoaWxkcmVuIHdhcyB0ZXh0IE9SIG51bGxcclxuICAgICAgICAgICAgICAgIC8vIG5ldyBjaGlsZHJlbiBpcyBhcnJheSBPUiBudWxsXHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdW50IG5ldyBpZiBhcnJheVxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hVbmtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgYzEgPSBjMSB8fCBFTVBUWV9BUlI7XHJcbiAgICAgICAgYzIgPSBjMiB8fCBFTVBUWV9BUlI7XHJcbiAgICAgICAgY29uc3Qgb2xkTGVuZ3RoID0gYzEubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGMyLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBjb21tb25MZW5ndGggPSBNYXRoLm1pbihvbGRMZW5ndGgsIG5ld0xlbmd0aCk7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcclxuICAgICAgICAgICAgcGF0Y2goYzFbaV0sIG5leHRDaGlsZCwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGRcclxuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlLCBmYWxzZSwgY29tbW9uTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG1vdW50IG5ld1xyXG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBjb21tb25MZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBjYW4gYmUgYWxsLWtleWVkIG9yIG1peGVkXHJcbiAgICBjb25zdCBwYXRjaEtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xyXG4gICAgICAgIGxldCBlMSA9IGMxLmxlbmd0aCAtIDE7IC8vIHByZXYgZW5kaW5nIGluZGV4XHJcbiAgICAgICAgbGV0IGUyID0gbDIgLSAxOyAvLyBuZXh0IGVuZGluZyBpbmRleFxyXG4gICAgICAgIC8vIDEuIHN5bmMgZnJvbSBzdGFydFxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyAoYSBiKSBkIGVcclxuICAgICAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4xID0gYzFbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IG4yID0gKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAyLiBzeW5jIGZyb20gZW5kXHJcbiAgICAgICAgLy8gYSAoYiBjKVxyXG4gICAgICAgIC8vIGQgZSAoYiBjKVxyXG4gICAgICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgY29uc3QgbjEgPSBjMVtlMV07XHJcbiAgICAgICAgICAgIGNvbnN0IG4yID0gKGMyW2UyXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltlMl0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2UyXSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZTEtLTtcclxuICAgICAgICAgICAgZTItLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4gY29tbW9uIHNlcXVlbmNlICsgbW91bnRcclxuICAgICAgICAvLyAoYSBiKVxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyBpID0gMiwgZTEgPSAxLCBlMiA9IDJcclxuICAgICAgICAvLyAoYSBiKVxyXG4gICAgICAgIC8vIGMgKGEgYilcclxuICAgICAgICAvLyBpID0gMCwgZTEgPSAtMSwgZTIgPSAwXHJcbiAgICAgICAgaWYgKGkgPiBlMSkge1xyXG4gICAgICAgICAgICBpZiAoaSA8PSBlMikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvcyA9IGUyICsgMTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRQb3MgPCBsMiA/IGMyW25leHRQb3NdLmVsIDogcGFyZW50QW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChudWxsLCAoYzJbaV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNC4gY29tbW9uIHNlcXVlbmNlICsgdW5tb3VudFxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyAoYSBiKVxyXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDIsIGUyID0gMVxyXG4gICAgICAgIC8vIGEgKGIgYylcclxuICAgICAgICAvLyAoYiBjKVxyXG4gICAgICAgIC8vIGkgPSAwLCBlMSA9IDAsIGUyID0gLTFcclxuICAgICAgICBlbHNlIGlmIChpID4gZTIpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPD0gZTEpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoYzFbaV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDUuIHVua25vd24gc2VxdWVuY2VcclxuICAgICAgICAvLyBbaSAuLi4gZTEgKyAxXTogYSBiIFtjIGQgZV0gZiBnXHJcbiAgICAgICAgLy8gW2kgLi4uIGUyICsgMV06IGEgYiBbZSBkIGMgaF0gZiBnXHJcbiAgICAgICAgLy8gaSA9IDIsIGUxID0gNCwgZTIgPSA1XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMxID0gaTsgLy8gcHJldiBzdGFydGluZyBpbmRleFxyXG4gICAgICAgICAgICBjb25zdCBzMiA9IGk7IC8vIG5leHQgc3RhcnRpbmcgaW5kZXhcclxuICAgICAgICAgICAgLy8gNS4xIGJ1aWxkIGtleTppbmRleCBtYXAgZm9yIG5ld0NoaWxkcmVuXHJcbiAgICAgICAgICAgIGNvbnN0IGtleVRvTmV3SW5kZXhNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IHMyOyBpIDw9IGUyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5VG9OZXdJbmRleE1hcC5oYXMobmV4dENoaWxkLmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRHVwbGljYXRlIGtleXMgZm91bmQgZHVyaW5nIHVwZGF0ZTpgLCBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSwgYE1ha2Ugc3VyZSBrZXlzIGFyZSB1bmlxdWUuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGtleVRvTmV3SW5kZXhNYXAuc2V0KG5leHRDaGlsZC5rZXksIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDUuMiBsb29wIHRocm91Z2ggb2xkIGNoaWxkcmVuIGxlZnQgdG8gYmUgcGF0Y2hlZCBhbmQgdHJ5IHRvIHBhdGNoXHJcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIG5vZGVzICYgcmVtb3ZlIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50XHJcbiAgICAgICAgICAgIGxldCBqO1xyXG4gICAgICAgICAgICBsZXQgcGF0Y2hlZCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvQmVQYXRjaGVkID0gZTIgLSBzMiArIDE7XHJcbiAgICAgICAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyB1c2VkIHRvIHRyYWNrIHdoZXRoZXIgYW55IG5vZGUgaGFzIG1vdmVkXHJcbiAgICAgICAgICAgIGxldCBtYXhOZXdJbmRleFNvRmFyID0gMDtcclxuICAgICAgICAgICAgLy8gd29ya3MgYXMgTWFwPG5ld0luZGV4LCBvbGRJbmRleD5cclxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IG9sZEluZGV4IGlzIG9mZnNldCBieSArMVxyXG4gICAgICAgICAgICAvLyBhbmQgb2xkSW5kZXggPSAwIGlzIGEgc3BlY2lhbCB2YWx1ZSBpbmRpY2F0aW5nIHRoZSBuZXcgbm9kZSBoYXNcclxuICAgICAgICAgICAgLy8gbm8gY29ycmVzcG9uZGluZyBvbGQgbm9kZS5cclxuICAgICAgICAgICAgLy8gdXNlZCBmb3IgZGV0ZXJtaW5pbmcgbG9uZ2VzdCBzdGFibGUgc3Vic2VxdWVuY2VcclxuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvQmVQYXRjaGVkOyBpKyspXHJcbiAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBzMTsgaSA8PSBlMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaGVkID49IHRvQmVQYXRjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG5ldyBjaGlsZHJlbiBoYXZlIGJlZW4gcGF0Y2hlZCBzbyB0aGlzIGNhbiBvbmx5IGJlIGEgcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBuZXdJbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2Q2hpbGQua2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGtleVRvTmV3SW5kZXhNYXAuZ2V0KHByZXZDaGlsZC5rZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8ga2V5LWxlc3Mgbm9kZSwgdHJ5IHRvIGxvY2F0ZSBhIGtleS1sZXNzIG5vZGUgb2YgdGhlIHNhbWUgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IHMyOyBqIDw9IGUyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtqIC0gczJdID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NhbWVWTm9kZVR5cGUocHJldkNoaWxkLCBjMltqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbbmV3SW5kZXggLSBzMl0gPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXggPj0gbWF4TmV3SW5kZXhTb0Zhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKHByZXZDaGlsZCwgYzJbbmV3SW5kZXhdLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hlZCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDUuMyBtb3ZlIGFuZCBtb3VudFxyXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBsb25nZXN0IHN0YWJsZSBzdWJzZXF1ZW5jZSBvbmx5IHdoZW4gbm9kZXMgaGF2ZSBtb3ZlZFxyXG4gICAgICAgICAgICBjb25zdCBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZSA9IG1vdmVkXHJcbiAgICAgICAgICAgICAgICA/IGdldFNlcXVlbmNlKG5ld0luZGV4VG9PbGRJbmRleE1hcClcclxuICAgICAgICAgICAgICAgIDogRU1QVFlfQVJSO1xyXG4gICAgICAgICAgICBqID0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgLy8gbG9vcGluZyBiYWNrd2FyZHMgc28gdGhhdCB3ZSBjYW4gdXNlIGxhc3QgcGF0Y2hlZCBub2RlIGFzIGFuY2hvclxyXG4gICAgICAgICAgICBmb3IgKGkgPSB0b0JlUGF0Y2hlZCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBzMiArIGk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltuZXh0SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dEluZGV4ICsgMSA8IGwyID8gYzJbbmV4dEluZGV4ICsgMV0uZWwgOiBwYXJlbnRBbmNob3I7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW91bnQgbmV3XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpZjpcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBzdGFibGUgc3Vic2VxdWVuY2UgKGUuZy4gYSByZXZlcnNlKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9SIGN1cnJlbnQgbm9kZSBpcyBub3QgYW1vbmcgdGhlIHN0YWJsZSBzZXF1ZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBpICE9PSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZVtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlKG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIDIgLyogUkVPUkRFUiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdmUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSwgcGFyZW50U3VzcGVuc2UgPSBudWxsKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBlbCwgdHlwZSwgdHJhbnNpdGlvbiwgY2hpbGRyZW4sIHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICB2bm9kZS5zdXNwZW5zZS5tb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KHZub2RlLmFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcclxuICAgICAgICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzaW5nbGUgbm9kZXNcclxuICAgICAgICBjb25zdCBuZWVkVHJhbnNpdGlvbiA9IG1vdmVUeXBlICE9PSAyIC8qIFJFT1JERVIgKi8gJiZcclxuICAgICAgICAgICAgc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb247XHJcbiAgICAgICAgaWYgKG5lZWRUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChtb3ZlVHlwZSA9PT0gMCAvKiBFTlRFUiAqLykge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gdHJhbnNpdGlvbi5lbnRlcihlbCksIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUsIGFmdGVyTGVhdmUgfSA9IHRyYW5zaXRpb247XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdmUgPSAoKSA9PiBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoZWwsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWxheUxlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXlMZWF2ZShlbCwgcmVtb3ZlLCBwZXJmb3JtTGVhdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybUxlYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdW5tb3VudCA9ICh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCByZWYsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIHNoYXBlRmxhZywgcGF0Y2hGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICAvLyB1bnNldCByZWZcclxuICAgICAgICBpZiAocmVmICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8pIHtcclxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5kZWFjdGl2YXRlKHZub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzaG91bGRJbnZva2VEaXJzID0gc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmIGRpcnM7XHJcbiAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVVbm1vdW50KSkge1xyXG4gICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuc3VzcGVuc2UudW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRJbnZva2VEaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVVbm1vdW50Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50eXBlLnJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkLCBpbnRlcm5hbHMsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkeW5hbWljQ2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgIC8vICMxMTUzOiBmYXN0IHBhdGggc2hvdWxkIG5vdCBiZSB0YWtlbiBmb3Igbm9uLXN0YWJsZSAodi1mb3IpIGZyYWdtZW50c1xyXG4gICAgICAgICAgICAgICAgKHR5cGUgIT09IEZyYWdtZW50IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZhc3QgcGF0aCBmb3IgYmxvY2sgbm9kZXM6IG9ubHkgbmVlZCB0byB1bm1vdW50IGR5bmFtaWMgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oZHluYW1pY0NoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHR5cGUgPT09IEZyYWdtZW50ICYmXHJcbiAgICAgICAgICAgICAgICAocGF0Y2hGbGFnICYgMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnICYgMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi8pKSB8fFxyXG4gICAgICAgICAgICAgICAgKCFvcHRpbWl6ZWQgJiYgc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkb1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKHZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVVbm1vdW50ZWQpIHx8IHNob3VsZEludm9rZURpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIHNob3VsZEludm9rZURpcnMgJiZcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICd1bm1vdW50ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBlbCwgYW5jaG9yLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgcmVtb3ZlRnJhZ21lbnQoZWwsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xyXG4gICAgICAgICAgICByZW1vdmVTdGF0aWNOb2RlKHZub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwZXJmb3JtUmVtb3ZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGVsKTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkICYmIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5hZnRlckxlYXZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgdHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4gbGVhdmUoZWwsIHBlcmZvcm1SZW1vdmUpO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsYXlMZWF2ZSh2bm9kZS5lbCwgcGVyZm9ybVJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwZXJmb3JtUmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZUZyYWdtZW50ID0gKGN1ciwgZW5kKSA9PiB7XHJcbiAgICAgICAgLy8gRm9yIGZyYWdtZW50cywgZGlyZWN0bHkgcmVtb3ZlIGFsbCBjb250YWluZWQgRE9NIG5vZGVzLlxyXG4gICAgICAgIC8vIChmcmFnbWVudCBjaGlsZCBub2RlcyBjYW5ub3QgaGF2ZSB0cmFuc2l0aW9uKVxyXG4gICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGN1cik7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoY3VyKTtcclxuICAgICAgICAgICAgY3VyID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdFJlbW92ZShlbmQpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDb21wb25lbnQgPSAoaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGJ1bSwgZWZmZWN0cywgdXBkYXRlLCBzdWJUcmVlLCB1bSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgLy8gYmVmb3JlVW5tb3VudCBob29rXHJcbiAgICAgICAgaWYgKGJ1bSkge1xyXG4gICAgICAgICAgICBpbnZva2VBcnJheUZucyhidW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWZmZWN0cykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVmZmVjdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHN0b3AoZWZmZWN0c1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdXBkYXRlIG1heSBiZSBudWxsIGlmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgaXRzIGFzeW5jXHJcbiAgICAgICAgLy8gc2V0dXAgaGFzIHJlc29sdmVkLlxyXG4gICAgICAgIGlmICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgc3RvcCh1cGRhdGUpO1xyXG4gICAgICAgICAgICB1bm1vdW50KHN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1bm1vdW50ZWQgaG9va1xyXG4gICAgICAgIGlmICh1bSkge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAvLyBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIGRlcCBpbnNpZGUgYSBwZW5kaW5nIHN1c3BlbnNlIGlzIHVubW91bnRlZCBiZWZvcmVcclxuICAgICAgICAvLyBpdHMgYXN5bmMgZGVwIHJlc29sdmVzLiBUaGlzIHNob3VsZCByZW1vdmUgdGhlIGRlcCBmcm9tIHRoZSBzdXNwZW5zZSwgYW5kXHJcbiAgICAgICAgLy8gY2F1c2UgdGhlIHN1c3BlbnNlIHRvIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgdGhhdCB3YXMgdGhlIGxhc3QgZGVwLlxyXG4gICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJlxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmXHJcbiAgICAgICAgICAgICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCAmJlxyXG4gICAgICAgICAgICAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UsIHN0YXJ0ID0gMCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXROZXh0SG9zdE5vZGUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBob3N0TmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCkpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbmRlciA9ICh2bm9kZSwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNvbnRhaW5lci5fdm5vZGUsIG51bGwsIG51bGwsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaChjb250YWluZXIuX3Zub2RlIHx8IG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIG51bGwsIG51bGwsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcclxuICAgICAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaW50ZXJuYWxzID0ge1xyXG4gICAgICAgIHA6IHBhdGNoLFxyXG4gICAgICAgIHVtOiB1bm1vdW50LFxyXG4gICAgICAgIG06IG1vdmUsXHJcbiAgICAgICAgcjogcmVtb3ZlLFxyXG4gICAgICAgIG10OiBtb3VudENvbXBvbmVudCxcclxuICAgICAgICBtYzogbW91bnRDaGlsZHJlbixcclxuICAgICAgICBwYzogcGF0Y2hDaGlsZHJlbixcclxuICAgICAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcclxuICAgICAgICBuOiBnZXROZXh0SG9zdE5vZGUsXHJcbiAgICAgICAgbzogb3B0aW9uc1xyXG4gICAgfTtcclxuICAgIGxldCBoeWRyYXRlO1xyXG4gICAgbGV0IGh5ZHJhdGVOb2RlO1xyXG4gICAgaWYgKGNyZWF0ZUh5ZHJhdGlvbkZucykge1xyXG4gICAgICAgIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV0gPSBjcmVhdGVIeWRyYXRpb25GbnMoaW50ZXJuYWxzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVuZGVyLFxyXG4gICAgICAgIGh5ZHJhdGUsXHJcbiAgICAgICAgY3JlYXRlQXBwOiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbnZva2VWTm9kZUhvb2soaG9vaywgaW5zdGFuY2UsIHZub2RlLCBwcmV2Vk5vZGUgPSBudWxsKSB7XHJcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgNyAvKiBWTk9ERV9IT09LICovLCBbXHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgcHJldlZOb2RlXHJcbiAgICBdKTtcclxufVxyXG4vKipcclxuICogIzExNTZcclxuICogV2hlbiBhIGNvbXBvbmVudCBpcyBITVItZW5hYmxlZCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBhbGwgc3RhdGljIG5vZGVzXHJcbiAqIGluc2lkZSBhIGJsb2NrIGFsc28gaW5oZXJpdCB0aGUgRE9NIGVsZW1lbnQgZnJvbSB0aGUgcHJldmlvdXMgdHJlZSBzbyB0aGF0XHJcbiAqIEhNUiB1cGRhdGVzICh3aGljaCBhcmUgZnVsbCB1cGRhdGVzKSBjYW4gcmV0cmlldmUgdGhlIGVsZW1lbnQgZm9yIHBhdGNoaW5nLlxyXG4gKlxyXG4gKiAjMjA4MFxyXG4gKiBJbnNpZGUga2V5ZWQgYHRlbXBsYXRlYCBmcmFnbWVudCBzdGF0aWMgY2hpbGRyZW4sIGlmIGEgZnJhZ21lbnQgaXMgbW92ZWQsXHJcbiAqIHRoZSBjaGlsZHJlbiB3aWxsIGFsd2F5cyBtb3ZlZCBzbyB0aGF0IG5lZWQgaW5oZXJpdCBlbCBmb3JtIHByZXZpb3VzIG5vZGVzXHJcbiAqIHRvIGVuc3VyZSBjb3JyZWN0IG1vdmVkIHBvc2l0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgY2gxID0gbjEuY2hpbGRyZW47XHJcbiAgICBjb25zdCBjaDIgPSBuMi5jaGlsZHJlbjtcclxuICAgIGlmIChpc0FycmF5KGNoMSkgJiYgaXNBcnJheShjaDIpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaDEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBvbmx5IGNhbGxlZCBpbiB0aGUgb3B0aW1pemVkIHBhdGggc28gYXJyYXkgY2hpbGRyZW4gYXJlXHJcbiAgICAgICAgICAgIC8vIGd1YXJhbnRlZWQgdG8gYmUgdm5vZGVzXHJcbiAgICAgICAgICAgIGNvbnN0IGMxID0gY2gxW2ldO1xyXG4gICAgICAgICAgICBsZXQgYzIgPSBjaDJbaV07XHJcbiAgICAgICAgICAgIGlmIChjMi5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiYgIWMyLmR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGMyLnBhdGNoRmxhZyA8PSAwIHx8IGMyLnBhdGNoRmxhZyA9PT0gMzIgLyogSFlEUkFURV9FVkVOVFMgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjMiA9IGNoMltpXSA9IGNsb25lSWZNb3VudGVkKGNoMltpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYzIuZWwgPSBjMS5lbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghc2hhbGxvdylcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKGMxLCBjMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYWxzbyBpbmhlcml0IGZvciBjb21tZW50IG5vZGVzLCBidXQgbm90IHBsYWNlaG9sZGVycyAoZS5nLiB2LWlmIHdoaWNoXHJcbiAgICAgICAgICAgIC8vIHdvdWxkIGhhdmUgcmVjZWl2ZWQgLmVsIGR1cmluZyBibG9jayBwYXRjaClcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjMi50eXBlID09PSBDb21tZW50JDEgJiYgIWMyLmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvbmdlc3RfaW5jcmVhc2luZ19zdWJzZXF1ZW5jZVxyXG5mdW5jdGlvbiBnZXRTZXF1ZW5jZShhcnIpIHtcclxuICAgIGNvbnN0IHAgPSBhcnIuc2xpY2UoKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFswXTtcclxuICAgIGxldCBpLCBqLCB1LCB2LCBjO1xyXG4gICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XHJcbiAgICAgICAgaWYgKGFyckkgIT09IDApIHtcclxuICAgICAgICAgICAgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICBwW2ldID0gajtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdSA9IDA7XHJcbiAgICAgICAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgd2hpbGUgKHUgPCB2KSB7XHJcbiAgICAgICAgICAgICAgICBjID0gKCh1ICsgdikgLyAyKSB8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IGMgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFyckkgPCBhcnJbcmVzdWx0W3VdXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbdV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdSA9IHJlc3VsdC5sZW5ndGg7XHJcbiAgICB2ID0gcmVzdWx0W3UgLSAxXTtcclxuICAgIHdoaWxlICh1LS0gPiAwKSB7XHJcbiAgICAgICAgcmVzdWx0W3VdID0gdjtcclxuICAgICAgICB2ID0gcFt2XTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cblxuY29uc3QgaXNUZWxlcG9ydCA9ICh0eXBlKSA9PiB0eXBlLl9faXNUZWxlcG9ydDtcclxuY29uc3QgaXNUZWxlcG9ydERpc2FibGVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuZGlzYWJsZWQgPT09ICcnKTtcclxuY29uc3QgaXNUYXJnZXRTVkcgPSAodGFyZ2V0KSA9PiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcclxuY29uc3QgcmVzb2x2ZVRhcmdldCA9IChwcm9wcywgc2VsZWN0KSA9PiB7XHJcbiAgICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xyXG4gICAgaWYgKGlzU3RyaW5nKHRhcmdldFNlbGVjdG9yKSkge1xyXG4gICAgICAgIGlmICghc2VsZWN0KSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQ3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyB0YXJnZXQgZm9yIFRlbGVwb3J0cy4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYChtaXNzaW5nIHF1ZXJ5U2VsZWN0b3IgcmVuZGVyZXIgb3B0aW9uKWApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdCh0YXJnZXRTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBOb3RlIHRoZSB0YXJnZXQgZWxlbWVudCBtdXN0IGV4aXN0IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgLSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGkuZS4gdGhlIHRhcmdldCBjYW5ub3QgYmUgcmVuZGVyZWQgYnkgdGhlIGNvbXBvbmVudCBpdHNlbGYsIGFuZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICF0YXJnZXRTZWxlY3RvciAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIFRlbGVwb3J0IHRhcmdldDogJHt0YXJnZXRTZWxlY3Rvcn1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XHJcbiAgICBfX2lzVGVsZXBvcnQ6IHRydWUsXHJcbiAgICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKSB7XHJcbiAgICAgICAgY29uc3QgeyBtYzogbW91bnRDaGlsZHJlbiwgcGM6IHBhdGNoQ2hpbGRyZW4sIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLCBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9IH0gPSBpbnRlcm5hbHM7XHJcbiAgICAgICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xyXG4gICAgICAgIGxldCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiB9ID0gbjI7XHJcbiAgICAgICAgLy8gIzMzMDJcclxuICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBpbnNlcnQgYW5jaG9ycyBpbiB0aGUgbWFpbiB2aWV3XHJcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKG4yLmVsID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbW1lbnQoJ3RlbGVwb3J0IHN0YXJ0JylcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21tZW50KCd0ZWxlcG9ydCBlbmQnKVxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgICAgIGluc2VydChwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSAobjIudGFyZ2V0QW5jaG9yID0gY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnQodGFyZ2V0QW5jaG9yLCB0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgLy8gIzI2NTIgd2UgY291bGQgYmUgdGVsZXBvcnRpbmcgZnJvbSBhIG5vbi1TVkcgdHJlZSBpbnRvIGFuIFNWRyB0cmVlXHJcbiAgICAgICAgICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gbW91bnQ6JywgdGFyZ2V0LCBgKCR7dHlwZW9mIHRhcmdldH0pYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbW91bnQgPSAoY29udGFpbmVyLCBhbmNob3IpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFRlbGVwb3J0ICphbHdheXMqIGhhcyBBcnJheSBjaGlsZHJlbi4gVGhpcyBpcyBlbmZvcmNlZCBpbiBib3RoIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZXIgYW5kIHZub2RlIGNoaWxkcmVuIG5vcm1hbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudChjb250YWluZXIsIG1haW5BbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgY29udGVudFxyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xLmFuY2hvcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChuMi50YXJnZXQgPSBuMS50YXJnZXQpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSAobjIudGFyZ2V0QW5jaG9yID0gbjEudGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICAgICAgY29uc3Qgd2FzRGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjEucHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyID0gd2FzRGlzYWJsZWQgPyBjb250YWluZXIgOiB0YXJnZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSB3YXNEaXNhYmxlZCA/IG1haW5BbmNob3IgOiB0YXJnZXRBbmNob3I7XHJcbiAgICAgICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gZmFzdCBwYXRoIHdoZW4gdGhlIHRlbGVwb3J0IGhhcHBlbnMgdG8gYmUgYSBibG9jayByb290XHJcbiAgICAgICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGN1cnJlbnRDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpbiBibG9jayB0cmVlIG1vZGUgd2UgbmVlZCB0byBtYWtlIHN1cmUgYWxsIHJvb3QtbGV2ZWwgbm9kZXNcclxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSB0ZWxlcG9ydCBpbmhlcml0IHByZXZpb3VzIERPTSByZWZlcmVuY2VzIHNvIHRoYXQgdGhleSBjYW5cclxuICAgICAgICAgICAgICAgIC8vIGJlIG1vdmVkIGluIGZ1dHVyZSBwYXRjaGVzLlxyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjdXJyZW50Q29udGFpbmVyLCBjdXJyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXdhc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlZCAtPiBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byBtYWluIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgY29udGFpbmVyLCBtYWluQW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVE9HR0xFICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHRhcmdldCBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgbmV4dFRhcmdldCwgbnVsbCwgaW50ZXJuYWxzLCAwIC8qIFRBUkdFVF9DSEFOR0UgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOicsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgLT4gZW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byB0ZWxlcG9ydCB0YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIHRhcmdldCwgdGFyZ2V0QW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVE9HR0xFICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgeyB1bTogdW5tb3VudCwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9LCBkb1JlbW92ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgYW5jaG9yLCB0YXJnZXRBbmNob3IsIHRhcmdldCwgcHJvcHMgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZSh0YXJnZXRBbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbiB1bm1vdW50ZWQgdGVsZXBvcnQgc2hvdWxkIGFsd2F5cyByZW1vdmUgaXRzIGNoaWxkcmVuIGlmIG5vdCBkaXNhYmxlZFxyXG4gICAgICAgIGlmIChkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGFuY2hvcik7XHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChjaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSwgISFjaGlsZC5keW5hbWljQ2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdmU6IG1vdmVUZWxlcG9ydCxcclxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxyXG59O1xyXG5mdW5jdGlvbiBtb3ZlVGVsZXBvcnQodm5vZGUsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCB7IG86IHsgaW5zZXJ0IH0sIG06IG1vdmUgfSwgbW92ZVR5cGUgPSAyIC8qIFJFT1JERVIgKi8pIHtcclxuICAgIC8vIG1vdmUgdGFyZ2V0IGFuY2hvciBpZiB0aGlzIGlzIGEgdGFyZ2V0IGNoYW5nZS5cclxuICAgIGlmIChtb3ZlVHlwZSA9PT0gMCAvKiBUQVJHRVRfQ0hBTkdFICovKSB7XHJcbiAgICAgICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBlbCwgYW5jaG9yLCBzaGFwZUZsYWcsIGNoaWxkcmVuLCBwcm9wcyB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMiAvKiBSRU9SREVSICovO1xyXG4gICAgLy8gbW92ZSBtYWluIHZpZXcgYW5jaG9yIGlmIHRoaXMgaXMgYSByZS1vcmRlci5cclxuICAgIGlmIChpc1Jlb3JkZXIpIHtcclxuICAgICAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxuICAgIC8vIGlmIHRoaXMgaXMgYSByZS1vcmRlciBhbmQgdGVsZXBvcnQgaXMgZW5hYmxlZCAoY29udGVudCBpcyBpbiB0YXJnZXQpXHJcbiAgICAvLyBkbyBub3QgbW92ZSBjaGlsZHJlbi4gU28gdGhlIG9wcG9zaXRlIGlzOiBvbmx5IG1vdmUgY2hpbGRyZW4gaWYgdGhpc1xyXG4gICAgLy8gaXMgbm90IGEgcmVvcmRlciwgb3IgdGhlIHRlbGVwb3J0IGlzIGRpc2FibGVkXHJcbiAgICBpZiAoIWlzUmVvcmRlciB8fCBpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XHJcbiAgICAgICAgLy8gVGVsZXBvcnQgaGFzIGVpdGhlciBBcnJheSBjaGlsZHJlbiBvciBubyBjaGlsZHJlbi5cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIDIgLyogUkVPUkRFUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBtb3ZlIG1haW4gdmlldyBhbmNob3IgaWYgdGhpcyBpcyBhIHJlLW9yZGVyLlxyXG4gICAgaWYgKGlzUmVvcmRlcikge1xyXG4gICAgICAgIGluc2VydChhbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoeWRyYXRlVGVsZXBvcnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IG86IHsgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHF1ZXJ5U2VsZWN0b3IgfSB9LCBoeWRyYXRlQ2hpbGRyZW4pIHtcclxuICAgIGNvbnN0IHRhcmdldCA9ICh2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KHZub2RlLnByb3BzLCBxdWVyeVNlbGVjdG9yKSk7XHJcbiAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gaWYgbXVsdGlwbGUgdGVsZXBvcnRzIHJlbmRlcmVkIHRvIHRoZSBzYW1lIHRhcmdldCBlbGVtZW50LCB3ZSBuZWVkIHRvXHJcbiAgICAgICAgLy8gcGljayB1cCBmcm9tIHdoZXJlIHRoZSBsYXN0IHRlbGVwb3J0IGZpbmlzaGVkIGluc3RlYWQgb2YgdGhlIGZpcnN0IG5vZGVcclxuICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gdGFyZ2V0Ll9scGEgfHwgdGFyZ2V0LmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1RlbGVwb3J0RGlzYWJsZWQodm5vZGUucHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4obmV4dFNpYmxpbmcobm9kZSksIHZub2RlLCBwYXJlbnROb2RlKG5vZGUpLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4odGFyZ2V0Tm9kZSwgdm5vZGUsIHRhcmdldCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhcmdldC5fbHBhID1cclxuICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZS5hbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yKTtcclxufVxyXG4vLyBGb3JjZS1jYXN0ZWQgcHVibGljIHR5cGluZyBmb3IgaCBhbmQgVFNYIHByb3BzIGluZmVyZW5jZVxyXG5jb25zdCBUZWxlcG9ydCA9IFRlbGVwb3J0SW1wbDtcblxuY29uc3QgQ09NUE9ORU5UUyA9ICdjb21wb25lbnRzJztcclxuY29uc3QgRElSRUNUSVZFUyA9ICdkaXJlY3RpdmVzJztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KG5hbWUsIG1heWJlU2VsZlJlZmVyZW5jZSkge1xyXG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBuYW1lLCB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UpIHx8IG5hbWU7XHJcbn1cclxuY29uc3QgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCA9IFN5bWJvbCgpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgaWYgKGlzU3RyaW5nKGNvbXBvbmVudCkpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIGNvbXBvbmVudCwgZmFsc2UpIHx8IGNvbXBvbmVudDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGludmFsaWQgdHlwZXMgd2lsbCBmYWxsdGhyb3VnaCB0byBjcmVhdGVWTm9kZSBhbmQgcmFpc2Ugd2FybmluZ1xyXG4gICAgICAgIHJldHVybiAoY29tcG9uZW50IHx8IE5VTExfRFlOQU1JQ19DT01QT05FTlQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZURpcmVjdGl2ZShuYW1lKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KERJUkVDVElWRVMsIG5hbWUpO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB8fCBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgICAgIC8vIGV4cGxpY2l0IHNlbGYgbmFtZSBoYXMgaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGZOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZk5hbWUgJiZcclxuICAgICAgICAgICAgICAgIChzZWxmTmFtZSA9PT0gbmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYW1lbGl6ZShuYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzID0gXHJcbiAgICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgLy8gY2hlY2sgaW5zdGFuY2VbdHlwZV0gZmlyc3Qgd2hpY2ggaXMgcmVzb2x2ZWQgZm9yIG9wdGlvbnMgQVBJXHJcbiAgICAgICAgcmVzb2x2ZShpbnN0YW5jZVt0eXBlXSB8fCBDb21wb25lbnRbdHlwZV0sIG5hbWUpIHx8XHJcbiAgICAgICAgICAgIC8vIGdsb2JhbCByZWdpc3RyYXRpb25cclxuICAgICAgICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKTtcclxuICAgICAgICBpZiAoIXJlcyAmJiBtYXliZVNlbGZSZWZlcmVuY2UpIHtcclxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gaW1wbGljaXQgc2VsZi1yZWZlcmVuY2VcclxuICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byByZXNvbHZlICR7dHlwZS5zbGljZSgwLCAtMSl9OiAke25hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGByZXNvbHZlJHtjYXBpdGFsaXplKHR5cGUuc2xpY2UoMCwgLTEpKX0gYCArXHJcbiAgICAgICAgICAgIGBjYW4gb25seSBiZSB1c2VkIGluIHJlbmRlcigpIG9yIHNldHVwKCkuYCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZShyZWdpc3RyeSwgbmFtZSkge1xyXG4gICAgcmV0dXJuIChyZWdpc3RyeSAmJlxyXG4gICAgICAgIChyZWdpc3RyeVtuYW1lXSB8fFxyXG4gICAgICAgICAgICByZWdpc3RyeVtjYW1lbGl6ZShuYW1lKV0gfHxcclxuICAgICAgICAgICAgcmVnaXN0cnlbY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSldKSk7XHJcbn1cblxuY29uc3QgRnJhZ21lbnQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ0ZyYWdtZW50JyA6IHVuZGVmaW5lZCk7XHJcbmNvbnN0IFRleHQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ1RleHQnIDogdW5kZWZpbmVkKTtcclxuY29uc3QgQ29tbWVudCQxID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdDb21tZW50JyA6IHVuZGVmaW5lZCk7XHJcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnU3RhdGljJyA6IHVuZGVmaW5lZCk7XHJcbi8vIFNpbmNlIHYtaWYgYW5kIHYtZm9yIGFyZSB0aGUgdHdvIHBvc3NpYmxlIHdheXMgbm9kZSBzdHJ1Y3R1cmUgY2FuIGR5bmFtaWNhbGx5XHJcbi8vIGNoYW5nZSwgb25jZSB3ZSBjb25zaWRlciB2LWlmIGJyYW5jaGVzIGFuZCBlYWNoIHYtZm9yIGZyYWdtZW50IGEgYmxvY2ssIHdlXHJcbi8vIGNhbiBkaXZpZGUgYSB0ZW1wbGF0ZSBpbnRvIG5lc3RlZCBibG9ja3MsIGFuZCB3aXRoaW4gZWFjaCBibG9jayB0aGUgbm9kZVxyXG4vLyBzdHJ1Y3R1cmUgd291bGQgYmUgc3RhYmxlLiBUaGlzIGFsbG93cyB1cyB0byBza2lwIG1vc3QgY2hpbGRyZW4gZGlmZmluZ1xyXG4vLyBhbmQgb25seSB3b3JyeSBhYm91dCB0aGUgZHluYW1pYyBub2RlcyAoaW5kaWNhdGVkIGJ5IHBhdGNoIGZsYWdzKS5cclxuY29uc3QgYmxvY2tTdGFjayA9IFtdO1xyXG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcclxuLyoqXHJcbiAqIE9wZW4gYSBibG9jay5cclxuICogVGhpcyBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYC4gSXQgY2Fubm90IGJlIHBhcnQgb2YgYGNyZWF0ZUJsb2NrYFxyXG4gKiBiZWNhdXNlIHRoZSBjaGlsZHJlbiBvZiB0aGUgYmxvY2sgYXJlIGV2YWx1YXRlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYCBpdHNlbGZcclxuICogaXMgY2FsbGVkLiBUaGUgZ2VuZXJhdGVkIGNvZGUgdHlwaWNhbGx5IGxvb2tzIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gKiAgIHJldHVybiAob3BlbkJsb2NrKCksY3JlYXRlQmxvY2soJ2RpdicsIG51bGwsIFsuLi5dKSlcclxuICogfVxyXG4gKiBgYGBcclxuICogZGlzYWJsZVRyYWNraW5nIGlzIHRydWUgd2hlbiBjcmVhdGluZyBhIHYtZm9yIGZyYWdtZW50IGJsb2NrLCBzaW5jZSBhIHYtZm9yXHJcbiAqIGZyYWdtZW50IGFsd2F5cyBkaWZmcyBpdHMgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBvcGVuQmxvY2soZGlzYWJsZVRyYWNraW5nID0gZmFsc2UpIHtcclxuICAgIGJsb2NrU3RhY2sucHVzaCgoY3VycmVudEJsb2NrID0gZGlzYWJsZVRyYWNraW5nID8gbnVsbCA6IFtdKSk7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcclxuICAgIGJsb2NrU3RhY2sucG9wKCk7XHJcbiAgICBjdXJyZW50QmxvY2sgPSBibG9ja1N0YWNrW2Jsb2NrU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbDtcclxufVxyXG4vLyBXaGV0aGVyIHdlIHNob3VsZCBiZSB0cmFja2luZyBkeW5hbWljIGNoaWxkIG5vZGVzIGluc2lkZSBhIGJsb2NrLlxyXG4vLyBPbmx5IHRyYWNrcyB3aGVuIHRoaXMgdmFsdWUgaXMgPiAwXHJcbi8vIFdlIGFyZSBub3QgdXNpbmcgYSBzaW1wbGUgYm9vbGVhbiBiZWNhdXNlIHRoaXMgdmFsdWUgbWF5IG5lZWQgdG8gYmVcclxuLy8gaW5jcmVtZW50ZWQvZGVjcmVtZW50ZWQgYnkgbmVzdGVkIHVzYWdlIG9mIHYtb25jZSAoc2VlIGJlbG93KVxyXG5sZXQgaXNCbG9ja1RyZWVFbmFibGVkID0gMTtcclxuLyoqXHJcbiAqIEJsb2NrIHRyYWNraW5nIHNvbWV0aW1lcyBuZWVkcyB0byBiZSBkaXNhYmxlZCwgZm9yIGV4YW1wbGUgZHVyaW5nIHRoZVxyXG4gKiBjcmVhdGlvbiBvZiBhIHRyZWUgdGhhdCBuZWVkcyB0byBiZSBjYWNoZWQgYnkgdi1vbmNlLiBUaGUgY29tcGlsZXIgZ2VuZXJhdGVzXHJcbiAqIGNvZGUgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGAganNcclxuICogX2NhY2hlWzFdIHx8IChcclxuICogICBzZXRCbG9ja1RyYWNraW5nKC0xKSxcclxuICogICBfY2FjaGVbMV0gPSBjcmVhdGVWTm9kZSguLi4pLFxyXG4gKiAgIHNldEJsb2NrVHJhY2tpbmcoMSksXHJcbiAqICAgX2NhY2hlWzFdXHJcbiAqIClcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRCbG9ja1RyYWNraW5nKHZhbHVlKSB7XHJcbiAgICBpc0Jsb2NrVHJlZUVuYWJsZWQgKz0gdmFsdWU7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGJsb2NrIHJvb3Qgdm5vZGUuIFRha2VzIHRoZSBzYW1lIGV4YWN0IGFyZ3VtZW50cyBhcyBgY3JlYXRlVk5vZGVgLlxyXG4gKiBBIGJsb2NrIHJvb3Qga2VlcHMgdHJhY2sgb2YgZHluYW1pYyBub2RlcyB3aXRoaW4gdGhlIGJsb2NrIGluIHRoZVxyXG4gKiBgZHluYW1pY0NoaWxkcmVuYCBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMpIHtcclxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgdHJ1ZSAvKiBpc0Jsb2NrOiBwcmV2ZW50IGEgYmxvY2sgZnJvbSB0cmFja2luZyBpdHNlbGYgKi8pO1xyXG4gICAgLy8gc2F2ZSBjdXJyZW50IGJsb2NrIGNoaWxkcmVuIG9uIHRoZSBibG9jayB2bm9kZVxyXG4gICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID1cclxuICAgICAgICBpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwID8gY3VycmVudEJsb2NrIHx8IEVNUFRZX0FSUiA6IG51bGw7XHJcbiAgICAvLyBjbG9zZSBibG9ja1xyXG4gICAgY2xvc2VCbG9jaygpO1xyXG4gICAgLy8gYSBibG9jayBpcyBhbHdheXMgZ29pbmcgdG8gYmUgcGF0Y2hlZCwgc28gdHJhY2sgaXQgYXMgYSBjaGlsZCBvZiBpdHNcclxuICAgIC8vIHBhcmVudCBibG9ja1xyXG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XHJcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIGlzVk5vZGUodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlLl9fdl9pc1ZOb2RlID09PSB0cnVlIDogZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIG4yLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovICYmXHJcbiAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmhhcyhuMi50eXBlKSkge1xyXG4gICAgICAgIC8vIEhNUiBvbmx5OiBpZiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGhvdC11cGRhdGVkLCBmb3JjZSBhIHJlbG9hZC5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbjEudHlwZSA9PT0gbjIudHlwZSAmJiBuMS5rZXkgPT09IG4yLmtleTtcclxufVxyXG5sZXQgdm5vZGVBcmdzVHJhbnNmb3JtZXI7XHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBBUEkgZm9yIHJlZ2lzdGVyaW5nIGFuIGFyZ3VtZW50cyB0cmFuc2Zvcm0gZm9yIGNyZWF0ZVZOb2RlXHJcbiAqIHVzZWQgZm9yIGNyZWF0aW5nIHN0dWJzIGluIHRoZSB0ZXN0LXV0aWxzXHJcbiAqIEl0IGlzICppbnRlcm5hbCogYnV0IG5lZWRzIHRvIGJlIGV4cG9zZWQgZm9yIHRlc3QtdXRpbHMgdG8gcGljayB1cCBwcm9wZXJcclxuICogdHlwaW5nc1xyXG4gKi9cclxuZnVuY3Rpb24gdHJhbnNmb3JtVk5vZGVBcmdzKHRyYW5zZm9ybWVyKSB7XHJcbiAgICB2bm9kZUFyZ3NUcmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyO1xyXG59XHJcbmNvbnN0IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gPSAoLi4uYXJncykgPT4ge1xyXG4gICAgcmV0dXJuIF9jcmVhdGVWTm9kZSguLi4odm5vZGVBcmdzVHJhbnNmb3JtZXJcclxuICAgICAgICA/IHZub2RlQXJnc1RyYW5zZm9ybWVyKGFyZ3MsIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSlcclxuICAgICAgICA6IGFyZ3MpKTtcclxufTtcclxuY29uc3QgSW50ZXJuYWxPYmplY3RLZXkgPSBgX192SW50ZXJuYWxgO1xyXG5jb25zdCBub3JtYWxpemVLZXkgPSAoeyBrZXkgfSkgPT4ga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsO1xyXG5jb25zdCBub3JtYWxpemVSZWYgPSAoeyByZWYgfSkgPT4ge1xyXG4gICAgcmV0dXJuIChyZWYgIT0gbnVsbFxyXG4gICAgICAgID8gaXNTdHJpbmcocmVmKSB8fCBpc1JlZihyZWYpIHx8IGlzRnVuY3Rpb24kMShyZWYpXHJcbiAgICAgICAgICAgID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiB9XHJcbiAgICAgICAgICAgIDogcmVmXHJcbiAgICAgICAgOiBudWxsKTtcclxufTtcclxuY29uc3QgY3JlYXRlVk5vZGUgPSAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICA/IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm1cclxuICAgIDogX2NyZWF0ZVZOb2RlKTtcclxuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XHJcbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXR5cGUpIHtcclxuICAgICAgICAgICAgd2FybihgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHR5cGUgPSBDb21tZW50JDE7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNWTm9kZSh0eXBlKSkge1xyXG4gICAgICAgIC8vIGNyZWF0ZVZOb2RlIHJlY2VpdmluZyBhbiBleGlzdGluZyB2bm9kZS4gVGhpcyBoYXBwZW5zIGluIGNhc2VzIGxpa2VcclxuICAgICAgICAvLyA8Y29tcG9uZW50IDppcz1cInZub2RlXCIvPlxyXG4gICAgICAgIC8vICMyMDc4IG1ha2Ugc3VyZSB0byBtZXJnZSByZWZzIGR1cmluZyB0aGUgY2xvbmUgaW5zdGVhZCBvZiBvdmVyd3JpdGluZyBpdFxyXG4gICAgICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodHlwZSwgcHJvcHMsIHRydWUgLyogbWVyZ2VSZWY6IHRydWUgKi8pO1xyXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgICAgICBub3JtYWxpemVDaGlsZHJlbihjbG9uZWQsIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcclxuICAgIH1cclxuICAgIC8vIGNsYXNzIGNvbXBvbmVudCBub3JtYWxpemF0aW9uLlxyXG4gICAgaWYgKGlzQ2xhc3NDb21wb25lbnQodHlwZSkpIHtcclxuICAgICAgICB0eXBlID0gdHlwZS5fX3ZjY09wdHM7XHJcbiAgICB9XHJcbiAgICAvLyBjbGFzcyAmIHN0eWxlIG5vcm1hbGl6YXRpb24uXHJcbiAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAvLyBmb3IgcmVhY3RpdmUgb3IgcHJveHkgb2JqZWN0cywgd2UgbmVlZCB0byBjbG9uZSBpdCB0byBlbmFibGUgbXV0YXRpb24uXHJcbiAgICAgICAgaWYgKGlzUHJveHkocHJvcHMpIHx8IEludGVybmFsT2JqZWN0S2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgIHByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xyXG4gICAgICAgIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XHJcbiAgICAgICAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNPYmplY3QkMShzdHlsZSkpIHtcclxuICAgICAgICAgICAgLy8gcmVhY3RpdmUgc3RhdGUgb2JqZWN0cyBuZWVkIHRvIGJlIGNsb25lZCBzaW5jZSB0aGV5IGFyZSBsaWtlbHkgdG8gYmVcclxuICAgICAgICAgICAgLy8gbXV0YXRlZFxyXG4gICAgICAgICAgICBpZiAoaXNQcm94eShzdHlsZSkgJiYgIWlzQXJyYXkoc3R5bGUpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZSA9IGV4dGVuZCh7fSwgc3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGVuY29kZSB0aGUgdm5vZGUgdHlwZSBpbmZvcm1hdGlvbiBpbnRvIGEgYml0bWFwXHJcbiAgICBjb25zdCBzaGFwZUZsYWcgPSBpc1N0cmluZyh0eXBlKVxyXG4gICAgICAgID8gMSAvKiBFTEVNRU5UICovXHJcbiAgICAgICAgOiBpc1N1c3BlbnNlKHR5cGUpXHJcbiAgICAgICAgICAgID8gMTI4IC8qIFNVU1BFTlNFICovXHJcbiAgICAgICAgICAgIDogaXNUZWxlcG9ydCh0eXBlKVxyXG4gICAgICAgICAgICAgICAgPyA2NCAvKiBURUxFUE9SVCAqL1xyXG4gICAgICAgICAgICAgICAgOiBpc09iamVjdCQxKHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbiQxKHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMiAvKiBGVU5DVElPTkFMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovICYmIGlzUHJveHkodHlwZSkpIHtcclxuICAgICAgICB0eXBlID0gdG9SYXcodHlwZSk7XHJcbiAgICAgICAgd2FybihgVnVlIHJlY2VpdmVkIGEgQ29tcG9uZW50IHdoaWNoIHdhcyBtYWRlIGEgcmVhY3RpdmUgb2JqZWN0LiBUaGlzIGNhbiBgICtcclxuICAgICAgICAgICAgYGxlYWQgdG8gdW5uZWNlc3NhcnkgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQsIGFuZCBzaG91bGQgYmUgYXZvaWRlZCBieSBgICtcclxuICAgICAgICAgICAgYG1hcmtpbmcgdGhlIGNvbXBvbmVudCB3aXRoIFxcYG1hcmtSYXdcXGAgb3IgdXNpbmcgXFxgc2hhbGxvd1JlZlxcYCBgICtcclxuICAgICAgICAgICAgYGluc3RlYWQgb2YgXFxgcmVmXFxgLmAsIGBcXG5Db21wb25lbnQgdGhhdCB3YXMgbWFkZSByZWFjdGl2ZTogYCwgdHlwZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2bm9kZSA9IHtcclxuICAgICAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcclxuICAgICAgICBfX3Zfc2tpcDogdHJ1ZSxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcclxuICAgICAgICByZWY6IHByb3BzICYmIG5vcm1hbGl6ZVJlZihwcm9wcyksXHJcbiAgICAgICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXHJcbiAgICAgICAgc2xvdFNjb3BlSWRzOiBudWxsLFxyXG4gICAgICAgIGNoaWxkcmVuOiBudWxsLFxyXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcclxuICAgICAgICBzdXNwZW5zZTogbnVsbCxcclxuICAgICAgICBzc0NvbnRlbnQ6IG51bGwsXHJcbiAgICAgICAgc3NGYWxsYmFjazogbnVsbCxcclxuICAgICAgICBkaXJzOiBudWxsLFxyXG4gICAgICAgIHRyYW5zaXRpb246IG51bGwsXHJcbiAgICAgICAgZWw6IG51bGwsXHJcbiAgICAgICAgYW5jaG9yOiBudWxsLFxyXG4gICAgICAgIHRhcmdldDogbnVsbCxcclxuICAgICAgICB0YXJnZXRBbmNob3I6IG51bGwsXHJcbiAgICAgICAgc2hhcGVGbGFnLFxyXG4gICAgICAgIHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcHMsXHJcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuOiBudWxsLFxyXG4gICAgICAgIGFwcENvbnRleHQ6IG51bGxcclxuICAgIH07XHJcbiAgICAvLyB2YWxpZGF0ZSBrZXlcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdm5vZGUua2V5ICE9PSB2bm9kZS5rZXkpIHtcclxuICAgICAgICB3YXJuKGBWTm9kZSBjcmVhdGVkIHdpdGggaW52YWxpZCBrZXkgKE5hTikuIFZOb2RlIHR5cGU6YCwgdm5vZGUudHlwZSk7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pO1xyXG4gICAgLy8gbm9ybWFsaXplIHN1c3BlbnNlIGNoaWxkcmVuXHJcbiAgICBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgdHlwZS5ub3JtYWxpemUodm5vZGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiZcclxuICAgICAgICAvLyBhdm9pZCBhIGJsb2NrIG5vZGUgZnJvbSB0cmFja2luZyBpdHNlbGZcclxuICAgICAgICAhaXNCbG9ja05vZGUgJiZcclxuICAgICAgICAvLyBoYXMgY3VycmVudCBwYXJlbnQgYmxvY2tcclxuICAgICAgICBjdXJyZW50QmxvY2sgJiZcclxuICAgICAgICAvLyBwcmVzZW5jZSBvZiBhIHBhdGNoIGZsYWcgaW5kaWNhdGVzIHRoaXMgbm9kZSBuZWVkcyBwYXRjaGluZyBvbiB1cGRhdGVzLlxyXG4gICAgICAgIC8vIGNvbXBvbmVudCBub2RlcyBhbHNvIHNob3VsZCBhbHdheXMgYmUgcGF0Y2hlZCwgYmVjYXVzZSBldmVuIGlmIHRoZVxyXG4gICAgICAgIC8vIGNvbXBvbmVudCBkb2Vzbid0IG5lZWQgdG8gdXBkYXRlLCBpdCBuZWVkcyB0byBwZXJzaXN0IHRoZSBpbnN0YW5jZSBvbiB0b1xyXG4gICAgICAgIC8vIHRoZSBuZXh0IHZub2RlIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZCBsYXRlci5cclxuICAgICAgICAocGF0Y2hGbGFnID4gMCB8fCBzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykgJiZcclxuICAgICAgICAvLyB0aGUgRVZFTlRTIGZsYWcgaXMgb25seSBmb3IgaHlkcmF0aW9uIGFuZCBpZiBpdCBpcyB0aGUgb25seSBmbGFnLCB0aGVcclxuICAgICAgICAvLyB2bm9kZSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgZHluYW1pYyBkdWUgdG8gaGFuZGxlciBjYWNoaW5nLlxyXG4gICAgICAgIHBhdGNoRmxhZyAhPT0gMzIgLyogSFlEUkFURV9FVkVOVFMgKi8pIHtcclxuICAgICAgICBjdXJyZW50QmxvY2sucHVzaCh2bm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gY2xvbmVWTm9kZSh2bm9kZSwgZXh0cmFQcm9wcywgbWVyZ2VSZWYgPSBmYWxzZSkge1xyXG4gICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IE5PVCB1c2luZyBzcHJlYWQgb3IgZXh0ZW5kIHRvIGF2b2lkIHRoZSBydW50aW1lXHJcbiAgICAvLyBrZXkgZW51bWVyYXRpb24gY29zdC5cclxuICAgIGNvbnN0IHsgcHJvcHMsIHJlZiwgcGF0Y2hGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBtZXJnZWRQcm9wcyA9IGV4dHJhUHJvcHMgPyBtZXJnZVByb3BzKHByb3BzIHx8IHt9LCBleHRyYVByb3BzKSA6IHByb3BzO1xyXG4gICAgY29uc3QgY2xvbmVkID0ge1xyXG4gICAgICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxyXG4gICAgICAgIF9fdl9za2lwOiB0cnVlLFxyXG4gICAgICAgIHR5cGU6IHZub2RlLnR5cGUsXHJcbiAgICAgICAgcHJvcHM6IG1lcmdlZFByb3BzLFxyXG4gICAgICAgIGtleTogbWVyZ2VkUHJvcHMgJiYgbm9ybWFsaXplS2V5KG1lcmdlZFByb3BzKSxcclxuICAgICAgICByZWY6IGV4dHJhUHJvcHMgJiYgZXh0cmFQcm9wcy5yZWZcclxuICAgICAgICAgICAgPyAvLyAjMjA3OCBpbiB0aGUgY2FzZSBvZiA8Y29tcG9uZW50IDppcz1cInZub2RlXCIgcmVmPVwiZXh0cmFcIi8+XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdm5vZGUgaXRzZWxmIGFscmVhZHkgaGFzIGEgcmVmLCBjbG9uZVZOb2RlIHdpbGwgbmVlZCB0byBtZXJnZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlZnMgc28gdGhlIHNpbmdsZSB2bm9kZSBjYW4gYmUgc2V0IG9uIG11bHRpcGxlIHJlZnNcclxuICAgICAgICAgICAgICAgIG1lcmdlUmVmICYmIHJlZlxyXG4gICAgICAgICAgICAgICAgICAgID8gaXNBcnJheShyZWYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLmNvbmNhdChub3JtYWxpemVSZWYoZXh0cmFQcm9wcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW3JlZiwgbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXVxyXG4gICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXHJcbiAgICAgICAgICAgIDogcmVmLFxyXG4gICAgICAgIHNjb3BlSWQ6IHZub2RlLnNjb3BlSWQsXHJcbiAgICAgICAgc2xvdFNjb3BlSWRzOiB2bm9kZS5zbG90U2NvcGVJZHMsXHJcbiAgICAgICAgY2hpbGRyZW46IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXRjaEZsYWcgPT09IC0xIC8qIEhPSVNURUQgKi8gJiYgaXNBcnJheShjaGlsZHJlbilcclxuICAgICAgICAgICAgPyBjaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpXHJcbiAgICAgICAgICAgIDogY2hpbGRyZW4sXHJcbiAgICAgICAgdGFyZ2V0OiB2bm9kZS50YXJnZXQsXHJcbiAgICAgICAgdGFyZ2V0QW5jaG9yOiB2bm9kZS50YXJnZXRBbmNob3IsXHJcbiAgICAgICAgc3RhdGljQ291bnQ6IHZub2RlLnN0YXRpY0NvdW50LFxyXG4gICAgICAgIHNoYXBlRmxhZzogdm5vZGUuc2hhcGVGbGFnLFxyXG4gICAgICAgIC8vIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgd2l0aCBleHRyYSBwcm9wcywgd2UgY2FuIG5vIGxvbmdlciBhc3N1bWUgaXRzXHJcbiAgICAgICAgLy8gZXhpc3RpbmcgcGF0Y2ggZmxhZyB0byBiZSByZWxpYWJsZSBhbmQgbmVlZCB0byBhZGQgdGhlIEZVTExfUFJPUFMgZmxhZy5cclxuICAgICAgICAvLyBub3RlOiBwZXJzZXJ2ZSBmbGFnIGZvciBmcmFnbWVudHMgc2luY2UgdGhleSB1c2UgdGhlIGZsYWcgZm9yIGNoaWxkcmVuXHJcbiAgICAgICAgLy8gZmFzdCBwYXRocyBvbmx5LlxyXG4gICAgICAgIHBhdGNoRmxhZzogZXh0cmFQcm9wcyAmJiB2bm9kZS50eXBlICE9PSBGcmFnbWVudFxyXG4gICAgICAgICAgICA/IHBhdGNoRmxhZyA9PT0gLTEgLy8gaG9pc3RlZCBub2RlXHJcbiAgICAgICAgICAgICAgICA/IDE2IC8qIEZVTExfUFJPUFMgKi9cclxuICAgICAgICAgICAgICAgIDogcGF0Y2hGbGFnIHwgMTYgLyogRlVMTF9QUk9QUyAqL1xyXG4gICAgICAgICAgICA6IHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcHM6IHZub2RlLmR5bmFtaWNQcm9wcyxcclxuICAgICAgICBkeW5hbWljQ2hpbGRyZW46IHZub2RlLmR5bmFtaWNDaGlsZHJlbixcclxuICAgICAgICBhcHBDb250ZXh0OiB2bm9kZS5hcHBDb250ZXh0LFxyXG4gICAgICAgIGRpcnM6IHZub2RlLmRpcnMsXHJcbiAgICAgICAgdHJhbnNpdGlvbjogdm5vZGUudHJhbnNpdGlvbixcclxuICAgICAgICAvLyBUaGVzZSBzaG91bGQgdGVjaG5pY2FsbHkgb25seSBiZSBub24tbnVsbCBvbiBtb3VudGVkIFZOb2Rlcy4gSG93ZXZlcixcclxuICAgICAgICAvLyB0aGV5ICpzaG91bGQqIGJlIGNvcGllZCBmb3Iga2VwdC1hbGl2ZSB2bm9kZXMuIFNvIHdlIGp1c3QgYWx3YXlzIGNvcHlcclxuICAgICAgICAvLyB0aGVtIHNpbmNlIHRoZW0gYmVpbmcgbm9uLW51bGwgZHVyaW5nIGEgbW91bnQgZG9lc24ndCBhZmZlY3QgdGhlIGxvZ2ljIGFzXHJcbiAgICAgICAgLy8gdGhleSB3aWxsIHNpbXBseSBiZSBvdmVyd3JpdHRlbi5cclxuICAgICAgICBjb21wb25lbnQ6IHZub2RlLmNvbXBvbmVudCxcclxuICAgICAgICBzdXNwZW5zZTogdm5vZGUuc3VzcGVuc2UsXHJcbiAgICAgICAgc3NDb250ZW50OiB2bm9kZS5zc0NvbnRlbnQgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0NvbnRlbnQpLFxyXG4gICAgICAgIHNzRmFsbGJhY2s6IHZub2RlLnNzRmFsbGJhY2sgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0ZhbGxiYWNrKSxcclxuICAgICAgICBlbDogdm5vZGUuZWwsXHJcbiAgICAgICAgYW5jaG9yOiB2bm9kZS5hbmNob3JcclxuICAgIH07XHJcbiAgICByZXR1cm4gY2xvbmVkO1xyXG59XHJcbi8qKlxyXG4gKiBEZXYgb25seSwgZm9yIEhNUiBvZiBob2lzdGVkIHZub2RlcyByZXVzZWQgaW4gdi1mb3JcclxuICogaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlL2lzc3Vlcy8yMDIyXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwQ2xvbmVWTm9kZSh2bm9kZSkge1xyXG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICBpZiAoaXNBcnJheSh2bm9kZS5jaGlsZHJlbikpIHtcclxuICAgICAgICBjbG9uZWQuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsb25lZDtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSh0ZXh0ID0gJyAnLCBmbGFnID0gMCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIHRleHQsIGZsYWcpO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU3RhdGljVk5vZGUoY29udGVudCwgbnVtYmVyT2ZOb2Rlcykge1xyXG4gICAgLy8gQSBzdGF0aWMgdm5vZGUgY2FuIGNvbnRhaW4gbXVsdGlwbGUgc3RyaW5naWZpZWQgZWxlbWVudHMsIGFuZCB0aGUgbnVtYmVyXHJcbiAgICAvLyBvZiBlbGVtZW50cyBpcyBuZWNlc3NhcnkgZm9yIGh5ZHJhdGlvbi5cclxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoU3RhdGljLCBudWxsLCBjb250ZW50KTtcclxuICAgIHZub2RlLnN0YXRpY0NvdW50ID0gbnVtYmVyT2ZOb2RlcztcclxuICAgIHJldHVybiB2bm9kZTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRWTm9kZSh0ZXh0ID0gJycsIFxyXG4vLyB3aGVuIHVzZWQgYXMgdGhlIHYtZWxzZSBicmFuY2gsIHRoZSBjb21tZW50IG5vZGUgbXVzdCBiZSBjcmVhdGVkIGFzIGFcclxuLy8gYmxvY2sgdG8gZW5zdXJlIGNvcnJlY3QgdXBkYXRlcy5cclxuYXNCbG9jayA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gYXNCbG9ja1xyXG4gICAgICAgID8gKG9wZW5CbG9jaygpLCBjcmVhdGVCbG9jayhDb21tZW50JDEsIG51bGwsIHRleHQpKVxyXG4gICAgICAgIDogY3JlYXRlVk5vZGUoQ29tbWVudCQxLCBudWxsLCB0ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVWTm9kZShjaGlsZCkge1xyXG4gICAgaWYgKGNoaWxkID09IG51bGwgfHwgdHlwZW9mIGNoaWxkID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAvLyBlbXB0eSBwbGFjZWhvbGRlclxyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShDb21tZW50JDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShjaGlsZCkpIHtcclxuICAgICAgICAvLyBmcmFnbWVudFxyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShGcmFnbWVudCwgbnVsbCwgXHJcbiAgICAgICAgLy8gIzM2NjYsIGF2b2lkIHJlZmVyZW5jZSBwb2xsdXRpb24gd2hlbiByZXVzaW5nIHZub2RlXHJcbiAgICAgICAgY2hpbGQuc2xpY2UoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gYWxyZWFkeSB2bm9kZSwgdGhpcyBzaG91bGQgYmUgdGhlIG1vc3QgY29tbW9uIHNpbmNlIGNvbXBpbGVkIHRlbXBsYXRlc1xyXG4gICAgICAgIC8vIGFsd2F5cyBwcm9kdWNlIGFsbC12bm9kZSBjaGlsZHJlbiBhcnJheXNcclxuICAgICAgICByZXR1cm4gY2xvbmVJZk1vdW50ZWQoY2hpbGQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc3RyaW5ncyBhbmQgbnVtYmVyc1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCBTdHJpbmcoY2hpbGQpKTtcclxuICAgIH1cclxufVxyXG4vLyBvcHRpbWl6ZWQgbm9ybWFsaXphdGlvbiBmb3IgdGVtcGxhdGUtY29tcGlsZWQgcmVuZGVyIGZuc1xyXG5mdW5jdGlvbiBjbG9uZUlmTW91bnRlZChjaGlsZCkge1xyXG4gICAgcmV0dXJuIGNoaWxkLmVsID09PSBudWxsID8gY2hpbGQgOiBjbG9uZVZOb2RlKGNoaWxkKTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pIHtcclxuICAgIGxldCB0eXBlID0gMDtcclxuICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSB2bm9kZTtcclxuICAgIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICB0eXBlID0gMTYgLyogQVJSQVlfQ0hJTERSRU4gKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyB8fCBzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgc2xvdCB0byBwbGFpbiBjaGlsZHJlbiBmb3IgcGxhaW4gZWxlbWVudCBhbmQgVGVsZXBvcnRcclxuICAgICAgICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkcmVuLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgIGlmIChzbG90KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBfYyBtYXJrZXIgaXMgYWRkZWQgYnkgd2l0aEN0eCgpIGluZGljYXRpbmcgdGhpcyBpcyBhIGNvbXBpbGVkIHNsb3RcclxuICAgICAgICAgICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgc2xvdCgpKTtcclxuICAgICAgICAgICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0eXBlID0gMzIgLyogU0xPVFNfQ0hJTERSRU4gKi87XHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3RGbGFnID0gY2hpbGRyZW4uXztcclxuICAgICAgICAgICAgaWYgKCFzbG90RmxhZyAmJiAhKEludGVybmFsT2JqZWN0S2V5IGluIGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uX2N0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbG90RmxhZyA9PT0gMyAvKiBGT1JXQVJERUQgKi8gJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhIGNoaWxkIGNvbXBvbmVudCByZWNlaXZlcyBmb3J3YXJkZWQgc2xvdHMgZnJvbSB0aGUgcGFyZW50LlxyXG4gICAgICAgICAgICAgICAgLy8gaXRzIHNsb3QgdHlwZSBpcyBkZXRlcm1pbmVkIGJ5IGl0cyBwYXJlbnQncyBzbG90IHR5cGUuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnNsb3RzLl8gPT09IDEgLyogU1RBQkxFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uXyA9IDEgLyogU1RBQkxFICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uXyA9IDIgLyogRFlOQU1JQyAqLztcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgfD0gMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbiQxKGNoaWxkcmVuKSkge1xyXG4gICAgICAgIGNoaWxkcmVuID0geyBkZWZhdWx0OiBjaGlsZHJlbiwgX2N0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIH07XHJcbiAgICAgICAgdHlwZSA9IDMyIC8qIFNMT1RTX0NISUxEUkVOICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSBTdHJpbmcoY2hpbGRyZW4pO1xyXG4gICAgICAgIC8vIGZvcmNlIHRlbGVwb3J0IGNoaWxkcmVuIHRvIGFycmF5IHNvIGl0IGNhbiBiZSBtb3ZlZCBhcm91bmRcclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgdHlwZSA9IDE2IC8qIEFSUkFZX0NISUxEUkVOICovO1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSA4IC8qIFRFWFRfQ0hJTERSRU4gKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdm5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgIHZub2RlLnNoYXBlRmxhZyB8PSB0eXBlO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlUHJvcHMoLi4uYXJncykge1xyXG4gICAgY29uc3QgcmV0ID0gZXh0ZW5kKHt9LCBhcmdzWzBdKTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHRvTWVyZ2UgPSBhcmdzW2ldO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRvTWVyZ2UpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldC5jbGFzcyAhPT0gdG9NZXJnZS5jbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldC5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKFtyZXQuY2xhc3MsIHRvTWVyZ2UuY2xhc3NdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcclxuICAgICAgICAgICAgICAgIHJldC5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKFtyZXQuc3R5bGUsIHRvTWVyZ2Uuc3R5bGVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmV0W2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNvbWluZyA9IHRvTWVyZ2Vba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZyAhPT0gaW5jb21pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IGV4aXN0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBpbmNvbWluZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbmNvbWluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IHRvTWVyZ2Vba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cblxuLyoqXHJcbiAqIEFjdHVhbCBpbXBsZW1lbnRhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyTGlzdChzb3VyY2UsIHJlbmRlckl0ZW0pIHtcclxuICAgIGxldCByZXQ7XHJcbiAgICBpZiAoaXNBcnJheShzb3VyY2UpIHx8IGlzU3RyaW5nKHNvdXJjZSkpIHtcclxuICAgICAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzb3VyY2UubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2ldLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIU51bWJlci5pc0ludGVnZXIoc291cmNlKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBUaGUgdi1mb3IgcmFuZ2UgZXhwZWN0IGFuIGludGVnZXIgdmFsdWUgYnV0IGdvdCAke3NvdXJjZX0uYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2U7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKGkgKyAxLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdCQxKHNvdXJjZSkpIHtcclxuICAgICAgICBpZiAoc291cmNlW1N5bWJvbC5pdGVyYXRvcl0pIHtcclxuICAgICAgICAgICAgcmV0ID0gQXJyYXkuZnJvbShzb3VyY2UsIHJlbmRlckl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtrZXldLCBrZXksIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0ID0gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgY3JlYXRpbmcgZHluYW1pYyBzbG90cyBvYmplY3RcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc2xvdCA9IGR5bmFtaWNTbG90c1tpXTtcclxuICAgICAgICAvLyBhcnJheSBvZiBkeW5hbWljIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiICNbLi4uXT5cclxuICAgICAgICBpZiAoaXNBcnJheShzbG90KSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsb3QubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHNsb3RzW3Nsb3Rbal0ubmFtZV0gPSBzbG90W2pdLmZuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNsb3QpIHtcclxuICAgICAgICAgICAgLy8gY29uZGl0aW9uYWwgc2luZ2xlIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWlmPVwiLi4uXCIgI2Zvbz5cclxuICAgICAgICAgICAgc2xvdHNbc2xvdC5uYW1lXSA9IHNsb3QuZm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNsb3RzO1xyXG59XG5cbi8qKlxyXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIGA8c2xvdC8+YFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyU2xvdChzbG90cywgbmFtZSwgcHJvcHMgPSB7fSwgXHJcbi8vIHRoaXMgaXMgbm90IGEgdXNlci1mYWNpbmcgZnVuY3Rpb24sIHNvIHRoZSBmYWxsYmFjayBpcyBhbHdheXMgZ2VuZXJhdGVkIGJ5XHJcbi8vIHRoZSBjb21waWxlciBhbmQgZ3VhcmFudGVlZCB0byBiZSBhIGZ1bmN0aW9uIHJldHVybmluZyBhbiBhcnJheVxyXG5mYWxsYmFjaywgbm9TbG90dGVkKSB7XHJcbiAgICBsZXQgc2xvdCA9IHNsb3RzW25hbWVdO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzbG90ICYmIHNsb3QubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHdhcm4oYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBgICtcclxuICAgICAgICAgICAgYGZ1bmN0aW9uLiBZb3UgbmVlZCB0byBtYXJrIHRoaXMgY29tcG9uZW50IHdpdGggJGR5bmFtaWMtc2xvdHMgaW4gdGhlIGAgK1xyXG4gICAgICAgICAgICBgcGFyZW50IHRlbXBsYXRlLmApO1xyXG4gICAgICAgIHNsb3QgPSAoKSA9PiBbXTtcclxuICAgIH1cclxuICAgIC8vIGEgY29tcGlsZWQgc2xvdCBkaXNhYmxlcyBibG9jayB0cmFja2luZyBieSBkZWZhdWx0IHRvIGF2b2lkIG1hbnVhbFxyXG4gICAgLy8gaW52b2NhdGlvbiBpbnRlcmZlcmluZyB3aXRoIHRlbXBsYXRlLWJhc2VkIGJsb2NrIHRyYWNraW5nLCBidXQgaW5cclxuICAgIC8vIGByZW5kZXJTbG90YCB3ZSBjYW4gYmUgc3VyZSB0aGF0IGl0J3MgdGVtcGxhdGUtYmFzZWQgc28gd2UgY2FuIGZvcmNlXHJcbiAgICAvLyBlbmFibGUgaXQuXHJcbiAgICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XHJcbiAgICAgICAgc2xvdC5fZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgb3BlbkJsb2NrKCk7XHJcbiAgICBjb25zdCB2YWxpZFNsb3RDb250ZW50ID0gc2xvdCAmJiBlbnN1cmVWYWxpZFZOb2RlKHNsb3QocHJvcHMpKTtcclxuICAgIGNvbnN0IHJlbmRlcmVkID0gY3JlYXRlQmxvY2soRnJhZ21lbnQsIHsga2V5OiBwcm9wcy5rZXkgfHwgYF8ke25hbWV9YCB9LCB2YWxpZFNsb3RDb250ZW50IHx8IChmYWxsYmFjayA/IGZhbGxiYWNrKCkgOiBbXSksIHZhbGlkU2xvdENvbnRlbnQgJiYgc2xvdHMuXyA9PT0gMSAvKiBTVEFCTEUgKi9cclxuICAgICAgICA/IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL1xyXG4gICAgICAgIDogLTIgLyogQkFJTCAqLyk7XHJcbiAgICBpZiAoIW5vU2xvdHRlZCAmJiByZW5kZXJlZC5zY29wZUlkKSB7XHJcbiAgICAgICAgcmVuZGVyZWQuc2xvdFNjb3BlSWRzID0gW3JlbmRlcmVkLnNjb3BlSWQgKyAnLXMnXTtcclxuICAgIH1cclxuICAgIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcclxuICAgICAgICBzbG90Ll9kID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiByZW5kZXJlZDtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVWYWxpZFZOb2RlKHZub2Rlcykge1xyXG4gICAgcmV0dXJuIHZub2Rlcy5zb21lKGNoaWxkID0+IHtcclxuICAgICAgICBpZiAoIWlzVk5vZGUoY2hpbGQpKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudCQxKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50ICYmXHJcbiAgICAgICAgICAgICFlbnN1cmVWYWxpZFZOb2RlKGNoaWxkLmNoaWxkcmVuKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSlcclxuICAgICAgICA/IHZub2Rlc1xyXG4gICAgICAgIDogbnVsbDtcclxufVxuXG4vKipcclxuICogRm9yIHByZWZpeGluZyBrZXlzIGluIHYtb249XCJvYmpcIiB3aXRoIFwib25cIlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdG9IYW5kbGVycyhvYmopIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNPYmplY3QkMShvYmopKSB7XHJcbiAgICAgICAgd2Fybihgdi1vbiB3aXRoIG5vIGFyZ3VtZW50IGV4cGVjdHMgYW4gb2JqZWN0IHZhbHVlLmApO1xyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICByZXRbdG9IYW5kbGVyS2V5KGtleSldID0gb2JqW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiAjMjQzNyBJbiBWdWUgMywgZnVuY3Rpb25hbCBjb21wb25lbnRzIGRvIG5vdCBoYXZlIGEgcHVibGljIGluc3RhbmNlIHByb3h5IGJ1dFxyXG4gKiB0aGV5IGV4aXN0IGluIHRoZSBpbnRlcm5hbCBwYXJlbnQgY2hhaW4uIEZvciBjb2RlIHRoYXQgcmVsaWVzIG9uIHRyYXZlcnNpbmdcclxuICogcHVibGljICRwYXJlbnQgY2hhaW5zLCBza2lwIGZ1bmN0aW9uYWwgb25lcyBhbmQgZ28gdG8gdGhlIHBhcmVudCBpbnN0ZWFkLlxyXG4gKi9cclxuY29uc3QgZ2V0UHVibGljSW5zdGFuY2UgPSAoaSkgPT4ge1xyXG4gICAgaWYgKCFpKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgaWYgKGlzU3RhdGVmdWxDb21wb25lbnQoaSkpXHJcbiAgICAgICAgcmV0dXJuIGdldEV4cG9zZVByb3h5KGkpIHx8IGkucHJveHk7XHJcbiAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpO1xyXG59O1xyXG5jb25zdCBwdWJsaWNQcm9wZXJ0aWVzTWFwID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUobnVsbCksIHtcclxuICAgICQ6IGkgPT4gaSxcclxuICAgICRlbDogaSA9PiBpLnZub2RlLmVsLFxyXG4gICAgJGRhdGE6IGkgPT4gaS5kYXRhLFxyXG4gICAgJHByb3BzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5wcm9wcykgOiBpLnByb3BzKSxcclxuICAgICRhdHRyczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkuYXR0cnMpIDogaS5hdHRycyksXHJcbiAgICAkc2xvdHM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLnNsb3RzKSA6IGkuc2xvdHMpLFxyXG4gICAgJHJlZnM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLnJlZnMpIDogaS5yZWZzKSxcclxuICAgICRwYXJlbnQ6IGkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpLFxyXG4gICAgJHJvb3Q6IGkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5yb290KSxcclxuICAgICRlbWl0OiBpID0+IGkuZW1pdCxcclxuICAgICRvcHRpb25zOiBpID0+IChfX1ZVRV9PUFRJT05TX0FQSV9fID8gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaSkgOiBpLnR5cGUpLFxyXG4gICAgJGZvcmNlVXBkYXRlOiBpID0+ICgpID0+IHF1ZXVlSm9iKGkudXBkYXRlKSxcclxuICAgICRuZXh0VGljazogaSA9PiBuZXh0VGljay5iaW5kKGkucHJveHkpLFxyXG4gICAgJHdhdGNoOiBpID0+IChfX1ZVRV9PUFRJT05TX0FQSV9fID8gaW5zdGFuY2VXYXRjaC5iaW5kKGkpIDogTk9PUClcclxufSk7XHJcbmNvbnN0IFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IHtcclxuICAgIGdldCh7IF86IGluc3RhbmNlIH0sIGtleSkge1xyXG4gICAgICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlLCBkYXRhLCBwcm9wcywgYWNjZXNzQ2FjaGUsIHR5cGUsIGFwcENvbnRleHQgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCBmb3JtYXR0ZXJzIHRvIGtub3cgdGhhdCB0aGlzIGlzIGEgVnVlIGluc3RhbmNlXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgPT09ICdfX2lzVnVlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcHJpb3JpdGl6ZSA8c2NyaXB0IHNldHVwPiBiaW5kaW5ncyBkdXJpbmcgZGV2LlxyXG4gICAgICAgIC8vIHRoaXMgYWxsb3dzIGV2ZW4gcHJvcGVydGllcyB0aGF0IHN0YXJ0IHdpdGggXyBvciAkIHRvIGJlIHVzZWQgLSBzbyB0aGF0XHJcbiAgICAgICAgLy8gaXQgYWxpZ25zIHdpdGggdGhlIHByb2R1Y3Rpb24gYmVoYXZpb3Igd2hlcmUgdGhlIHJlbmRlciBmbiBpcyBpbmxpbmVkIGFuZFxyXG4gICAgICAgIC8vIGluZGVlZCBoYXMgYWNjZXNzIHRvIGFsbCBkZWNsYXJlZCB2YXJpYWJsZXMuXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICBzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiZcclxuICAgICAgICAgICAgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiZcclxuICAgICAgICAgICAgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGF0YSAvIHByb3BzIC8gY3R4XHJcbiAgICAgICAgLy8gVGhpcyBnZXR0ZXIgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IHByb3BlcnR5IGFjY2VzcyBvbiB0aGUgcmVuZGVyIGNvbnRleHRcclxuICAgICAgICAvLyBkdXJpbmcgcmVuZGVyIGFuZCBpcyBhIG1ham9yIGhvdHNwb3QuIFRoZSBtb3N0IGV4cGVuc2l2ZSBwYXJ0IG9mIHRoaXNcclxuICAgICAgICAvLyBpcyB0aGUgbXVsdGlwbGUgaGFzT3duKCkgY2FsbHMuIEl0J3MgbXVjaCBmYXN0ZXIgdG8gZG8gYSBzaW1wbGUgcHJvcGVydHlcclxuICAgICAgICAvLyBhY2Nlc3Mgb24gYSBwbGFpbiBvYmplY3QsIHNvIHdlIHVzZSBhbiBhY2Nlc3NDYWNoZSBvYmplY3QgKHdpdGggbnVsbFxyXG4gICAgICAgIC8vIHByb3RvdHlwZSkgdG8gbWVtb2l6ZSB3aGF0IGFjY2VzcyB0eXBlIGEga2V5IGNvcnJlc3BvbmRzIHRvLlxyXG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XHJcbiAgICAgICAgaWYgKGtleVswXSAhPT0gJyQnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSBhY2Nlc3NDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDAgLyogU0VUVVAgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIERBVEEgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzIC8qIENPTlRFWFQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIgLyogUFJPUFMgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQ6IGp1c3QgZmFsbHRocm91Z2hcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAwIC8qIFNFVFVQICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAxIC8qIERBVEEgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICAobm9ybWFsaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSAmJlxyXG4gICAgICAgICAgICAgICAgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDIgLyogUFJPUFMgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMyAvKiBDT05URVhUICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX1ZVRV9PUFRJT05TX0FQSV9fIHx8IHNob3VsZENhY2hlQWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBPVEhFUiAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwdWJsaWNHZXR0ZXIgPSBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV07XHJcbiAgICAgICAgbGV0IGNzc01vZHVsZSwgZ2xvYmFsUHJvcGVydGllcztcclxuICAgICAgICAvLyBwdWJsaWMgJHh4eCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaWYgKHB1YmxpY0dldHRlcikge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnJGF0dHJzJykge1xyXG4gICAgICAgICAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0dldHRlcihpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgIC8vIGNzcyBtb2R1bGUgKGluamVjdGVkIGJ5IHZ1ZS1sb2FkZXIpXHJcbiAgICAgICAgKGNzc01vZHVsZSA9IHR5cGUuX19jc3NNb2R1bGVzKSAmJlxyXG4gICAgICAgICAgICAoY3NzTW9kdWxlID0gY3NzTW9kdWxlW2tleV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjc3NNb2R1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcclxuICAgICAgICAgICAgLy8gdXNlciBtYXkgc2V0IGN1c3RvbSBwcm9wZXJ0aWVzIHRvIGB0aGlzYCB0aGF0IHN0YXJ0IHdpdGggYCRgXHJcbiAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAzIC8qIENPTlRFWFQgKi87XHJcbiAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgLy8gZ2xvYmFsIHByb3BlcnRpZXNcclxuICAgICAgICAoKGdsb2JhbFByb3BlcnRpZXMgPSBhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSxcclxuICAgICAgICAgICAgaGFzT3duKGdsb2JhbFByb3BlcnRpZXMsIGtleSkpKSB7XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxQcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSAmJlxyXG4gICAgICAgICAgICAoIWlzU3RyaW5nKGtleSkgfHxcclxuICAgICAgICAgICAgICAgIC8vICMxMDkxIGF2b2lkIGludGVybmFsIGlzUmVmL2lzVk5vZGUgY2hlY2tzIG9uIGNvbXBvbmVudCBpbnN0YW5jZSBsZWFkaW5nXHJcbiAgICAgICAgICAgICAgICAvLyB0byBpbmZpbml0ZSB3YXJuaW5nIGxvb3BcclxuICAgICAgICAgICAgICAgIGtleS5pbmRleE9mKCdfX3YnKSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJlxyXG4gICAgICAgICAgICAgICAgKGtleVswXSA9PT0gJyQnIHx8IGtleVswXSA9PT0gJ18nKSAmJlxyXG4gICAgICAgICAgICAgICAgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gbXVzdCBiZSBhY2Nlc3NlZCB2aWEgJGRhdGEgYmVjYXVzZSBpdCBzdGFydHMgd2l0aCBhIHJlc2VydmVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBjaGFyYWN0ZXIgKFwiJFwiIG9yIFwiX1wiKSBhbmQgaXMgbm90IHByb3hpZWQgb24gdGhlIHJlbmRlciBjb250ZXh0LmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGluc3RhbmNlID09PSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gd2FzIGFjY2Vzc2VkIGR1cmluZyByZW5kZXIgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYGJ1dCBpcyBub3QgZGVmaW5lZCBvbiBpbnN0YW5jZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBzZXR1cFN0YXRlLCBjdHggfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIGlmIChzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgICAgICAgc2V0dXBTdGF0ZVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xyXG4gICAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGFzT3duKGluc3RhbmNlLnByb3BzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHJvcCBcIiR7a2V5fVwiLiBQcm9wcyBhcmUgcmVhZG9ubHkuYCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZXlbMF0gPT09ICckJyAmJiBrZXkuc2xpY2UoMSkgaW4gaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwdWJsaWMgcHJvcGVydHkgXCIke2tleX1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFByb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCAkIGFyZSByZXNlcnZlZCBhbmQgcmVhZG9ubHkuYCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSBpbiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdHhba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGhhcyh7IF86IHsgZGF0YSwgc2V0dXBTdGF0ZSwgYWNjZXNzQ2FjaGUsIGN0eCwgYXBwQ29udGV4dCwgcHJvcHNPcHRpb25zIH0gfSwga2V5KSB7XHJcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcclxuICAgICAgICByZXR1cm4gKGFjY2Vzc0NhY2hlW2tleV0gIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB8fFxyXG4gICAgICAgICAgICAoc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB8fFxyXG4gICAgICAgICAgICAoKG5vcm1hbGl6ZWRQcm9wcyA9IHByb3BzT3B0aW9uc1swXSkgJiYgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSkgfHxcclxuICAgICAgICAgICAgaGFzT3duKGN0eCwga2V5KSB8fFxyXG4gICAgICAgICAgICBoYXNPd24ocHVibGljUHJvcGVydGllc01hcCwga2V5KSB8fFxyXG4gICAgICAgICAgICBoYXNPd24oYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywga2V5KSk7XHJcbiAgICB9XHJcbn07XHJcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWZhbHNlKSB7XHJcbiAgICBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMub3duS2V5cyA9ICh0YXJnZXQpID0+IHtcclxuICAgICAgICB3YXJuKGBBdm9pZCBhcHAgbG9naWMgdGhhdCByZWxpZXMgb24gZW51bWVyYXRpbmcga2V5cyBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZS4gYCArXHJcbiAgICAgICAgICAgIGBUaGUga2V5cyB3aWxsIGJlIGVtcHR5IGluIHByb2R1Y3Rpb24gbW9kZSB0byBhdm9pZCBwZXJmb3JtYW5jZSBvdmVyaGVhZC5gKTtcclxuICAgICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IGV4dGVuZCh7fSwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLCB7XHJcbiAgICBnZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAvLyBmYXN0IHBhdGggZm9yIHVuc2NvcGFibGVzIHdoZW4gdXNpbmcgYHdpdGhgIGJsb2NrXHJcbiAgICAgICAgaWYgKGtleSA9PT0gU3ltYm9sLnVuc2NvcGFibGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5nZXQodGFyZ2V0LCBrZXksIHRhcmdldCk7XHJcbiAgICB9LFxyXG4gICAgaGFzKF8sIGtleSkge1xyXG4gICAgICAgIGNvbnN0IGhhcyA9IGtleVswXSAhPT0gJ18nICYmICFpc0dsb2JhbGx5V2hpdGVsaXN0ZWQoa2V5KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXMgJiYgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmhhcyhfLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIF8gd2hpY2ggaXMgYSByZXNlcnZlZCBwcmVmaXggZm9yIFZ1ZSBpbnRlcm5hbHMuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXM7XHJcbiAgICB9XHJcbn0pO1xyXG4vLyBJbiBkZXYgbW9kZSwgdGhlIHByb3h5IHRhcmdldCBleHBvc2VzIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgc2VlbiBvbiBgdGhpc2BcclxuLy8gZm9yIGVhc2llciBjb25zb2xlIGluc3BlY3Rpb24uIEluIHByb2QgbW9kZSBpdCB3aWxsIGJlIGFuIGVtcHR5IG9iamVjdCBzb1xyXG4vLyB0aGVzZSBwcm9wZXJ0aWVzIGRlZmluaXRpb25zIGNhbiBiZSBza2lwcGVkLlxyXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcclxuICAgIC8vIGV4cG9zZSBpbnRlcm5hbCBpbnN0YW5jZSBmb3IgcHJveHkgaGFuZGxlcnNcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGBfYCwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlXHJcbiAgICB9KTtcclxuICAgIC8vIGV4cG9zZSBwdWJsaWMgcHJvcGVydGllc1xyXG4gICAgT2JqZWN0LmtleXMocHVibGljUHJvcGVydGllc01hcCkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBnZXQ6ICgpID0+IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSksXHJcbiAgICAgICAgICAgIC8vIGludGVyY2VwdGVkIGJ5IHRoZSBwcm94eSBzbyBubyBuZWVkIGZvciBpbXBsZW1lbnRhdGlvbixcclxuICAgICAgICAgICAgLy8gYnV0IG5lZWRlZCB0byBwcmV2ZW50IHNldCBlcnJvcnNcclxuICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgY3R4LCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdIH0gPSBpbnN0YW5jZTtcclxuICAgIGlmIChwcm9wc09wdGlvbnMpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhwcm9wc09wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZS5wcm9wc1trZXldLFxyXG4gICAgICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8vIGRldiBvbmx5XHJcbmZ1bmN0aW9uIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlIH0gPSBpbnN0YW5jZTtcclxuICAgIE9iamVjdC5rZXlzKHRvUmF3KHNldHVwU3RhdGUpKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaWYgKCFzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCAmJiAoa2V5WzBdID09PSAnJCcgfHwga2V5WzBdID09PSAnXycpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHNldHVwKCkgcmV0dXJuIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIFwiJFwiIG9yIFwiX1wiIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdoaWNoIGFyZSByZXNlcnZlZCBwcmVmaXhlcyBmb3IgVnVlIGludGVybmFscy5gKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBnZXQ6ICgpID0+IHNldHVwU3RhdGVba2V5XSxcclxuICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxuXG5jb25zdCBlbXB0eUFwcENvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XHJcbmxldCB1aWQkMSA9IDA7XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKHZub2RlLCBwYXJlbnQsIHN1c3BlbnNlKSB7XHJcbiAgICBjb25zdCB0eXBlID0gdm5vZGUudHlwZTtcclxuICAgIC8vIGluaGVyaXQgcGFyZW50IGFwcCBjb250ZXh0IC0gb3IgLSBpZiByb290LCBhZG9wdCBmcm9tIHJvb3Qgdm5vZGVcclxuICAgIGNvbnN0IGFwcENvbnRleHQgPSAocGFyZW50ID8gcGFyZW50LmFwcENvbnRleHQgOiB2bm9kZS5hcHBDb250ZXh0KSB8fCBlbXB0eUFwcENvbnRleHQ7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IHtcclxuICAgICAgICB1aWQ6IHVpZCQxKyssXHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBwYXJlbnQsXHJcbiAgICAgICAgYXBwQ29udGV4dCxcclxuICAgICAgICByb290OiBudWxsLFxyXG4gICAgICAgIG5leHQ6IG51bGwsXHJcbiAgICAgICAgc3ViVHJlZTogbnVsbCxcclxuICAgICAgICB1cGRhdGU6IG51bGwsXHJcbiAgICAgICAgcmVuZGVyOiBudWxsLFxyXG4gICAgICAgIHByb3h5OiBudWxsLFxyXG4gICAgICAgIGV4cG9zZWQ6IG51bGwsXHJcbiAgICAgICAgZXhwb3NlUHJveHk6IG51bGwsXHJcbiAgICAgICAgd2l0aFByb3h5OiBudWxsLFxyXG4gICAgICAgIGVmZmVjdHM6IG51bGwsXHJcbiAgICAgICAgcHJvdmlkZXM6IHBhcmVudCA/IHBhcmVudC5wcm92aWRlcyA6IE9iamVjdC5jcmVhdGUoYXBwQ29udGV4dC5wcm92aWRlcyksXHJcbiAgICAgICAgYWNjZXNzQ2FjaGU6IG51bGwsXHJcbiAgICAgICAgcmVuZGVyQ2FjaGU6IFtdLFxyXG4gICAgICAgIC8vIGxvY2FsIHJlc292bGVkIGFzc2V0c1xyXG4gICAgICAgIGNvbXBvbmVudHM6IG51bGwsXHJcbiAgICAgICAgZGlyZWN0aXZlczogbnVsbCxcclxuICAgICAgICAvLyByZXNvbHZlZCBwcm9wcyBhbmQgZW1pdHMgb3B0aW9uc1xyXG4gICAgICAgIHByb3BzT3B0aW9uczogbm9ybWFsaXplUHJvcHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxyXG4gICAgICAgIGVtaXRzT3B0aW9uczogbm9ybWFsaXplRW1pdHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxyXG4gICAgICAgIC8vIGVtaXRcclxuICAgICAgICBlbWl0OiBudWxsLFxyXG4gICAgICAgIGVtaXR0ZWQ6IG51bGwsXHJcbiAgICAgICAgLy8gcHJvcHMgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgIHByb3BzRGVmYXVsdHM6IEVNUFRZX09CSixcclxuICAgICAgICAvLyBpbmhlcml0QXR0cnNcclxuICAgICAgICBpbmhlcml0QXR0cnM6IHR5cGUuaW5oZXJpdEF0dHJzLFxyXG4gICAgICAgIC8vIHN0YXRlXHJcbiAgICAgICAgY3R4OiBFTVBUWV9PQkosXHJcbiAgICAgICAgZGF0YTogRU1QVFlfT0JKLFxyXG4gICAgICAgIHByb3BzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgYXR0cnM6IEVNUFRZX09CSixcclxuICAgICAgICBzbG90czogRU1QVFlfT0JKLFxyXG4gICAgICAgIHJlZnM6IEVNUFRZX09CSixcclxuICAgICAgICBzZXR1cFN0YXRlOiBFTVBUWV9PQkosXHJcbiAgICAgICAgc2V0dXBDb250ZXh0OiBudWxsLFxyXG4gICAgICAgIC8vIHN1c3BlbnNlIHJlbGF0ZWRcclxuICAgICAgICBzdXNwZW5zZSxcclxuICAgICAgICBzdXNwZW5zZUlkOiBzdXNwZW5zZSA/IHN1c3BlbnNlLnBlbmRpbmdJZCA6IDAsXHJcbiAgICAgICAgYXN5bmNEZXA6IG51bGwsXHJcbiAgICAgICAgYXN5bmNSZXNvbHZlZDogZmFsc2UsXHJcbiAgICAgICAgLy8gbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICAgICAgLy8gbm90IHVzaW5nIGVudW1zIGhlcmUgYmVjYXVzZSBpdCByZXN1bHRzIGluIGNvbXB1dGVkIHByb3BlcnRpZXNcclxuICAgICAgICBpc01vdW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBpc0RlYWN0aXZhdGVkOiBmYWxzZSxcclxuICAgICAgICBiYzogbnVsbCxcclxuICAgICAgICBjOiBudWxsLFxyXG4gICAgICAgIGJtOiBudWxsLFxyXG4gICAgICAgIG06IG51bGwsXHJcbiAgICAgICAgYnU6IG51bGwsXHJcbiAgICAgICAgdTogbnVsbCxcclxuICAgICAgICB1bTogbnVsbCxcclxuICAgICAgICBidW06IG51bGwsXHJcbiAgICAgICAgZGE6IG51bGwsXHJcbiAgICAgICAgYTogbnVsbCxcclxuICAgICAgICBydGc6IG51bGwsXHJcbiAgICAgICAgcnRjOiBudWxsLFxyXG4gICAgICAgIGVjOiBudWxsLFxyXG4gICAgICAgIHNwOiBudWxsXHJcbiAgICB9O1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGluc3RhbmNlLmN0eCA9IGNyZWF0ZVJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaW5zdGFuY2UuY3R4ID0geyBfOiBpbnN0YW5jZSB9O1xyXG4gICAgfVxyXG4gICAgaW5zdGFuY2Uucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IDogaW5zdGFuY2U7XHJcbiAgICBpbnN0YW5jZS5lbWl0ID0gZW1pdC5iaW5kKG51bGwsIGluc3RhbmNlKTtcclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxufVxyXG5sZXQgY3VycmVudEluc3RhbmNlID0gbnVsbDtcclxuY29uc3QgZ2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuY29uc3Qgc2V0Q3VycmVudEluc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XHJcbiAgICBjdXJyZW50SW5zdGFuY2UgPSBpbnN0YW5jZTtcclxufTtcclxuY29uc3QgaXNCdWlsdEluVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcpO1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29uZmlnKSB7XHJcbiAgICBjb25zdCBhcHBJc05hdGl2ZVRhZyA9IGNvbmZpZy5pc05hdGl2ZVRhZyB8fCBOTztcclxuICAgIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgYXBwSXNOYXRpdmVUYWcobmFtZSkpIHtcclxuICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50IGlkOiAnICsgbmFtZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSkge1xyXG4gICAgcmV0dXJuIGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovO1xyXG59XHJcbmxldCBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcclxuZnVuY3Rpb24gc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSID0gZmFsc2UpIHtcclxuICAgIGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGlzU1NSO1xyXG4gICAgY29uc3QgeyBwcm9wcywgY2hpbGRyZW4gfSA9IGluc3RhbmNlLnZub2RlO1xyXG4gICAgY29uc3QgaXNTdGF0ZWZ1bCA9IGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpO1xyXG4gICAgaW5pdFByb3BzKGluc3RhbmNlLCBwcm9wcywgaXNTdGF0ZWZ1bCwgaXNTU1IpO1xyXG4gICAgaW5pdFNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XHJcbiAgICBjb25zdCBzZXR1cFJlc3VsdCA9IGlzU3RhdGVmdWxcclxuICAgICAgICA/IHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKVxyXG4gICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XHJcbiAgICByZXR1cm4gc2V0dXBSZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpIHtcclxuICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5uYW1lKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShDb21wb25lbnQubmFtZSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcG9uZW50LmNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuY29tcG9uZW50cyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lc1tpXSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wb25lbnQuZGlyZWN0aXZlcykge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5kaXJlY3RpdmVzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWVzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcG9uZW50LmNvbXBpbGVyT3B0aW9ucyAmJiBpc1J1bnRpbWVPbmx5KCkpIHtcclxuICAgICAgICAgICAgd2FybihgXCJjb21waWxlck9wdGlvbnNcIiBpcyBvbmx5IHN1cHBvcnRlZCB3aGVuIHVzaW5nIGEgYnVpbGQgb2YgVnVlIHRoYXQgYCArXHJcbiAgICAgICAgICAgICAgICBgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIuIFNpbmNlIHlvdSBhcmUgdXNpbmcgYSBydW50aW1lLW9ubHkgYCArXHJcbiAgICAgICAgICAgICAgICBgYnVpbGQsIHRoZSBvcHRpb25zIHNob3VsZCBiZSBwYXNzZWQgdmlhIHlvdXIgYnVpbGQgdG9vbCBjb25maWcgaW5zdGVhZC5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAwLiBjcmVhdGUgcmVuZGVyIHByb3h5IHByb3BlcnR5IGFjY2VzcyBjYWNoZVxyXG4gICAgaW5zdGFuY2UuYWNjZXNzQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgLy8gMS4gY3JlYXRlIHB1YmxpYyBpbnN0YW5jZSAvIHJlbmRlciBwcm94eVxyXG4gICAgLy8gYWxzbyBtYXJrIGl0IHJhdyBzbyBpdCdzIG5ldmVyIG9ic2VydmVkXHJcbiAgICBpbnN0YW5jZS5wcm94eSA9IG1hcmtSYXcobmV3IFByb3h5KGluc3RhbmNlLmN0eCwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKSk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgLy8gMi4gY2FsbCBzZXR1cCgpXHJcbiAgICBjb25zdCB7IHNldHVwIH0gPSBDb21wb25lbnQ7XHJcbiAgICBpZiAoc2V0dXApIHtcclxuICAgICAgICBjb25zdCBzZXR1cENvbnRleHQgPSAoaW5zdGFuY2Uuc2V0dXBDb250ZXh0ID1cclxuICAgICAgICAgICAgc2V0dXAubGVuZ3RoID4gMSA/IGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkgOiBudWxsKTtcclxuICAgICAgICBjdXJyZW50SW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc2V0dXAsIGluc3RhbmNlLCAwIC8qIFNFVFVQX0ZVTkNUSU9OICovLCBbKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnByb3BzKSA6IGluc3RhbmNlLnByb3BzLCBzZXR1cENvbnRleHRdKTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gbnVsbDtcclxuICAgICAgICBpZiAoaXNQcm9taXNlJDEoc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVuc2V0SW5zdGFuY2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBzZXR1cFJlc3VsdC50aGVuKHVuc2V0SW5zdGFuY2UsIHVuc2V0SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBpZiAoaXNTU1IpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcHJvbWlzZSBzbyBzZXJ2ZXItcmVuZGVyZXIgY2FuIHdhaXQgb24gaXRcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXNvbHZlZFJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCByZXNvbHZlZFJlc3VsdCwgaXNTU1IpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgaW5zdGFuY2UsIDAgLyogU0VUVVBfRlVOQ1RJT04gKi8pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3luYyBzZXR1cCByZXR1cm5lZCBQcm9taXNlLlxyXG4gICAgICAgICAgICAgICAgLy8gYmFpbCBoZXJlIGFuZCB3YWl0IGZvciByZS1lbnRyeS5cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmFzeW5jRGVwID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24kMShzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICAvLyBzZXR1cCByZXR1cm5lZCBhbiBpbmxpbmUgcmVuZGVyIGZ1bmN0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc09iamVjdCQxKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNWTm9kZShzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICAgICAgd2Fybihgc2V0dXAoKSBzaG91bGQgbm90IHJldHVybiBWTm9kZXMgZGlyZWN0bHkgLSBgICtcclxuICAgICAgICAgICAgICAgIGByZXR1cm4gYSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0dXAgcmV0dXJuZWQgYmluZGluZ3MuXHJcbiAgICAgICAgLy8gYXNzdW1pbmcgYSByZW5kZXIgZnVuY3Rpb24gY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBpcyBwcmVzZW50LlxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmRldnRvb2xzUmF3U2V0dXBTdGF0ZSA9IHNldHVwUmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5zZXR1cFN0YXRlID0gcHJveHlSZWZzKHNldHVwUmVzdWx0KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzZXR1cFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgd2Fybihgc2V0dXAoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4gUmVjZWl2ZWQ6ICR7c2V0dXBSZXN1bHQgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2Ygc2V0dXBSZXN1bHR9YCk7XHJcbiAgICB9XHJcbiAgICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpO1xyXG59XHJcbmxldCBjb21waWxlO1xyXG4vLyBkZXYgb25seVxyXG5jb25zdCBpc1J1bnRpbWVPbmx5ID0gKCkgPT4gIWNvbXBpbGU7XHJcbi8qKlxyXG4gKiBGb3IgcnVudGltZS1kb20gdG8gcmVnaXN0ZXIgdGhlIGNvbXBpbGVyLlxyXG4gKiBOb3RlIHRoZSBleHBvcnRlZCBtZXRob2QgdXNlcyBhbnkgdG8gYXZvaWQgZC50cyByZWx5aW5nIG9uIHRoZSBjb21waWxlciB0eXBlcy5cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyKF9jb21waWxlKSB7XHJcbiAgICBjb21waWxlID0gX2NvbXBpbGU7XHJcbn1cclxuZnVuY3Rpb24gZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSLCBza2lwT3B0aW9ucykge1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgIC8vIHRlbXBsYXRlIC8gcmVuZGVyIGZ1bmN0aW9uIG5vcm1hbGl6YXRpb25cclxuICAgIGlmICghaW5zdGFuY2UucmVuZGVyKSB7XHJcbiAgICAgICAgLy8gY291bGQgYmUgc2V0IGZyb20gc2V0dXAoKVxyXG4gICAgICAgIGlmIChjb21waWxlICYmICFDb21wb25lbnQucmVuZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gQ29tcG9uZW50LnRlbXBsYXRlO1xyXG4gICAgICAgICAgICBpZiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzQ3VzdG9tRWxlbWVudCwgY29tcGlsZXJPcHRpb25zIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVsaW1pdGVycywgY29tcGlsZXJPcHRpb25zOiBjb21wb25lbnRDb21waWxlck9wdGlvbnMgfSA9IENvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsQ29tcGlsZXJPcHRpb25zID0gZXh0ZW5kKGV4dGVuZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNDdXN0b21FbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGltaXRlcnNcclxuICAgICAgICAgICAgICAgIH0sIGNvbXBpbGVyT3B0aW9ucyksIGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucmVuZGVyID0gY29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxDb21waWxlck9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gKENvbXBvbmVudC5yZW5kZXIgfHwgTk9PUCk7XHJcbiAgICAgICAgLy8gZm9yIHJ1bnRpbWUtY29tcGlsZWQgcmVuZGVyIGZ1bmN0aW9ucyB1c2luZyBgd2l0aGAgYmxvY2tzLCB0aGUgcmVuZGVyXHJcbiAgICAgICAgLy8gcHJveHkgdXNlZCBuZWVkcyBhIGRpZmZlcmVudCBgaGFzYCBoYW5kbGVyIHdoaWNoIGlzIG1vcmUgcGVyZm9ybWFudCBhbmRcclxuICAgICAgICAvLyBhbHNvIG9ubHkgYWxsb3dzIGEgd2hpdGVsaXN0IG9mIGdsb2JhbHMgdG8gZmFsbHRocm91Z2guXHJcbiAgICAgICAgaWYgKGluc3RhbmNlLnJlbmRlci5fcmMpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2Uud2l0aFByb3h5ID0gbmV3IFByb3h5KGluc3RhbmNlLmN0eCwgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBzdXBwb3J0IGZvciAyLnggb3B0aW9uc1xyXG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIShmYWxzZSApKSB7XHJcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyB3YXJuIG1pc3NpbmcgdGVtcGxhdGUvcmVuZGVyXHJcbiAgICAvLyB0aGUgcnVudGltZSBjb21waWxhdGlvbiBvZiB0ZW1wbGF0ZSBpbiBTU1IgaXMgZG9uZSBieSBzZXJ2ZXItcmVuZGVyXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFDb21wb25lbnQucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCAmJiAhaXNTU1IpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIWNvbXBpbGUgJiYgQ29tcG9uZW50LnRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBwcm92aWRlZCB0ZW1wbGF0ZSBvcHRpb24gYnV0IGAgK1xyXG4gICAgICAgICAgICAgICAgYHJ1bnRpbWUgY29tcGlsYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIFZ1ZS5gICtcclxuICAgICAgICAgICAgICAgIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmBcclxuICAgICAgICAgICAgICAgICAgICApIC8qIHNob3VsZCBub3QgaGFwcGVuICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBpcyBtaXNzaW5nIHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbi5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgYXR0ckRldlByb3h5SGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6ICh0YXJnZXQsIGtleSkgPT4ge1xyXG4gICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xyXG4gICAgfSxcclxuICAgIHNldDogKCkgPT4ge1xyXG4gICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgZGVsZXRlUHJvcGVydHk6ICgpID0+IHtcclxuICAgICAgICB3YXJuKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGV4cG9zZSA9IGV4cG9zZWQgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UuZXhwb3NlZCkge1xyXG4gICAgICAgICAgICB3YXJuKGBleHBvc2UoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgc2V0dXAoKS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IGV4cG9zZWQgfHwge307XHJcbiAgICB9O1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGxldCBhdHRycztcclxuICAgICAgICAvLyBXZSB1c2UgZ2V0dGVycyBpbiBkZXYgaW4gY2FzZSBsaWJzIGxpa2UgdGVzdC11dGlscyBvdmVyd3JpdGUgaW5zdGFuY2VcclxuICAgICAgICAvLyBwcm9wZXJ0aWVzIChvdmVyd3JpdGVzIHNob3VsZCBub3QgYmUgZG9uZSBpbiBwcm9kKVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChhdHRycyB8fCAoYXR0cnMgPSBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIGF0dHJEZXZQcm94eUhhbmRsZXJzKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgc2xvdHMoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnNsb3RzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0IGVtaXQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiBpbnN0YW5jZS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXhwb3NlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhdHRyczogaW5zdGFuY2UuYXR0cnMsXHJcbiAgICAgICAgICAgIHNsb3RzOiBpbnN0YW5jZS5zbG90cyxcclxuICAgICAgICAgICAgZW1pdDogaW5zdGFuY2UuZW1pdCxcclxuICAgICAgICAgICAgZXhwb3NlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRFeHBvc2VQcm94eShpbnN0YW5jZSkge1xyXG4gICAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcclxuICAgICAgICByZXR1cm4gKGluc3RhbmNlLmV4cG9zZVByb3h5IHx8XHJcbiAgICAgICAgICAgIChpbnN0YW5jZS5leHBvc2VQcm94eSA9IG5ldyBQcm94eShwcm94eVJlZnMobWFya1JhdyhpbnN0YW5jZS5leHBvc2VkKSksIHtcclxuICAgICAgICAgICAgICAgIGdldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgfVxyXG59XHJcbi8vIHJlY29yZCBlZmZlY3RzIGNyZWF0ZWQgZHVyaW5nIGEgY29tcG9uZW50J3Mgc2V0dXAoKSBzbyB0aGF0IHRoZXkgY2FuIGJlXHJcbi8vIHN0b3BwZWQgd2hlbiB0aGUgY29tcG9uZW50IHVubW91bnRzXHJcbmZ1bmN0aW9uIHJlY29yZEluc3RhbmNlQm91bmRFZmZlY3QoZWZmZWN0LCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgKGluc3RhbmNlLmVmZmVjdHMgfHwgKGluc3RhbmNlLmVmZmVjdHMgPSBbXSkpLnB1c2goZWZmZWN0KTtcclxuICAgIH1cclxufVxyXG5jb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xyXG5jb25zdCBjbGFzc2lmeSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIGMgPT4gYy50b1VwcGVyQ2FzZSgpKS5yZXBsYWNlKC9bLV9dL2csICcnKTtcclxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uJDEoQ29tcG9uZW50KVxyXG4gICAgICAgID8gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lXHJcbiAgICAgICAgOiBDb21wb25lbnQubmFtZTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBDb21wb25lbnQsIGlzUm9vdCA9IGZhbHNlKSB7XHJcbiAgICBsZXQgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KTtcclxuICAgIGlmICghbmFtZSAmJiBDb21wb25lbnQuX19maWxlKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBDb21wb25lbnQuX19maWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBtYXRjaFsxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIW5hbWUgJiYgaW5zdGFuY2UgJiYgaW5zdGFuY2UucGFyZW50KSB7XHJcbiAgICAgICAgLy8gdHJ5IHRvIGluZmVyIHRoZSBuYW1lIGJhc2VkIG9uIHJldmVyc2UgcmVzb2x1dGlvblxyXG4gICAgICAgIGNvbnN0IGluZmVyRnJvbVJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5KSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlZ2lzdHJ5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0cnlba2V5XSA9PT0gQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbmFtZSA9XHJcbiAgICAgICAgICAgIGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmNvbXBvbmVudHMgfHxcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudC50eXBlLmNvbXBvbmVudHMpIHx8IGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmFwcENvbnRleHQuY29tcG9uZW50cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmFtZSA/IGNsYXNzaWZ5KG5hbWUpIDogaXNSb290ID8gYEFwcGAgOiBgQW5vbnltb3VzYDtcclxufVxyXG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbiQxKHZhbHVlKSAmJiAnX192Y2NPcHRzJyBpbiB2YWx1ZTtcclxufVxuXG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGMgPSBjb21wdXRlZCQxKGdldHRlck9yT3B0aW9ucyk7XHJcbiAgICByZWNvcmRJbnN0YW5jZUJvdW5kRWZmZWN0KGMuZWZmZWN0KTtcclxuICAgIHJldHVybiBjO1xyXG59XG5cbihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgPyBPYmplY3QuZnJlZXplKHt9KVxyXG4gICAgOiB7fTtcclxuKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcclxuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XHJcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xyXG5jb25zdCBpc1Byb21pc2UgPSAodmFsKSA9PiB7XHJcbiAgICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XHJcbn07XG5cbi8vIGRldiBvbmx5XHJcbmNvbnN0IHdhcm5SdW50aW1lVXNhZ2UgPSAobWV0aG9kKSA9PiB3YXJuKGAke21ldGhvZH0oKSBpcyBhIGNvbXBpbGVyLWhpbnQgaGVscGVyIHRoYXQgaXMgb25seSB1c2FibGUgaW5zaWRlIGAgK1xyXG4gICAgYDxzY3JpcHQgc2V0dXA+IG9mIGEgc2luZ2xlIGZpbGUgY29tcG9uZW50LiBJdHMgYXJndW1lbnRzIHNob3VsZCBiZSBgICtcclxuICAgIGBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gKTtcclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gZGVmaW5lUHJvcHMoKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lUHJvcHNgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGRlZmluZUVtaXRzKCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZUVtaXRzYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vKipcclxuICogQGRlcHJlY2F0ZWQgdXNlIGBkZWZpbmVFbWl0c2AgaW5zdGVhZC5cclxuICovXHJcbmNvbnN0IGRlZmluZUVtaXQgPSBkZWZpbmVFbWl0cztcclxuLyoqXHJcbiAqIFZ1ZSBgPHNjcmlwdCBzZXR1cD5gIGNvbXBpbGVyIG1hY3JvIGZvciBkZWNsYXJpbmcgYSBjb21wb25lbnQncyBleHBvc2VkXHJcbiAqIGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBpdCBpcyBhY2Nlc3NlZCBieSBhIHBhcmVudCBjb21wb25lbnQgdmlhIHRlbXBsYXRlXHJcbiAqIHJlZnMuXHJcbiAqXHJcbiAqIGA8c2NyaXB0IHNldHVwPmAgY29tcG9uZW50cyBhcmUgY2xvc2VkIGJ5IGRlZmF1bHQgLSBpLmUuIHZhcmFpYmxlcyBpbnNpZGVcclxuICogdGhlIGA8c2NyaXB0IHNldHVwPmAgc2NvcGUgaXMgbm90IGV4cG9zZWQgdG8gcGFyZW50IHVubGVzcyBleHBsaWNpdGx5IGV4cG9zZWRcclxuICogdmlhIGBkZWZpbmVFeHBvc2VgLlxyXG4gKlxyXG4gKiBUaGlzIGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgPHNjcmlwdCBzZXR1cD5gLCBpcyBjb21waWxlZCBhd2F5IGluIHRoZVxyXG4gKiBvdXRwdXQgYW5kIHNob3VsZCAqKm5vdCoqIGJlIGFjdHVhbGx5IGNhbGxlZCBhdCBydW50aW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVmaW5lRXhwb3NlKGV4cG9zZWQpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFeHBvc2VgKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVnVlIGA8c2NyaXB0IHNldHVwPmAgY29tcGlsZXIgbWFjcm8gZm9yIHByb3ZpZGluZyBwcm9wcyBkZWZhdWx0IHZhbHVlcyB3aGVuXHJcbiAqIHVzaW5nIHR5cGUtYmFzZWQgYGRlZmluZVByb3BzYCBkZWNhbHJhdGlvbi5cclxuICpcclxuICogRXhhbXBsZSB1c2FnZTpcclxuICogYGBgdHNcclxuICogd2l0aERlZmF1bHRzKGRlZmluZVByb3BzPHtcclxuICogICBzaXplPzogbnVtYmVyXHJcbiAqICAgbGFiZWxzPzogc3RyaW5nW11cclxuICogfT4oKSwge1xyXG4gKiAgIHNpemU6IDMsXHJcbiAqICAgbGFiZWxzOiAoKSA9PiBbJ2RlZmF1bHQgbGFiZWwnXVxyXG4gKiB9KVxyXG4gKiBgYGBcclxuICpcclxuICogVGhpcyBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgYDxzY3JpcHQgc2V0dXA+YCwgaXMgY29tcGlsZWQgYXdheSBpbiB0aGUgb3V0cHV0XHJcbiAqIGFuZCBzaG91bGQgKipub3QqKiBiZSBhY3R1YWxseSBjYWxsZWQgYXQgcnVudGltZS5cclxuICovXHJcbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhwcm9wcywgZGVmYXVsdHMpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuUnVudGltZVVzYWdlKGB3aXRoRGVmYXVsdHNgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCB1c2UgYHVzZVNsb3RzYCBhbmQgYHVzZUF0dHJzYCBpbnN0ZWFkLlxyXG4gKi9cclxuZnVuY3Rpb24gdXNlQ29udGV4dCgpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBcXGB1c2VDb250ZXh0KClcXGAgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBgICtcclxuICAgICAgICAgICAgYG5leHQgbWlub3IgcmVsZWFzZS4gVXNlIFxcYHVzZVNsb3RzKClcXGAgYW5kIFxcYHVzZUF0dHJzKClcXGAgaW5zdGVhZC5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZXRDb250ZXh0KCk7XHJcbn1cclxuZnVuY3Rpb24gdXNlU2xvdHMoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xyXG59XHJcbmZ1bmN0aW9uIHVzZUF0dHJzKCkge1xyXG4gICAgcmV0dXJuIGdldENvbnRleHQoKS5hdHRycztcclxufVxyXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xyXG4gICAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaSkge1xyXG4gICAgICAgIHdhcm4oYHVzZUNvbnRleHQoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaS5zZXR1cENvbnRleHQgfHwgKGkuc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KGkpKTtcclxufVxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgZGVmYXVsdCBkZWNsYXJhdGlvbnMuIEltcG9ydGVkIGJ5IGNvbXBpbGVkIGNvZGVcclxuICogb25seS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKFxyXG4vLyB0aGUgYmFzZSBwcm9wcyBpcyBjb21waWxlci1nZW5lcmF0ZWQgYW5kIGd1YXJhbnRlZWQgdG8gYmUgaW4gdGhpcyBzaGFwZS5cclxucHJvcHMsIGRlZmF1bHRzKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0cykge1xyXG4gICAgICAgIGNvbnN0IHZhbCA9IHByb3BzW2tleV07XHJcbiAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICB2YWwuZGVmYXVsdCA9IGRlZmF1bHRzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwcm9wc1trZXldID0geyBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBwcm9wcyBkZWZhdWx0IGtleSBcIiR7a2V5fVwiIGhhcyBubyBjb3JyZXNwb25kaW5nIGRlY2xhcmF0aW9uLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wcztcclxufVxyXG4vKipcclxuICogYDxzY3JpcHQgc2V0dXA+YCBoZWxwZXIgZm9yIHBlcnNpc3RpbmcgdGhlIGN1cnJlbnQgaW5zdGFuY2UgY29udGV4dCBvdmVyXHJcbiAqIGFzeW5jL2F3YWl0IGZsb3dzLlxyXG4gKlxyXG4gKiBgQHZ1ZS9jb21waWxlci1zZmNgIGNvbnZlcnRzIHRoZSBmb2xsb3dpbmc6XHJcbiAqXHJcbiAqIGBgYHRzXHJcbiAqIGNvbnN0IHggPSBhd2FpdCBmb28oKVxyXG4gKiBgYGBcclxuICpcclxuICogaW50bzpcclxuICpcclxuICogYGBgdHNcclxuICogbGV0IF9fdGVtcCwgX19yZXN0b3JlXHJcbiAqIGNvbnN0IHggPSAoKFtfX3RlbXAsIF9fcmVzdG9yZV0gPSB3aXRoQXN5bmNDb250ZXh0KCgpID0+IGZvbygpKSksX190ZW1wPWF3YWl0IF9fdGVtcCxfX3Jlc3RvcmUoKSxfX3RlbXApXHJcbiAqIGBgYFxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhBc3luY0NvbnRleHQoZ2V0QXdhaXRhYmxlKSB7XHJcbiAgICBjb25zdCBjdHggPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIGxldCBhd2FpdGFibGUgPSBnZXRBd2FpdGFibGUoKTtcclxuICAgIHNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcclxuICAgIGlmIChpc1Byb21pc2UoYXdhaXRhYmxlKSkge1xyXG4gICAgICAgIGF3YWl0YWJsZSA9IGF3YWl0YWJsZS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN0eCk7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2F3YWl0YWJsZSwgKCkgPT4gc2V0Q3VycmVudEluc3RhbmNlKGN0eCldO1xyXG59XG5cbi8vIEFjdHVhbCBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcclxuICAgIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgaWYgKGwgPT09IDIpIHtcclxuICAgICAgICBpZiAoaXNPYmplY3QkMShwcm9wc09yQ2hpbGRyZW4pICYmICFpc0FycmF5KHByb3BzT3JDaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgLy8gc2luZ2xlIHZub2RlIHdpdGhvdXQgcHJvcHNcclxuICAgICAgICAgICAgaWYgKGlzVk5vZGUocHJvcHNPckNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIFtwcm9wc09yQ2hpbGRyZW5dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wcyB3aXRob3V0IGNoaWxkcmVuXHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gb21pdCBwcm9wc1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgcHJvcHNPckNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAobCA+IDMpIHtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHNzckNvbnRleHRLZXkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHNzckNvbnRleHRgIDogYGApO1xyXG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IGluamVjdChzc3JDb250ZXh0S2V5KTtcclxuICAgICAgICBpZiAoIWN0eCkge1xyXG4gICAgICAgICAgICB3YXJuKGBTZXJ2ZXIgcmVuZGVyaW5nIGNvbnRleHQgbm90IHByb3ZpZGVkLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIGAgK1xyXG4gICAgICAgICAgICAgICAgYHVzZVNTUkNvbnRleHQoKSBjb25kaXRpb25hbGx5IGluIHRoZSBzZXJ2ZXIgYnVpbGQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdHg7XHJcbiAgICB9XHJcbn07XG5cbmZ1bmN0aW9uIGluaXRDdXN0b21Gb3JtYXR0ZXIoKSB7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxuICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdnVlU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzNiYTc3NicgfTtcclxuICAgIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiMwYjFiYzknIH07XHJcbiAgICBjb25zdCBzdHJpbmdTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojYjYyZTI0JyB9O1xyXG4gICAgY29uc3Qga2V5d29yZFN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiM5ZDI4OGMnIH07XHJcbiAgICAvLyBjdXN0b20gZm9ybWF0dGVyIGZvciBDaHJvbWVcclxuICAgIC8vIGh0dHBzOi8vd3d3Lm1hdHR6ZXVuZXJ0LmNvbS8yMDE2LzAyLzE5L2N1c3RvbS1jaHJvbWUtZGV2dG9vbHMtb2JqZWN0LWZvcm1hdHRlcnMuaHRtbFxyXG4gICAgY29uc3QgZm9ybWF0dGVyID0ge1xyXG4gICAgICAgIGhlYWRlcihvYmopIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBhbHNvIGZvcm1hdCBDb21wb25lbnRQdWJsaWNJbnN0YW5jZSAmIGN0eC5zbG90cy9hdHRycyBpbiBzZXR1cFxyXG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0JDEob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9iai5fX2lzVnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydkaXYnLCB2dWVTdHlsZSwgYFZ1ZUluc3RhbmNlYF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWYob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgZ2VuUmVmRmxhZyhvYmopXSxcclxuICAgICAgICAgICAgICAgICAgICAnPCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqLnZhbHVlKSxcclxuICAgICAgICAgICAgICAgICAgICBgPmBcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIHZ1ZVN0eWxlLCAnUmVhY3RpdmUnXSxcclxuICAgICAgICAgICAgICAgICAgICAnPCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcclxuICAgICAgICAgICAgICAgICAgICBgPiR7aXNSZWFkb25seShvYmopID8gYCAocmVhZG9ubHkpYCA6IGBgfWBcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFkb25seShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIHZ1ZVN0eWxlLCAnUmVhZG9ubHknXSxcclxuICAgICAgICAgICAgICAgICAgICAnPCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcclxuICAgICAgICAgICAgICAgICAgICAnPidcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXNCb2R5KG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIG9iai5fX2lzVnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keShvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmouX19pc1Z1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICAuLi5mb3JtYXRJbnN0YW5jZShvYmouJClcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0SW5zdGFuY2UoaW5zdGFuY2UpIHtcclxuICAgICAgICBjb25zdCBibG9ja3MgPSBbXTtcclxuICAgICAgICBpZiAoaW5zdGFuY2UudHlwZS5wcm9wcyAmJiBpbnN0YW5jZS5wcm9wcykge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdwcm9wcycsIHRvUmF3KGluc3RhbmNlLnByb3BzKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zdGFuY2Uuc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ3NldHVwJywgaW5zdGFuY2Uuc2V0dXBTdGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zdGFuY2UuZGF0YSAhPT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ2RhdGEnLCB0b1JhdyhpbnN0YW5jZS5kYXRhKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCAnY29tcHV0ZWQnKTtcclxuICAgICAgICBpZiAoY29tcHV0ZWQpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnY29tcHV0ZWQnLCBjb21wdXRlZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbmplY3RlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCAnaW5qZWN0Jyk7XHJcbiAgICAgICAgaWYgKGluamVjdGVkKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ2luamVjdGVkJywgaW5qZWN0ZWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmxvY2tzLnB1c2goW1xyXG4gICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICdzcGFuJyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZToga2V5d29yZFN0eWxlLnN0eWxlICsgJztvcGFjaXR5OjAuNjYnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgJyQgKGludGVybmFsKTogJ1xyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbJ29iamVjdCcsIHsgb2JqZWN0OiBpbnN0YW5jZSB9XVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHJldHVybiBibG9ja3M7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUJsb2NrKHR5cGUsIHRhcmdldCkge1xyXG4gICAgICAgIHRhcmdldCA9IGV4dGVuZCh7fSwgdGFyZ2V0KTtcclxuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRhcmdldCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7fV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICB7IHN0eWxlOiAnbGluZS1oZWlnaHQ6MS4yNWVtO21hcmdpbi1ib3R0b206MC42ZW0nIH0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnY29sb3I6IzQ3NjU4MidcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0eXBlXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAncGFkZGluZy1sZWZ0OjEuMjVlbSdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAuLi5PYmplY3Qua2V5cyh0YXJnZXQpLm1hcChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgWydzcGFuJywga2V5d29yZFN0eWxlLCBrZXkgKyAnOiAnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUodGFyZ2V0W2tleV0sIGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIGFzUmF3ID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIG51bWJlclN0eWxlLCB2XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBzdHJpbmdTdHlsZSwgSlNPTi5zdHJpbmdpZnkodildO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBrZXl3b3JkU3R5bGUsIHZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc09iamVjdCQxKHYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ29iamVjdCcsIHsgb2JqZWN0OiBhc1JhdyA/IHRvUmF3KHYpIDogdiB9XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBzdHJpbmdTdHlsZSwgU3RyaW5nKHYpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHRyYWN0S2V5cyhpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgICAgIGNvbnN0IENvbXAgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uJDEoQ29tcCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBleHRyYWN0ZWQgPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5jdHgpIHtcclxuICAgICAgICAgICAgaWYgKGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGV4dHJhY3RlZFtrZXldID0gaW5zdGFuY2UuY3R4W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RlZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkge1xyXG4gICAgICAgIGNvbnN0IG9wdHMgPSBDb21wW3R5cGVdO1xyXG4gICAgICAgIGlmICgoaXNBcnJheShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkpIHx8XHJcbiAgICAgICAgICAgIChpc09iamVjdCQxKG9wdHMpICYmIGtleSBpbiBvcHRzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXAuZXh0ZW5kcyAmJiBpc0tleU9mVHlwZShDb21wLmV4dGVuZHMsIGtleSwgdHlwZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wLm1peGlucyAmJiBDb21wLm1peGlucy5zb21lKG0gPT4gaXNLZXlPZlR5cGUobSwga2V5LCB0eXBlKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2VuUmVmRmxhZyh2KSB7XHJcbiAgICAgICAgaWYgKHYuX3NoYWxsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBTaGFsbG93UmVmYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHYuZWZmZWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgQ29tcHV0ZWRSZWZgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYFJlZmA7XHJcbiAgICB9XHJcbiAgICBpZiAod2luZG93LmRldnRvb2xzRm9ybWF0dGVycykge1xyXG4gICAgICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMucHVzaChmb3JtYXR0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycyA9IFtmb3JtYXR0ZXJdO1xyXG4gICAgfVxyXG59XG5cbi8vIENvcmUgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5jb25zdCB2ZXJzaW9uID0gXCIzLjEuNVwiO1xyXG4vKipcclxuICogU1NSIHV0aWxzIGZvciBcXEB2dWUvc2VydmVyLXJlbmRlcmVyLiBPbmx5IGV4cG9zZWQgaW4gY2pzIGJ1aWxkcy5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBzc3JVdGlscyA9IChudWxsKTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBvbmx5IGV4cG9zZWQgaW4gY29tcGF0IGJ1aWxkc1xyXG4gKi9cclxuY29uc3QgcmVzb2x2ZUZpbHRlciA9IG51bGw7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgb25seSBleHBvc2VkIGluIGNvbXBhdCBidWlsZHMuXHJcbiAqL1xyXG5jb25zdCBjb21wYXRVdGlscyA9IChudWxsKTtcblxuZXhwb3J0IHsgQmFzZVRyYW5zaXRpb24sIENvbW1lbnQkMSBhcyBDb21tZW50LCBGcmFnbWVudCwgS2VlcEFsaXZlLCBTdGF0aWMsIFN1c3BlbnNlLCBUZWxlcG9ydCwgVGV4dCwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGNhbGxXaXRoRXJyb3JIYW5kbGluZywgY2xvbmVWTm9kZSwgY29tcGF0VXRpbHMsIGNvbXB1dGVkLCBjcmVhdGVCbG9jaywgY3JlYXRlQ29tbWVudFZOb2RlLCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZVNsb3RzLCBjcmVhdGVTdGF0aWNWTm9kZSwgY3JlYXRlVGV4dFZOb2RlLCBjcmVhdGVWTm9kZSwgZGVmaW5lQXN5bmNDb21wb25lbnQsIGRlZmluZUNvbXBvbmVudCwgZGVmaW5lRW1pdCwgZGVmaW5lRW1pdHMsIGRlZmluZUV4cG9zZSwgZGVmaW5lUHJvcHMsIGRldnRvb2xzLCBnZXRDdXJyZW50SW5zdGFuY2UsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgaCwgaGFuZGxlRXJyb3IsIGluaXRDdXN0b21Gb3JtYXR0ZXIsIGluamVjdCwgaXNSdW50aW1lT25seSwgaXNWTm9kZSwgbWVyZ2VEZWZhdWx0cywgbWVyZ2VQcm9wcywgbmV4dFRpY2ssIG9uQWN0aXZhdGVkLCBvbkJlZm9yZU1vdW50LCBvbkJlZm9yZVVubW91bnQsIG9uQmVmb3JlVXBkYXRlLCBvbkRlYWN0aXZhdGVkLCBvbkVycm9yQ2FwdHVyZWQsIG9uTW91bnRlZCwgb25SZW5kZXJUcmFja2VkLCBvblJlbmRlclRyaWdnZXJlZCwgb25TZXJ2ZXJQcmVmZXRjaCwgb25Vbm1vdW50ZWQsIG9uVXBkYXRlZCwgb3BlbkJsb2NrLCBwb3BTY29wZUlkLCBwcm92aWRlLCBwdXNoU2NvcGVJZCwgcXVldWVQb3N0Rmx1c2hDYiwgcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIsIHJlbmRlckxpc3QsIHJlbmRlclNsb3QsIHJlc29sdmVDb21wb25lbnQsIHJlc29sdmVEaXJlY3RpdmUsIHJlc29sdmVEeW5hbWljQ29tcG9uZW50LCByZXNvbHZlRmlsdGVyLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBzZXRCbG9ja1RyYWNraW5nLCBzZXREZXZ0b29sc0hvb2ssIHNldFRyYW5zaXRpb25Ib29rcywgc3NyQ29udGV4dEtleSwgc3NyVXRpbHMsIHRvSGFuZGxlcnMsIHRyYW5zZm9ybVZOb2RlQXJncywgdXNlQXR0cnMsIHVzZUNvbnRleHQsIHVzZVNTUkNvbnRleHQsIHVzZVNsb3RzLCB1c2VUcmFuc2l0aW9uU3RhdGUsIHZlcnNpb24sIHdhcm4sIHdhdGNoLCB3YXRjaEVmZmVjdCwgd2l0aEFzeW5jQ29udGV4dCwgd2l0aEN0eCwgd2l0aERlZmF1bHRzLCB3aXRoRGlyZWN0aXZlcywgd2l0aFNjb3BlSWQgfTtcbiIsImltcG9ydCB7IGNhbWVsaXplLCB3YXJuLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgZ2V0Q3VycmVudEluc3RhbmNlLCBvbk1vdW50ZWQsIHdhdGNoRWZmZWN0LCBvblVwZGF0ZWQsIEZyYWdtZW50LCBTdGF0aWMsIGgsIEJhc2VUcmFuc2l0aW9uLCB1c2VUcmFuc2l0aW9uU3RhdGUsIHRvUmF3LCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIHNldFRyYW5zaXRpb25Ib29rcywgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgY3JlYXRlVk5vZGUsIGNyZWF0ZVJlbmRlcmVyLCBpc1J1bnRpbWVPbmx5LCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciB9IGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0FycmF5LCBoeXBoZW5hdGUsIGNhcGl0YWxpemUsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc09uLCBpc01vZGVsTGlzdGVuZXIsIGlzRnVuY3Rpb24sIEVNUFRZX09CSiwgZXh0ZW5kLCBpc09iamVjdCwgdG9OdW1iZXIsIGludm9rZUFycmF5Rm5zLCBsb29zZUluZGV4T2YsIGlzU2V0LCBsb29zZUVxdWFsLCBpc0hUTUxUYWcsIGlzU1ZHVGFnIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbmNvbnN0IGRvYyA9ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsKTtcclxuY29uc3Qgc3RhdGljVGVtcGxhdGVDYWNoZSA9IG5ldyBNYXAoKTtcclxuY29uc3Qgbm9kZU9wcyA9IHtcclxuICAgIGluc2VydDogKGNoaWxkLCBwYXJlbnQsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGFuY2hvciB8fCBudWxsKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmU6IGNoaWxkID0+IHtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlRWxlbWVudDogKHRhZywgaXNTVkcsIGlzLCBwcm9wcykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsID0gaXNTVkdcclxuICAgICAgICAgICAgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0YWcpXHJcbiAgICAgICAgICAgIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCBpcyA/IHsgaXMgfSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgaWYgKHRhZyA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMgJiYgcHJvcHMubXVsdGlwbGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgcHJvcHMubXVsdGlwbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlVGV4dDogdGV4dCA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXHJcbiAgICBjcmVhdGVDb21tZW50OiB0ZXh0ID0+IGRvYy5jcmVhdGVDb21tZW50KHRleHQpLFxyXG4gICAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcclxuICAgICAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XHJcbiAgICB9LFxyXG4gICAgc2V0RWxlbWVudFRleHQ6IChlbCwgdGV4dCkgPT4ge1xyXG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcclxuICAgIH0sXHJcbiAgICBwYXJlbnROb2RlOiBub2RlID0+IG5vZGUucGFyZW50Tm9kZSxcclxuICAgIG5leHRTaWJsaW5nOiBub2RlID0+IG5vZGUubmV4dFNpYmxpbmcsXHJcbiAgICBxdWVyeVNlbGVjdG9yOiBzZWxlY3RvciA9PiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXHJcbiAgICBzZXRTY29wZUlkKGVsLCBpZCkge1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShpZCwgJycpO1xyXG4gICAgfSxcclxuICAgIGNsb25lTm9kZShlbCkge1xyXG4gICAgICAgIGNvbnN0IGNsb25lZCA9IGVsLmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICAvLyAjMzA3MlxyXG4gICAgICAgIC8vIC0gaW4gYHBhdGNoRE9NUHJvcGAsIHdlIHN0b3JlIHRoZSBhY3R1YWwgdmFsdWUgaW4gdGhlIGBlbC5fdmFsdWVgIHByb3BlcnR5LlxyXG4gICAgICAgIC8vIC0gbm9ybWFsbHksIGVsZW1lbnRzIHVzaW5nIGA6dmFsdWVgIGJpbmRpbmdzIHdpbGwgbm90IGJlIGhvaXN0ZWQsIGJ1dCBpZlxyXG4gICAgICAgIC8vICAgdGhlIGJvdW5kIHZhbHVlIGlzIGEgY29uc3RhbnQsIGUuZy4gYDp2YWx1ZT1cInRydWVcImAgLSB0aGV5IGRvIGdldFxyXG4gICAgICAgIC8vICAgaG9pc3RlZC5cclxuICAgICAgICAvLyAtIGluIHByb2R1Y3Rpb24sIGhvaXN0ZWQgbm9kZXMgYXJlIGNsb25lZCB3aGVuIHN1YnNlcXVlbnQgaW5zZXJ0cywgYnV0XHJcbiAgICAgICAgLy8gICBjbG9uZU5vZGUoKSBkb2VzIG5vdCBjb3B5IHRoZSBjdXN0b20gcHJvcGVydHkgd2UgYXR0YWNoZWQuXHJcbiAgICAgICAgLy8gLSBUaGlzIG1heSBuZWVkIHRvIGFjY291bnQgZm9yIG90aGVyIGN1c3RvbSBET00gcHJvcGVydGllcyB3ZSBhdHRhY2ggdG9cclxuICAgICAgICAvLyAgIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIGBfdmFsdWVgIGluIHRoZSBmdXR1cmUuXHJcbiAgICAgICAgaWYgKGBfdmFsdWVgIGluIGVsKSB7XHJcbiAgICAgICAgICAgIGNsb25lZC5fdmFsdWUgPSBlbC5fdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgICB9LFxyXG4gICAgLy8gX19VTlNBRkVfX1xyXG4gICAgLy8gUmVhc29uOiBpbm5lckhUTUwuXHJcbiAgICAvLyBTdGF0aWMgY29udGVudCBoZXJlIGNhbiBvbmx5IGNvbWUgZnJvbSBjb21waWxlZCB0ZW1wbGF0ZXMuXHJcbiAgICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxyXG4gICAgaW5zZXJ0U3RhdGljQ29udGVudChjb250ZW50LCBwYXJlbnQsIGFuY2hvciwgaXNTVkcpIHtcclxuICAgICAgICAvLyA8cGFyZW50PiBiZWZvcmUgfCBmaXJzdCAuLi4gbGFzdCB8IGFuY2hvciA8L3BhcmVudD5cclxuICAgICAgICBjb25zdCBiZWZvcmUgPSBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZDtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBzdGF0aWNUZW1wbGF0ZUNhY2hlLmdldChjb250ZW50KTtcclxuICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBkb2MuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcclxuICAgICAgICAgICAgdC5pbm5lckhUTUwgPSBpc1NWRyA/IGA8c3ZnPiR7Y29udGVudH08L3N2Zz5gIDogY29udGVudDtcclxuICAgICAgICAgICAgdGVtcGxhdGUgPSB0LmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIGlmIChpc1NWRykge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG91dGVyIHN2ZyB3cmFwcGVyXHJcbiAgICAgICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gdGVtcGxhdGUuZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh3cmFwcGVyLmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5hcHBlbmRDaGlsZCh3cmFwcGVyLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGVtcGxhdGUucmVtb3ZlQ2hpbGQod3JhcHBlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RhdGljVGVtcGxhdGVDYWNoZS5zZXQoY29udGVudCwgdGVtcGxhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKSwgYW5jaG9yKTtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAvLyBmaXJzdFxyXG4gICAgICAgICAgICBiZWZvcmUgPyBiZWZvcmUubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZCxcclxuICAgICAgICAgICAgLy8gbGFzdFxyXG4gICAgICAgICAgICBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbn07XG5cbi8vIGNvbXBpbGVyIHNob3VsZCBub3JtYWxpemUgY2xhc3MgKyA6Y2xhc3MgYmluZGluZ3Mgb24gdGhlIHNhbWUgZWxlbWVudFxyXG4vLyBpbnRvIGEgc2luZ2xlIGJpbmRpbmcgWydzdGF0aWNDbGFzcycsIGR5bmFtaWNdXHJcbmZ1bmN0aW9uIHBhdGNoQ2xhc3MoZWwsIHZhbHVlLCBpc1NWRykge1xyXG4gICAgLy8gZGlyZWN0bHkgc2V0dGluZyBjbGFzc05hbWUgc2hvdWxkIGJlIGZhc3RlciB0aGFuIHNldEF0dHJpYnV0ZSBpbiB0aGVvcnlcclxuICAgIC8vIGlmIHRoaXMgaXMgYW4gZWxlbWVudCBkdXJpbmcgYSB0cmFuc2l0aW9uLCB0YWtlIHRoZSB0ZW1wb3JhcnkgdHJhbnNpdGlvblxyXG4gICAgLy8gY2xhc3NlcyBpbnRvIGFjY291bnQuXHJcbiAgICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl92dGM7XHJcbiAgICBpZiAodHJhbnNpdGlvbkNsYXNzZXMpIHtcclxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZVxyXG4gICAgICAgICAgICA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdXHJcbiAgICAgICAgICAgIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbignICcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NWRykge1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XHJcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgaWYgKCFuZXh0KSB7XHJcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdHJpbmcobmV4dCkpIHtcclxuICAgICAgICBpZiAocHJldiAhPT0gbmV4dCkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gc3R5bGUuZGlzcGxheTtcclxuICAgICAgICAgICAgc3R5bGUuY3NzVGV4dCA9IG5leHQ7XHJcbiAgICAgICAgICAgIC8vIGluZGljYXRlcyB0aGF0IHRoZSBgZGlzcGxheWAgb2YgdGhlIGVsZW1lbnQgaXMgY29udHJvbGxlZCBieSBgdi1zaG93YCxcclxuICAgICAgICAgICAgLy8gc28gd2UgYWx3YXlzIGtlZXAgdGhlIGN1cnJlbnQgYGRpc3BsYXlgIHZhbHVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGBzdHlsZWAgdmFsdWUsXHJcbiAgICAgICAgICAgIC8vIHRodXMgaGFuZGluZyBvdmVyIGNvbnRyb2wgdG8gYHYtc2hvd2AuXHJcbiAgICAgICAgICAgIGlmICgnX3ZvZCcgaW4gZWwpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSBjdXJyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xyXG4gICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBuZXh0W2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldiAmJiAhaXNTdHJpbmcocHJldikpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XHJcbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2YWwpIHtcclxuICAgIGlmIChpc0FycmF5KHZhbCkpIHtcclxuICAgICAgICB2YWwuZm9yRWFjaCh2ID0+IHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCctLScpKSB7XHJcbiAgICAgICAgICAgIC8vIGN1c3RvbSBwcm9wZXJ0eSBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBwcmVmaXhlZCA9IGF1dG9QcmVmaXgoc3R5bGUsIG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAhaW1wb3J0YW50XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUocHJlZml4ZWQpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZVtwcmVmaXhlZF0gPSB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcclxuY29uc3QgcHJlZml4Q2FjaGUgPSB7fTtcclxuZnVuY3Rpb24gYXV0b1ByZWZpeChzdHlsZSwgcmF3TmFtZSkge1xyXG4gICAgY29uc3QgY2FjaGVkID0gcHJlZml4Q2FjaGVbcmF3TmFtZV07XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgIH1cclxuICAgIGxldCBuYW1lID0gY2FtZWxpemUocmF3TmFtZSk7XHJcbiAgICBpZiAobmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSBpbiBzdHlsZSkge1xyXG4gICAgICAgIHJldHVybiAocHJlZml4Q2FjaGVbcmF3TmFtZV0gPSBuYW1lKTtcclxuICAgIH1cclxuICAgIG5hbWUgPSBjYXBpdGFsaXplKG5hbWUpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyBuYW1lO1xyXG4gICAgICAgIGlmIChwcmVmaXhlZCBpbiBzdHlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHByZWZpeENhY2hlW3Jhd05hbWVdID0gcHJlZml4ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByYXdOYW1lO1xyXG59XG5cbmNvbnN0IHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XHJcbmZ1bmN0aW9uIHBhdGNoQXR0cihlbCwga2V5LCB2YWx1ZSwgaXNTVkcsIGluc3RhbmNlKSB7XHJcbiAgICBpZiAoaXNTVkcgJiYga2V5LnN0YXJ0c1dpdGgoJ3hsaW5rOicpKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywga2V5LnNsaWNlKDYsIGtleS5sZW5ndGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG5vdGUgd2UgYXJlIG9ubHkgY2hlY2tpbmcgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXQgZG9uJ3QgaGF2ZSBhXHJcbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBkb20gcHJvcCBvZiB0aGUgc2FtZSBuYW1lIGhlcmUuXHJcbiAgICAgICAgY29uc3QgaXNCb29sZWFuID0gaXNTcGVjaWFsQm9vbGVhbkF0dHIoa2V5KTtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoaXNCb29sZWFuICYmIHZhbHVlID09PSBmYWxzZSkpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0Jvb2xlYW4gPyAnJyA6IHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLy8gX19VTlNBRkVfX1xyXG4vLyBmdW5jdGlvbnMuIFRoZSB1c2VyIGlzIHJlc3BvbnNpYmxlIGZvciB1c2luZyB0aGVtIHdpdGggb25seSB0cnVzdGVkIGNvbnRlbnQuXHJcbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgXHJcbi8vIHRoZSBmb2xsb3dpbmcgYXJncyBhcmUgcGFzc2VkIG9ubHkgZHVlIHRvIHBvdGVudGlhbCBpbm5lckhUTUwvdGV4dENvbnRlbnRcclxuLy8gb3ZlcnJpZGluZyBleGlzdGluZyBWTm9kZXMsIGluIHdoaWNoIGNhc2UgdGhlIG9sZCB0cmVlIG11c3QgYmUgcHJvcGVybHlcclxuLy8gdW5tb3VudGVkLlxyXG5wcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikge1xyXG4gICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgfHwga2V5ID09PSAndGV4dENvbnRlbnQnKSB7XHJcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxba2V5XSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiYgZWwudGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xyXG4gICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXHJcbiAgICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZC5cclxuICAgICAgICBlbC5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcclxuICAgICAgICBpZiAodmFsdWUgPT09ICcnICYmIHR5cGUgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAvLyBlLmcuIDxzZWxlY3QgbXVsdGlwbGU+IGNvbXBpbGVzIHRvIHsgbXVsdGlwbGU6ICcnIH1cclxuICAgICAgICAgICAgZWxba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gbnVsbCAmJiB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAvLyBlLmcuIDxkaXYgOmlkPVwibnVsbFwiPlxyXG4gICAgICAgICAgICBlbFtrZXldID0gJyc7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPGltZyA6d2lkdGg9XCJudWxsXCI+XHJcbiAgICAgICAgICAgIC8vIHRoZSB2YWx1ZSBvZiBzb21lIElETCBhdHRyIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAsIGUuZy4gaW5wdXQuc2l6ZSA9IDAgLT4gZXJyb3JcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGVsW2tleV0gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gc29tZSBwcm9wZXJ0aWVzIHBlcmZvcm0gdmFsdWUgdmFsaWRhdGlvbiBhbmQgdGhyb3dcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZWxba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCBzZXR0aW5nIHByb3AgXCIke2tleX1cIiBvbiA8JHtlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCl9PjogYCArXHJcbiAgICAgICAgICAgICAgICBgdmFsdWUgJHt2YWx1ZX0gaXMgaW52YWxpZC5gLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cclxubGV0IF9nZXROb3cgPSBEYXRlLm5vdztcclxubGV0IHNraXBUaW1lc3RhbXBDaGVjayA9IGZhbHNlO1xyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIC8vIERldGVybWluZSB3aGF0IGV2ZW50IHRpbWVzdGFtcCB0aGUgYnJvd3NlciBpcyB1c2luZy4gQW5ub3lpbmdseSwgdGhlXHJcbiAgICAvLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xyXG4gICAgLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXHJcbiAgICAvLyBzYW1lIHRpbWVzdGFtcCB0eXBlIHdoZW4gc2F2aW5nIHRoZSBmbHVzaCB0aW1lc3RhbXAuXHJcbiAgICBpZiAoX2dldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wKSB7XHJcbiAgICAgICAgLy8gaWYgdGhlIGxvdy1yZXMgdGltZXN0YW1wIHdoaWNoIGlzIGJpZ2dlciB0aGFuIHRoZSBldmVudCB0aW1lc3RhbXBcclxuICAgICAgICAvLyAod2hpY2ggaXMgZXZhbHVhdGVkIEFGVEVSKSBpdCBtZWFucyB0aGUgZXZlbnQgaXMgdXNpbmcgYSBoaS1yZXMgdGltZXN0YW1wLFxyXG4gICAgICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHVzZSB0aGUgaGktcmVzIHZlcnNpb24gZm9yIGV2ZW50IGxpc3RlbmVycyBhcyB3ZWxsLlxyXG4gICAgICAgIF9nZXROb3cgPSAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIH1cclxuICAgIC8vICMzNDg1OiBGaXJlZm94IDw9IDUzIGhhcyBpbmNvcnJlY3QgRXZlbnQudGltZVN0YW1wIGltcGxlbWVudGF0aW9uXHJcbiAgICAvLyBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvIHNhZmUgdG8gZXhjbHVkZS5cclxuICAgIGNvbnN0IGZmTWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9maXJlZm94XFwvKFxcZCspL2kpO1xyXG4gICAgc2tpcFRpbWVzdGFtcENoZWNrID0gISEoZmZNYXRjaCAmJiBOdW1iZXIoZmZNYXRjaFsxXSkgPD0gNTMpO1xyXG59XHJcbi8vIFRvIGF2b2lkIHRoZSBvdmVyaGVhZCBvZiByZXBlYXRlZGx5IGNhbGxpbmcgcGVyZm9ybWFuY2Uubm93KCksIHdlIGNhY2hlXHJcbi8vIGFuZCB1c2UgdGhlIHNhbWUgdGltZXN0YW1wIGZvciBhbGwgZXZlbnQgbGlzdGVuZXJzIGF0dGFjaGVkIGluIHRoZSBzYW1lIHRpY2suXHJcbmxldCBjYWNoZWROb3cgPSAwO1xyXG5jb25zdCBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbmNvbnN0IHJlc2V0ID0gKCkgPT4ge1xyXG4gICAgY2FjaGVkTm93ID0gMDtcclxufTtcclxuY29uc3QgZ2V0Tm93ID0gKCkgPT4gY2FjaGVkTm93IHx8IChwLnRoZW4ocmVzZXQpLCAoY2FjaGVkTm93ID0gX2dldE5vdygpKSk7XHJcbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XHJcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xyXG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hFdmVudChlbCwgcmF3TmFtZSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGluc3RhbmNlID0gbnVsbCkge1xyXG4gICAgLy8gdmVpID0gdnVlIGV2ZW50IGludm9rZXJzXHJcbiAgICBjb25zdCBpbnZva2VycyA9IGVsLl92ZWkgfHwgKGVsLl92ZWkgPSB7fSk7XHJcbiAgICBjb25zdCBleGlzdGluZ0ludm9rZXIgPSBpbnZva2Vyc1tyYXdOYW1lXTtcclxuICAgIGlmIChuZXh0VmFsdWUgJiYgZXhpc3RpbmdJbnZva2VyKSB7XHJcbiAgICAgICAgLy8gcGF0Y2hcclxuICAgICAgICBleGlzdGluZ0ludm9rZXIudmFsdWUgPSBuZXh0VmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBbbmFtZSwgb3B0aW9uc10gPSBwYXJzZU5hbWUocmF3TmFtZSk7XHJcbiAgICAgICAgaWYgKG5leHRWYWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBhZGRcclxuICAgICAgICAgICAgY29uc3QgaW52b2tlciA9IChpbnZva2Vyc1tyYXdOYW1lXSA9IGNyZWF0ZUludm9rZXIobmV4dFZhbHVlLCBpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBpbnZva2VyLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXhpc3RpbmdJbnZva2VyKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZVxyXG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBleGlzdGluZ0ludm9rZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpbnZva2Vyc1tyYXdOYW1lXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3Qgb3B0aW9uc01vZGlmaWVyUkUgPSAvKD86T25jZXxQYXNzaXZlfENhcHR1cmUpJC87XHJcbmZ1bmN0aW9uIHBhcnNlTmFtZShuYW1lKSB7XHJcbiAgICBsZXQgb3B0aW9ucztcclxuICAgIGlmIChvcHRpb25zTW9kaWZpZXJSRS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIGxldCBtO1xyXG4gICAgICAgIHdoaWxlICgobSA9IG5hbWUubWF0Y2gob3B0aW9uc01vZGlmaWVyUkUpKSkge1xyXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIG1bMF0ubGVuZ3RoKTtcclxuICAgICAgICAgICAgb3B0aW9uc1ttWzBdLnRvTG93ZXJDYXNlKCldID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2h5cGhlbmF0ZShuYW1lLnNsaWNlKDIpKSwgb3B0aW9uc107XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW52b2tlcihpbml0aWFsVmFsdWUsIGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCBpbnZva2VyID0gKGUpID0+IHtcclxuICAgICAgICAvLyBhc3luYyBlZGdlIGNhc2UgIzY1NjY6IGlubmVyIGNsaWNrIGV2ZW50IHRyaWdnZXJzIHBhdGNoLCBldmVudCBoYW5kbGVyXHJcbiAgICAgICAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcclxuICAgICAgICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cclxuICAgICAgICAvLyB0aGUgc29sdXRpb24gaXMgc2ltcGxlOiB3ZSBzYXZlIHRoZSB0aW1lc3RhbXAgd2hlbiBhIGhhbmRsZXIgaXMgYXR0YWNoZWQsXHJcbiAgICAgICAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxyXG4gICAgICAgIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cclxuICAgICAgICBjb25zdCB0aW1lU3RhbXAgPSBlLnRpbWVTdGFtcCB8fCBfZ2V0Tm93KCk7XHJcbiAgICAgICAgaWYgKHNraXBUaW1lc3RhbXBDaGVjayB8fCB0aW1lU3RhbXAgPj0gaW52b2tlci5hdHRhY2hlZCAtIDEpIHtcclxuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcocGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgaW52b2tlci52YWx1ZSksIGluc3RhbmNlLCA1IC8qIE5BVElWRV9FVkVOVF9IQU5ETEVSICovLCBbZV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpbnZva2VyLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xyXG4gICAgaW52b2tlci5hdHRhY2hlZCA9IGdldE5vdygpO1xyXG4gICAgcmV0dXJuIGludm9rZXI7XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgdmFsdWUpIHtcclxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU3RvcCA9IGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uO1xyXG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBvcmlnaW5hbFN0b3AuY2FsbChlKTtcclxuICAgICAgICAgICAgZS5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZuID0+IChlKSA9PiAhZS5fc3RvcHBlZCAmJiBmbihlKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgbmF0aXZlT25SRSA9IC9eb25bYS16XS87XHJcbmNvbnN0IGZvcmNlUGF0Y2hQcm9wID0gKF8sIGtleSkgPT4ga2V5ID09PSAndmFsdWUnO1xyXG5jb25zdCBwYXRjaFByb3AgPSAoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGlzU1ZHID0gZmFsc2UsIHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKSA9PiB7XHJcbiAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgIC8vIHNwZWNpYWxcclxuICAgICAgICBjYXNlICdjbGFzcyc6XHJcbiAgICAgICAgICAgIHBhdGNoQ2xhc3MoZWwsIG5leHRWYWx1ZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdzdHlsZSc6XHJcbiAgICAgICAgICAgIHBhdGNoU3R5bGUoZWwsIHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgaWYgKGlzT24oa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHYtbW9kZWwgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hFdmVudChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRykpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoRE9NUHJvcChlbCwga2V5LCBuZXh0VmFsdWUsIHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgPGlucHV0IHYtbW9kZWwgdHlwZT1cImNoZWNrYm94XCI+IHdpdGhcclxuICAgICAgICAgICAgICAgIC8vIDp0cnVlLXZhbHVlICYgOmZhbHNlLXZhbHVlXHJcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBkb20gcHJvcGVydGllcyBzaW5jZSBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlXHJcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmdpZmllZC5cclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICd0cnVlLXZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLl90cnVlVmFsdWUgPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdmYWxzZS12YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5fZmFsc2VWYWx1ZSA9IG5leHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIHZhbHVlLCBpc1NWRykge1xyXG4gICAgaWYgKGlzU1ZHKSB7XHJcbiAgICAgICAgLy8gbW9zdCBrZXlzIG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZSBvbiBzdmcgZWxlbWVudHMgdG8gd29ya1xyXG4gICAgICAgIC8vIC4uLmV4Y2VwdCBpbm5lckhUTUxcclxuICAgICAgICBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb3IgbmF0aXZlIG9uY2xpY2sgd2l0aCBmdW5jdGlvbiB2YWx1ZXNcclxuICAgICAgICBpZiAoa2V5IGluIGVsICYmIG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBzcGVsbGNoZWNrIGFuZCBkcmFnZ2FibGUgYXJlIG51bWVyYXRlZCBhdHRycywgaG93ZXZlciB0aGVpclxyXG4gICAgLy8gY29ycmVzcG9uZGluZyBET00gcHJvcGVydGllcyBhcmUgYWN0dWFsbHkgYm9vbGVhbnMgLSB0aGlzIGxlYWRzIHRvXHJcbiAgICAvLyBzZXR0aW5nIGl0IHdpdGggYSBzdHJpbmcgXCJmYWxzZVwiIHZhbHVlIGxlYWRpbmcgaXQgdG8gYmUgY29lcmNlZCB0b1xyXG4gICAgLy8gYHRydWVgLCBzbyB3ZSBuZWVkIHRvIGFsd2F5cyB0cmVhdCB0aGVtIGFzIGF0dHJpYnV0ZXMuXHJcbiAgICAvLyBOb3RlIHRoYXQgYGNvbnRlbnRFZGl0YWJsZWAgZG9lc24ndCBoYXZlIHRoaXMgcHJvYmxlbTogaXRzIERPTVxyXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBlbnVtZXJhdGVkIHN0cmluZyB2YWx1ZXMuXHJcbiAgICBpZiAoa2V5ID09PSAnc3BlbGxjaGVjaycgfHwga2V5ID09PSAnZHJhZ2dhYmxlJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vICMxNzg3LCAjMjg0MCBmb3JtIHByb3BlcnR5IG9uIGZvcm0gZWxlbWVudHMgaXMgcmVhZG9ubHkgYW5kIG11c3QgYmUgc2V0IGFzXHJcbiAgICAvLyBhdHRyaWJ1dGUuXHJcbiAgICBpZiAoa2V5ID09PSAnZm9ybScpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyAjMTUyNiA8aW5wdXQgbGlzdD4gbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXHJcbiAgICBpZiAoa2V5ID09PSAnbGlzdCcgJiYgZWwudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vICMyNzY2IDx0ZXh0YXJlYSB0eXBlPiBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcclxuICAgIGlmIChrZXkgPT09ICd0eXBlJyAmJiBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gbmF0aXZlIG9uY2xpY2sgd2l0aCBzdHJpbmcgdmFsdWUsIG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxyXG4gICAgaWYgKG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBrZXkgaW4gZWw7XHJcbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUgPSAnJHN0eWxlJykge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHVzZUNzc01vZHVsZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgc2V0dXAoKWApO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtb2R1bGVzID0gaW5zdGFuY2UudHlwZS5fX2Nzc01vZHVsZXM7XHJcbiAgICAgICAgaWYgKCFtb2R1bGVzKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZXMgaW5qZWN0ZWQuYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1vZCA9IG1vZHVsZXNbbmFtZV07XHJcbiAgICAgICAgaWYgKCFtb2QpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZSBuYW1lZCBcIiR7bmFtZX1cIi5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vZDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIFNGQydzIENTUyB2YXJpYWJsZSBpbmplY3Rpb24gZmVhdHVyZS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHVzZUNzc1ZhcnMoZ2V0dGVyKSB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybihgdXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2V0VmFycyA9ICgpID0+IHNldFZhcnNPblZOb2RlKGluc3RhbmNlLnN1YlRyZWUsIGdldHRlcihpbnN0YW5jZS5wcm94eSkpO1xyXG4gICAgb25Nb3VudGVkKCgpID0+IHdhdGNoRWZmZWN0KHNldFZhcnMsIHsgZmx1c2g6ICdwb3N0JyB9KSk7XHJcbiAgICBvblVwZGF0ZWQoc2V0VmFycyk7XHJcbn1cclxuZnVuY3Rpb24gc2V0VmFyc09uVk5vZGUodm5vZGUsIHZhcnMpIHtcclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlO1xyXG4gICAgICAgIHZub2RlID0gc3VzcGVuc2UuYWN0aXZlQnJhbmNoO1xyXG4gICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0VmFyc09uVk5vZGUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCB2YXJzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZHJpbGwgZG93biBIT0NzIHVudGlsIGl0J3MgYSBub24tY29tcG9uZW50IHZub2RlXHJcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50KSB7XHJcbiAgICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnQuc3ViVHJlZTtcclxuICAgIH1cclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiYgdm5vZGUuZWwpIHtcclxuICAgICAgICBzZXRWYXJzT25Ob2RlKHZub2RlLmVsLCB2YXJzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaChjID0+IHNldFZhcnNPblZOb2RlKGMsIHZhcnMpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IFN0YXRpYykge1xyXG4gICAgICAgIGxldCB7IGVsLCBhbmNob3IgfSA9IHZub2RlO1xyXG4gICAgICAgIHdoaWxlIChlbCkge1xyXG4gICAgICAgICAgICBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKTtcclxuICAgICAgICAgICAgaWYgKGVsID09PSBhbmNob3IpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZWwgPSBlbC5uZXh0U2libGluZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0VmFyc09uTm9kZShlbCwgdmFycykge1xyXG4gICAgaWYgKGVsLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJzKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KGAtLSR7a2V5fWAsIHZhcnNba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNvbnN0IFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XHJcbmNvbnN0IEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xyXG4vLyBET00gVHJhbnNpdGlvbiBpcyBhIGhpZ2hlci1vcmRlci1jb21wb25lbnQgYmFzZWQgb24gdGhlIHBsYXRmb3JtLWFnbm9zdGljXHJcbi8vIGJhc2UgVHJhbnNpdGlvbiBjb21wb25lbnQsIHdpdGggRE9NLXNwZWNpZmljIGxvZ2ljLlxyXG5jb25zdCBUcmFuc2l0aW9uID0gKHByb3BzLCB7IHNsb3RzIH0pID0+IGgoQmFzZVRyYW5zaXRpb24sIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocHJvcHMpLCBzbG90cyk7XHJcblRyYW5zaXRpb24uZGlzcGxheU5hbWUgPSAnVHJhbnNpdGlvbic7XHJcbmNvbnN0IERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XHJcbiAgICBuYW1lOiBTdHJpbmcsXHJcbiAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICBjc3M6IHtcclxuICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgIH0sXHJcbiAgICBkdXJhdGlvbjogW1N0cmluZywgTnVtYmVyLCBPYmplY3RdLFxyXG4gICAgZW50ZXJGcm9tQ2xhc3M6IFN0cmluZyxcclxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGVudGVyVG9DbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyRnJvbUNsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVGcm9tQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlVG9DbGFzczogU3RyaW5nXHJcbn07XHJcbmNvbnN0IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSAoVHJhbnNpdGlvbi5wcm9wcyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBCYXNlVHJhbnNpdGlvbi5wcm9wcywgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpO1xyXG4vKipcclxuICogIzMyMjcgSW5jb21pbmcgaG9va3MgbWF5IGJlIG1lcmdlZCBpbnRvIGFycmF5cyB3aGVuIHdyYXBwaW5nIFRyYW5zaXRpb25cclxuICogd2l0aCBjdXN0b20gSE9Dcy5cclxuICovXHJcbmNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MgPSBbXSkgPT4ge1xyXG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcclxuICAgICAgICBob29rLmZvckVhY2goaCA9PiBoKC4uLmFyZ3MpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhvb2spIHtcclxuICAgICAgICBob29rKC4uLmFyZ3MpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQ2hlY2sgaWYgYSBob29rIGV4cGVjdHMgYSBjYWxsYmFjayAoMm5kIGFyZyksIHdoaWNoIG1lYW5zIHRoZSB1c2VyXHJcbiAqIGludGVuZHMgdG8gZXhwbGljaXRseSBjb250cm9sIHRoZSBlbmQgb2YgdGhlIHRyYW5zaXRpb24uXHJcbiAqL1xyXG5jb25zdCBoYXNFeHBsaWNpdENhbGxiYWNrID0gKGhvb2spID0+IHtcclxuICAgIHJldHVybiBob29rXHJcbiAgICAgICAgPyBpc0FycmF5KGhvb2spXHJcbiAgICAgICAgICAgID8gaG9vay5zb21lKGggPT4gaC5sZW5ndGggPiAxKVxyXG4gICAgICAgICAgICA6IGhvb2subGVuZ3RoID4gMVxyXG4gICAgICAgIDogZmFsc2U7XHJcbn07XHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpIHtcclxuICAgIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpIHtcclxuICAgICAgICAgICAgYmFzZVByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChyYXdQcm9wcy5jc3MgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2VQcm9wcztcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbmFtZSA9ICd2JywgdHlwZSwgZHVyYXRpb24sIGVudGVyRnJvbUNsYXNzID0gYCR7bmFtZX0tZW50ZXItZnJvbWAsIGVudGVyQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLCBlbnRlclRvQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci10b2AsIGFwcGVhckZyb21DbGFzcyA9IGVudGVyRnJvbUNsYXNzLCBhcHBlYXJBY3RpdmVDbGFzcyA9IGVudGVyQWN0aXZlQ2xhc3MsIGFwcGVhclRvQ2xhc3MgPSBlbnRlclRvQ2xhc3MsIGxlYXZlRnJvbUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtZnJvbWAsIGxlYXZlQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgLCBsZWF2ZVRvQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS10b2AgfSA9IHJhd1Byb3BzO1xyXG4gICAgY29uc3QgZHVyYXRpb25zID0gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pO1xyXG4gICAgY29uc3QgZW50ZXJEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMF07XHJcbiAgICBjb25zdCBsZWF2ZUR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1sxXTtcclxuICAgIGNvbnN0IHsgb25CZWZvcmVFbnRlciwgb25FbnRlciwgb25FbnRlckNhbmNlbGxlZCwgb25MZWF2ZSwgb25MZWF2ZUNhbmNlbGxlZCwgb25CZWZvcmVBcHBlYXIgPSBvbkJlZm9yZUVudGVyLCBvbkFwcGVhciA9IG9uRW50ZXIsIG9uQXBwZWFyQ2FuY2VsbGVkID0gb25FbnRlckNhbmNlbGxlZCB9ID0gYmFzZVByb3BzO1xyXG4gICAgY29uc3QgZmluaXNoRW50ZXIgPSAoZWwsIGlzQXBwZWFyLCBkb25lKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIGRvbmUgJiYgZG9uZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGZpbmlzaExlYXZlID0gKGVsLCBkb25lKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgZG9uZSAmJiBkb25lKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbWFrZUVudGVySG9vayA9IChpc0FwcGVhcikgPT4ge1xyXG4gICAgICAgIHJldHVybiAoZWwsIGRvbmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaG9vayA9IGlzQXBwZWFyID8gb25BcHBlYXIgOiBvbkVudGVyO1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcclxuICAgICAgICAgICAgY2FsbEhvb2soaG9vaywgW2VsLCByZXNvbHZlXSk7XHJcbiAgICAgICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyRnJvbUNsYXNzIDogZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKGhvb2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBlbnRlckR1cmF0aW9uLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xyXG4gICAgICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVFbnRlciwgW2VsXSk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVBcHBlYXIsIFtlbF0pO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXHJcbiAgICAgICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXHJcbiAgICAgICAgb25MZWF2ZShlbCwgZG9uZSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgLy8gZm9yY2UgcmVmbG93IHNvICotbGVhdmUtZnJvbSBjbGFzc2VzIGltbWVkaWF0ZWx5IHRha2UgZWZmZWN0ICgjMjU5MylcclxuICAgICAgICAgICAgZm9yY2VSZWZsb3coKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcclxuICAgICAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKG9uTGVhdmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBsZWF2ZUR1cmF0aW9uLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25FbnRlckNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hFbnRlcihlbCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkVudGVyQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkKGVsKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25BcHBlYXJDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25MZWF2ZUNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hMZWF2ZShlbCk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKSB7XHJcbiAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QoZHVyYXRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIFtOdW1iZXJPZihkdXJhdGlvbi5lbnRlciksIE51bWJlck9mKGR1cmF0aW9uLmxlYXZlKV07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBuID0gTnVtYmVyT2YoZHVyYXRpb24pO1xyXG4gICAgICAgIHJldHVybiBbbiwgbl07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gTnVtYmVyT2YodmFsKSB7XHJcbiAgICBjb25zdCByZXMgPSB0b051bWJlcih2YWwpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcclxuICAgICAgICB2YWxpZGF0ZUR1cmF0aW9uKHJlcyk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb24odmFsKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gYCArXHJcbiAgICAgICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb24gaXMgTmFOIC0gYCArXHJcbiAgICAgICAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGVsLmNsYXNzTGlzdC5hZGQoYykpO1xyXG4gICAgKGVsLl92dGMgfHxcclxuICAgICAgICAoZWwuX3Z0YyA9IG5ldyBTZXQoKSkpLmFkZChjbHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XHJcbiAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcclxuICAgIGNvbnN0IHsgX3Z0YyB9ID0gZWw7XHJcbiAgICBpZiAoX3Z0Yykge1xyXG4gICAgICAgIF92dGMuZGVsZXRlKGNscyk7XHJcbiAgICAgICAgaWYgKCFfdnRjLnNpemUpIHtcclxuICAgICAgICAgICAgZWwuX3Z0YyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV4dEZyYW1lKGNiKSB7XHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XHJcbiAgICB9KTtcclxufVxyXG5sZXQgZW5kSWQgPSAwO1xyXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgZXhwbGljaXRUaW1lb3V0LCByZXNvbHZlKSB7XHJcbiAgICBjb25zdCBpZCA9IChlbC5fZW5kSWQgPSArK2VuZElkKTtcclxuICAgIGNvbnN0IHJlc29sdmVJZk5vdFN0YWxlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChpZCA9PT0gZWwuX2VuZElkKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKGV4cGxpY2l0VGltZW91dCkge1xyXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmVJZk5vdFN0YWxlLCBleHBsaWNpdFRpbWVvdXQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyB0eXBlLCB0aW1lb3V0LCBwcm9wQ291bnQgfSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xyXG4gICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVuZEV2ZW50ID0gdHlwZSArICdlbmQnO1xyXG4gICAgbGV0IGVuZGVkID0gMDtcclxuICAgIGNvbnN0IGVuZCA9ICgpID0+IHtcclxuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XHJcbiAgICAgICAgcmVzb2x2ZUlmTm90U3RhbGUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBvbkVuZCA9IChlKSA9PiB7XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCAmJiArK2VuZGVkID49IHByb3BDb3VudCkge1xyXG4gICAgICAgICAgICBlbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XHJcbiAgICAgICAgICAgIGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHRpbWVvdXQgKyAxKTtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKSB7XHJcbiAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XHJcbiAgICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXHJcbiAgICBjb25zdCBnZXRTdHlsZVByb3BlcnRpZXMgPSAoa2V5KSA9PiAoc3R5bGVzW2tleV0gfHwgJycpLnNwbGl0KCcsICcpO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhUUkFOU0lUSU9OICsgJ0RlbGF5Jyk7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKFRSQU5TSVRJT04gKyAnRHVyYXRpb24nKTtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IGdldFN0eWxlUHJvcGVydGllcyhBTklNQVRJT04gKyAnRGVsYXknKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhBTklNQVRJT04gKyAnRHVyYXRpb24nKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcclxuICAgIGxldCB0eXBlID0gbnVsbDtcclxuICAgIGxldCB0aW1lb3V0ID0gMDtcclxuICAgIGxldCBwcm9wQ291bnQgPSAwO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcclxuICAgICAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xyXG4gICAgICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xyXG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gQU5JTUFUSU9OO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcclxuICAgICAgICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xyXG4gICAgICAgIHR5cGUgPVxyXG4gICAgICAgICAgICB0aW1lb3V0ID4gMFxyXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcclxuICAgICAgICAgICAgICAgICAgICA/IFRSQU5TSVRJT05cclxuICAgICAgICAgICAgICAgICAgICA6IEFOSU1BVElPTlxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIHByb3BDb3VudCA9IHR5cGVcclxuICAgICAgICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXHJcbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgICAgICAgOiAwO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaGFzVHJhbnNmb3JtID0gdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxyXG4gICAgICAgIC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS8udGVzdChzdHlsZXNbVFJBTlNJVElPTiArICdQcm9wZXJ0eSddKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICB0aW1lb3V0LFxyXG4gICAgICAgIHByb3BDb3VudCxcclxuICAgICAgICBoYXNUcmFuc2Zvcm1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xyXG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLmR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSkpKTtcclxufVxyXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlclxyXG4vLyBudW1iZXJzIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cclxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93blxyXG4vLyAoaS5lLiBhY3RpbmcgYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xyXG5mdW5jdGlvbiB0b01zKHMpIHtcclxuICAgIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMDtcclxufVxyXG4vLyBzeW5jaHJvbm91c2x5IGZvcmNlIGxheW91dCB0byBwdXQgZWxlbWVudHMgaW50byBhIGNlcnRhaW4gc3RhdGVcclxuZnVuY3Rpb24gZm9yY2VSZWZsb3coKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XHJcbn1cblxuY29uc3QgcG9zaXRpb25NYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBuZXdQb3NpdGlvbk1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IFRyYW5zaXRpb25Hcm91cEltcGwgPSB7XHJcbiAgICBuYW1lOiAnVHJhbnNpdGlvbkdyb3VwJyxcclxuICAgIHByb3BzOiAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywge1xyXG4gICAgICAgIHRhZzogU3RyaW5nLFxyXG4gICAgICAgIG1vdmVDbGFzczogU3RyaW5nXHJcbiAgICB9KSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XHJcbiAgICAgICAgbGV0IHByZXZDaGlsZHJlbjtcclxuICAgICAgICBsZXQgY2hpbGRyZW47XHJcbiAgICAgICAgb25VcGRhdGVkKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gY2hpbGRyZW4gaXMgZ3VhcmFudGVlZCB0byBleGlzdCBhZnRlciBpbml0aWFsIHJlbmRlclxyXG4gICAgICAgICAgICBpZiAoIXByZXZDaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtb3ZlQ2xhc3MgPSBwcm9wcy5tb3ZlQ2xhc3MgfHwgYCR7cHJvcHMubmFtZSB8fCAndid9LW1vdmVgO1xyXG4gICAgICAgICAgICBpZiAoIWhhc0NTU1RyYW5zZm9ybShwcmV2Q2hpbGRyZW5bMF0uZWwsIGluc3RhbmNlLnZub2RlLmVsLCBtb3ZlQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXHJcbiAgICAgICAgICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxyXG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgbW92ZWRDaGlsZHJlbiA9IHByZXZDaGlsZHJlbi5maWx0ZXIoYXBwbHlUcmFuc2xhdGlvbik7XHJcbiAgICAgICAgICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxyXG4gICAgICAgICAgICBmb3JjZVJlZmxvdygpO1xyXG4gICAgICAgICAgICBtb3ZlZENoaWxkcmVuLmZvckVhY2goYyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGMuZWw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IChlbC5fbW92ZUNiID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBjYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgY2IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgY3NzVHJhbnNpdGlvblByb3BzID0gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcyk7XHJcbiAgICAgICAgICAgIGxldCB0YWcgPSByYXdQcm9wcy50YWcgfHwgRnJhZ21lbnQ7XHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgPyBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpKSA6IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGNoaWxkLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgPFRyYW5zaXRpb25Hcm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJldkNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gcHJldkNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhjaGlsZCwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoY2hpbGQsIGNoaWxkLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodGFnLCBudWxsLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuY29uc3QgVHJhbnNpdGlvbkdyb3VwID0gVHJhbnNpdGlvbkdyb3VwSW1wbDtcclxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMoYykge1xyXG4gICAgY29uc3QgZWwgPSBjLmVsO1xyXG4gICAgaWYgKGVsLl9tb3ZlQ2IpIHtcclxuICAgICAgICBlbC5fbW92ZUNiKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZWwuX2VudGVyQ2IpIHtcclxuICAgICAgICBlbC5fZW50ZXJDYigpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uKGMpIHtcclxuICAgIG5ld1Bvc2l0aW9uTWFwLnNldChjLCBjLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcclxufVxyXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uKGMpIHtcclxuICAgIGNvbnN0IG9sZFBvcyA9IHBvc2l0aW9uTWFwLmdldChjKTtcclxuICAgIGNvbnN0IG5ld1BvcyA9IG5ld1Bvc2l0aW9uTWFwLmdldChjKTtcclxuICAgIGNvbnN0IGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcclxuICAgIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XHJcbiAgICBpZiAoZHggfHwgZHkpIHtcclxuICAgICAgICBjb25zdCBzID0gYy5lbC5zdHlsZTtcclxuICAgICAgICBzLnRyYW5zZm9ybSA9IHMud2Via2l0VHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2R4fXB4LCR7ZHl9cHgpYDtcclxuICAgICAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFzQ1NTVHJhbnNmb3JtKGVsLCByb290LCBtb3ZlQ2xhc3MpIHtcclxuICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xyXG4gICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXHJcbiAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXHJcbiAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcclxuICAgIC8vIGlzIGFwcGxpZWQuXHJcbiAgICBjb25zdCBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xyXG4gICAgaWYgKGVsLl92dGMpIHtcclxuICAgICAgICBlbC5fdnRjLmZvckVhY2goY2xzID0+IHtcclxuICAgICAgICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LnJlbW92ZShjKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtb3ZlQ2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QuYWRkKGMpKTtcclxuICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSAocm9vdC5ub2RlVHlwZSA9PT0gMVxyXG4gICAgICAgID8gcm9vdFxyXG4gICAgICAgIDogcm9vdC5wYXJlbnROb2RlKTtcclxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9uZSk7XHJcbiAgICBjb25zdCB7IGhhc1RyYW5zZm9ybSB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xyXG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNsb25lKTtcclxuICAgIHJldHVybiBoYXNUcmFuc2Zvcm07XHJcbn1cblxuY29uc3QgZ2V0TW9kZWxBc3NpZ25lciA9ICh2bm9kZSkgPT4ge1xyXG4gICAgY29uc3QgZm4gPSB2bm9kZS5wcm9wc1snb25VcGRhdGU6bW9kZWxWYWx1ZSddO1xyXG4gICAgcmV0dXJuIGlzQXJyYXkoZm4pID8gdmFsdWUgPT4gaW52b2tlQXJyYXlGbnMoZm4sIHZhbHVlKSA6IGZuO1xyXG59O1xyXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xyXG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xyXG4gICAgaWYgKHRhcmdldC5jb21wb3NpbmcpIHtcclxuICAgICAgICB0YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsICdpbnB1dCcpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXIoZWwsIHR5cGUpIHtcclxuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xyXG4gICAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xyXG59XHJcbi8vIFdlIGFyZSBleHBvcnRpbmcgdGhlIHYtbW9kZWwgcnVudGltZSBkaXJlY3RseSBhcyB2bm9kZSBob29rcyBzbyB0aGF0IGl0IGNhblxyXG4vLyBiZSB0cmVlLXNoYWtlbiBpbiBjYXNlIHYtbW9kZWwgaXMgbmV2ZXIgdXNlZC5cclxuY29uc3Qgdk1vZGVsVGV4dCA9IHtcclxuICAgIGNyZWF0ZWQoZWwsIHsgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGNhc3RUb051bWJlciA9IG51bWJlciB8fCBlbC50eXBlID09PSAnbnVtYmVyJztcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBsYXp5ID8gJ2NoYW5nZScgOiAnaW5wdXQnLCBlID0+IHtcclxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0LmNvbXBvc2luZylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgbGV0IGRvbVZhbHVlID0gZWwudmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgICAgICBkb21WYWx1ZSA9IGRvbVZhbHVlLnRyaW0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjYXN0VG9OdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIGRvbVZhbHVlID0gdG9OdW1iZXIoZG9tVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsLl9hc3NpZ24oZG9tVmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlbC52YWx1ZSA9IGVsLnZhbHVlLnRyaW0oKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbGF6eSkge1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xyXG4gICAgICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXHJcbiAgICAgICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcclxuICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxyXG4gICAgICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBzZXQgdmFsdWUgb24gbW91bnRlZCBzbyBpdCdzIGFmdGVyIG1pbi9tYXggZm9yIHR5cGU9XCJyYW5nZVwiXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBlbC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgbW9kaWZpZXJzOiB7IHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIC8vIGF2b2lkIGNsZWFyaW5nIHVucmVzb2x2ZWQgdGV4dC4gIzIzMDJcclxuICAgICAgICBpZiAoZWwuY29tcG9zaW5nKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XHJcbiAgICAgICAgICAgIGlmICh0cmltICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKG51bWJlciB8fCBlbC50eXBlID09PSAnbnVtYmVyJykgJiYgdG9OdW1iZXIoZWwudmFsdWUpID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XHJcbiAgICAgICAgaWYgKGVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgdk1vZGVsQ2hlY2tib3ggPSB7XHJcbiAgICAvLyAjNDA5NiBhcnJheSBjaGVja2JveGVzIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcclxuICAgIGRlZXA6IHRydWUsXHJcbiAgICBjcmVhdGVkKGVsLCBfLCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2RlbFZhbHVlID0gZWwuX21vZGVsVmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IGdldFZhbHVlKGVsKTtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGFzc2lnbiA9IGVsLl9hc3NpZ247XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG1vZGVsVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGxvb3NlSW5kZXhPZihtb2RlbFZhbHVlLCBlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSBpbmRleCAhPT0gLTE7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCAmJiAhZm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NpZ24obW9kZWxWYWx1ZS5jb25jYXQoZWxlbWVudFZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hlY2tlZCAmJiBmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gWy4uLm1vZGVsVmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKGZpbHRlcmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1NldChtb2RlbFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gbmV3IFNldChtb2RlbFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmRlbGV0ZShlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXNzaWduKGNsb25lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhc3NpZ24oZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgLy8gc2V0IGluaXRpYWwgY2hlY2tlZCBvbiBtb3VudCB0byB3YWl0IGZvciB0cnVlLXZhbHVlL2ZhbHNlLXZhbHVlXHJcbiAgICBtb3VudGVkOiBzZXRDaGVja2VkLFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBzZXRDaGVja2VkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICBlbC5fbW9kZWxWYWx1ZSA9IHZhbHVlO1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBnZXRDaGVja2JveFZhbHVlKGVsLCB0cnVlKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3Qgdk1vZGVsUmFkaW8gPSB7XHJcbiAgICBjcmVhdGVkKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihnZXRWYWx1ZShlbCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgdk1vZGVsU2VsZWN0ID0ge1xyXG4gICAgLy8gPHNlbGVjdCBtdWx0aXBsZT4gdmFsdWUgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxyXG4gICAgZGVlcDogdHJ1ZSxcclxuICAgIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGlzU2V0TW9kZWwgPSBpc1NldCh2YWx1ZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyXHJcbiAgICAgICAgICAgICAgICAuY2FsbChlbC5vcHRpb25zLCAobykgPT4gby5zZWxlY3RlZClcclxuICAgICAgICAgICAgICAgIC5tYXAoKG8pID0+IG51bWJlciA/IHRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pKTtcclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihlbC5tdWx0aXBsZVxyXG4gICAgICAgICAgICAgICAgPyBpc1NldE1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgU2V0KHNlbGVjdGVkVmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxcclxuICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxbMF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgIH0sXHJcbiAgICAvLyBzZXQgdmFsdWUgaW4gbW91bnRlZCAmIHVwZGF0ZWQgYmVjYXVzZSA8c2VsZWN0PiByZWxpZXMgb24gaXRzIGNoaWxkcmVuXHJcbiAgICAvLyA8b3B0aW9uPnMuXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgX2JpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSkge1xyXG4gICAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xyXG4gICAgaWYgKGlzTXVsdGlwbGUgJiYgIWlzQXJyYXkodmFsdWUpICYmICFpc1NldCh2YWx1ZSkpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybihgPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPiBleHBlY3RzIGFuIEFycmF5IG9yIFNldCB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGAgK1xyXG4gICAgICAgICAgICAgICAgYGJ1dCBnb3QgJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKX0uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xyXG4gICAgICAgIGlmIChpc011bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBvcHRpb25WYWx1ZSkgPiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpXHJcbiAgICAgICAgICAgICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTXVsdGlwbGUgJiYgZWwuc2VsZWN0ZWRJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgICB9XHJcbn1cclxuLy8gcmV0cmlldmUgcmF3IHZhbHVlIHNldCB2aWEgOnZhbHVlIGJpbmRpbmdzXHJcbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XHJcbiAgICByZXR1cm4gJ192YWx1ZScgaW4gZWwgPyBlbC5fdmFsdWUgOiBlbC52YWx1ZTtcclxufVxyXG4vLyByZXRyaWV2ZSByYXcgdmFsdWUgZm9yIHRydWUtdmFsdWUgYW5kIGZhbHNlLXZhbHVlIHNldCB2aWEgOnRydWUtdmFsdWUgb3IgOmZhbHNlLXZhbHVlIGJpbmRpbmdzXHJcbmZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpIHtcclxuICAgIGNvbnN0IGtleSA9IGNoZWNrZWQgPyAnX3RydWVWYWx1ZScgOiAnX2ZhbHNlVmFsdWUnO1xyXG4gICAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xyXG59XHJcbmNvbnN0IHZNb2RlbER5bmFtaWMgPSB7XHJcbiAgICBjcmVhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCAnY3JlYXRlZCcpO1xyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsICdtb3VudGVkJyk7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgJ2JlZm9yZVVwZGF0ZScpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCAndXBkYXRlZCcpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XHJcbiAgICBsZXQgbW9kZWxUb1VzZTtcclxuICAgIHN3aXRjaCAoZWwudGFnTmFtZSkge1xyXG4gICAgICAgIGNhc2UgJ1NFTEVDVCc6XHJcbiAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxTZWxlY3Q7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ1RFWFRBUkVBJzpcclxuICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbFRleHQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHN3aXRjaCAodm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxDaGVja2JveDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbFRvVXNlID0gdk1vZGVsUmFkaW87XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxUZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBmbiA9IG1vZGVsVG9Vc2VbaG9va107XHJcbiAgICBmbiAmJiBmbihlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSk7XHJcbn1cblxuY29uc3Qgc3lzdGVtTW9kaWZpZXJzID0gWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ107XHJcbmNvbnN0IG1vZGlmaWVyR3VhcmRzID0ge1xyXG4gICAgc3RvcDogZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxyXG4gICAgcHJldmVudDogZSA9PiBlLnByZXZlbnREZWZhdWx0KCksXHJcbiAgICBzZWxmOiBlID0+IGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQsXHJcbiAgICBjdHJsOiBlID0+ICFlLmN0cmxLZXksXHJcbiAgICBzaGlmdDogZSA9PiAhZS5zaGlmdEtleSxcclxuICAgIGFsdDogZSA9PiAhZS5hbHRLZXksXHJcbiAgICBtZXRhOiBlID0+ICFlLm1ldGFLZXksXHJcbiAgICBsZWZ0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDAsXHJcbiAgICBtaWRkbGU6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMSxcclxuICAgIHJpZ2h0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDIsXHJcbiAgICBleGFjdDogKGUsIG1vZGlmaWVycykgPT4gc3lzdGVtTW9kaWZpZXJzLnNvbWUobSA9PiBlW2Ake219S2V5YF0gJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhtKSlcclxufTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB3aXRoTW9kaWZpZXJzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcclxuICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBndWFyZCA9IG1vZGlmaWVyR3VhcmRzW21vZGlmaWVyc1tpXV07XHJcbiAgICAgICAgICAgIGlmIChndWFyZCAmJiBndWFyZChldmVudCwgbW9kaWZpZXJzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZuKGV2ZW50LCAuLi5hcmdzKTtcclxuICAgIH07XHJcbn07XHJcbi8vIEtlcHQgZm9yIDIueCBjb21wYXQuXHJcbi8vIE5vdGU6IElFMTEgY29tcGF0IGZvciBgc3BhY2ViYXJgIGFuZCBgZGVsYCBpcyByZW1vdmVkIGZvciBub3cuXHJcbmNvbnN0IGtleU5hbWVzID0ge1xyXG4gICAgZXNjOiAnZXNjYXBlJyxcclxuICAgIHNwYWNlOiAnICcsXHJcbiAgICB1cDogJ2Fycm93LXVwJyxcclxuICAgIGxlZnQ6ICdhcnJvdy1sZWZ0JyxcclxuICAgIHJpZ2h0OiAnYXJyb3ctcmlnaHQnLFxyXG4gICAgZG93bjogJ2Fycm93LWRvd24nLFxyXG4gICAgZGVsZXRlOiAnYmFja3NwYWNlJ1xyXG59O1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHdpdGhLZXlzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcclxuICAgIHJldHVybiAoZXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoISgna2V5JyBpbiBldmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBldmVudEtleSA9IGh5cGhlbmF0ZShldmVudC5rZXkpO1xyXG4gICAgICAgIGlmIChtb2RpZmllcnMuc29tZShrID0+IGsgPT09IGV2ZW50S2V5IHx8IGtleU5hbWVzW2tdID09PSBldmVudEtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB2U2hvdyA9IHtcclxuICAgIGJlZm9yZU1vdW50KGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICAgICAgZWwuX3ZvZCA9IGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB1cGRhdGVkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xyXG4gICAgICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5sZWF2ZShlbCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGJlZm9yZVVubW91bnQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2V0RGlzcGxheShlbCwgdmFsdWUpIHtcclxuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl92b2QgOiAnbm9uZSc7XHJcbn1cblxuY29uc3QgcmVuZGVyZXJPcHRpb25zID0gZXh0ZW5kKHsgcGF0Y2hQcm9wLCBmb3JjZVBhdGNoUHJvcCB9LCBub2RlT3BzKTtcclxuLy8gbGF6eSBjcmVhdGUgdGhlIHJlbmRlcmVyIC0gdGhpcyBtYWtlcyBjb3JlIHJlbmRlcmVyIGxvZ2ljIHRyZWUtc2hha2FibGVcclxuLy8gaW4gY2FzZSB0aGUgdXNlciBvbmx5IGltcG9ydHMgcmVhY3Rpdml0eSB1dGlsaXRpZXMgZnJvbSBWdWUuXHJcbmxldCByZW5kZXJlcjtcclxubGV0IGVuYWJsZWRIeWRyYXRpb24gPSBmYWxzZTtcclxuZnVuY3Rpb24gZW5zdXJlUmVuZGVyZXIoKSB7XHJcbiAgICByZXR1cm4gcmVuZGVyZXIgfHwgKHJlbmRlcmVyID0gY3JlYXRlUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKSk7XHJcbn1cclxuZnVuY3Rpb24gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKSB7XHJcbiAgICByZW5kZXJlciA9IGVuYWJsZWRIeWRyYXRpb25cclxuICAgICAgICA/IHJlbmRlcmVyXHJcbiAgICAgICAgOiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xyXG4gICAgZW5hYmxlZEh5ZHJhdGlvbiA9IHRydWU7XHJcbiAgICByZXR1cm4gcmVuZGVyZXI7XHJcbn1cclxuLy8gdXNlIGV4cGxpY2l0IHR5cGUgY2FzdHMgaGVyZSB0byBhdm9pZCBpbXBvcnQoKSBjYWxscyBpbiByb2xsZWQtdXAgZC50c1xyXG5jb25zdCByZW5kZXIgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGVuc3VyZVJlbmRlcmVyKCkucmVuZGVyKC4uLmFyZ3MpO1xyXG59KTtcclxuY29uc3QgaHlkcmF0ZSA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5oeWRyYXRlKC4uLmFyZ3MpO1xyXG59KTtcclxuY29uc3QgY3JlYXRlQXBwID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICBjb25zdCBhcHAgPSBlbnN1cmVSZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xyXG4gICAgICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XHJcbiAgICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lcilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGFwcC5fY29tcG9uZW50O1xyXG4gICAgICAgIGlmICghaXNGdW5jdGlvbihjb21wb25lbnQpICYmICFjb21wb25lbnQucmVuZGVyICYmICFjb21wb25lbnQudGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgLy8gX19VTlNBRkVfX1xyXG4gICAgICAgICAgICAvLyBSZWFzb246IHBvdGVudGlhbCBleGVjdXRpb24gb2YgSlMgZXhwcmVzc2lvbnMgaW4gaW4tRE9NIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAvLyBUaGUgdXNlciBtdXN0IG1ha2Ugc3VyZSB0aGUgaW4tRE9NIHRlbXBsYXRlIGlzIHRydXN0ZWQuIElmIGl0J3NcclxuICAgICAgICAgICAgLy8gcmVuZGVyZWQgYnkgdGhlIHNlcnZlciwgdGhlIHRlbXBsYXRlIHNob3VsZCBub3QgY29udGFpbiBhbnkgdXNlciBkYXRhLlxyXG4gICAgICAgICAgICBjb21wb25lbnQudGVtcGxhdGUgPSBjb250YWluZXIuaW5uZXJIVE1MO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjbGVhciBjb250ZW50IGJlZm9yZSBtb3VudGluZ1xyXG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICBjb25zdCBwcm94eSA9IG1vdW50KGNvbnRhaW5lciwgZmFsc2UsIGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xyXG4gICAgICAgIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ3YtY2xvYWsnKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnZGF0YS12LWFwcCcsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb3h5O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBhcHA7XHJcbn0pO1xyXG5jb25zdCBjcmVhdGVTU1JBcHAgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGNvbnN0IGFwcCA9IGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XHJcbiAgICAgICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcclxuICAgIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xyXG4gICAgICAgIGlmIChjb250YWluZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vdW50KGNvbnRhaW5lciwgdHJ1ZSwgY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBhcHA7XHJcbn0pO1xyXG5mdW5jdGlvbiBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApIHtcclxuICAgIC8vIEluamVjdCBgaXNOYXRpdmVUYWdgXHJcbiAgICAvLyB0aGlzIGlzIHVzZWQgZm9yIGNvbXBvbmVudCBuYW1lIHZhbGlkYXRpb24gKGRldiBvbmx5KVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdpc05hdGl2ZVRhZycsIHtcclxuICAgICAgICB2YWx1ZTogKHRhZykgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSxcclxuICAgICAgICB3cml0YWJsZTogZmFsc2VcclxuICAgIH0pO1xyXG59XHJcbi8vIGRldiBvbmx5XHJcbmZ1bmN0aW9uIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCkge1xyXG4gICAgaWYgKGlzUnVudGltZU9ubHkoKSkge1xyXG4gICAgICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGFwcC5jb25maWcuaXNDdXN0b21FbGVtZW50O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCAnaXNDdXN0b21FbGVtZW50Jywge1xyXG4gICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDdXN0b21FbGVtZW50O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBUaGUgXFxgaXNDdXN0b21FbGVtZW50XFxgIGNvbmZpZyBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVXNlIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBcXGBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50XFxgIGluc3RlYWQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBjb21waWxlck9wdGlvbnMgPSBhcHAuY29uZmlnLmNvbXBpbGVyT3B0aW9ucztcclxuICAgICAgICBjb25zdCBtc2cgPSBgVGhlIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBjb25maWcgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgYCArXHJcbiAgICAgICAgICAgIGBhIGJ1aWxkIG9mIFZ1ZS5qcyB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyIChha2EgXCJmdWxsIGJ1aWxkXCIpLiBgICtcclxuICAgICAgICAgICAgYFNpbmNlIHlvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCwgXFxgY29tcGlsZXJPcHRpb25zXFxgIGAgK1xyXG4gICAgICAgICAgICBgbXVzdCBiZSBwYXNzZWQgdG8gXFxgQHZ1ZS9jb21waWxlci1kb21cXGAgaW4gdGhlIGJ1aWxkIHNldHVwIGluc3RlYWQuXFxuYCArXHJcbiAgICAgICAgICAgIGAtIEZvciB2dWUtbG9hZGVyOiBwYXNzIGl0IHZpYSB2dWUtbG9hZGVyJ3MgXFxgY29tcGlsZXJPcHRpb25zXFxgIGxvYWRlciBvcHRpb24uXFxuYCArXHJcbiAgICAgICAgICAgIGAtIEZvciB2dWUtY2xpOiBzZWUgaHR0cHM6Ly9jbGkudnVlanMub3JnL2d1aWRlL3dlYnBhY2suaHRtbCNtb2RpZnlpbmctb3B0aW9ucy1vZi1hLWxvYWRlclxcbmAgK1xyXG4gICAgICAgICAgICBgLSBGb3Igdml0ZTogcGFzcyBpdCB2aWEgQHZpdGVqcy9wbHVnaW4tdnVlIG9wdGlvbnMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvdHJlZS9tYWluL3BhY2thZ2VzL3BsdWdpbi12dWUjZXhhbXBsZS1mb3ItcGFzc2luZy1vcHRpb25zLXRvLXZ1ZWNvbXBpbGVyLWRvbWA7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdjb21waWxlck9wdGlvbnMnLCB7XHJcbiAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4obXNnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlck9wdGlvbnM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4obXNnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXIpIHtcclxuICAgIGlmIChpc1N0cmluZyhjb250YWluZXIpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250YWluZXIpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXJlcykge1xyXG4gICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbW91bnQgYXBwOiBtb3VudCB0YXJnZXQgc2VsZWN0b3IgXCIke2NvbnRhaW5lcn1cIiByZXR1cm5lZCBudWxsLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIGNvbnRhaW5lciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290ICYmXHJcbiAgICAgICAgY29udGFpbmVyLm1vZGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgd2FybihgbW91bnRpbmcgb24gYSBTaGFkb3dSb290IHdpdGggXFxge21vZGU6IFwiY2xvc2VkXCJ9XFxgIG1heSBsZWFkIHRvIHVucHJlZGljdGFibGUgYnVnc2ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcclxufVxuXG5leHBvcnQgeyBUcmFuc2l0aW9uLCBUcmFuc2l0aW9uR3JvdXAsIGNyZWF0ZUFwcCwgY3JlYXRlU1NSQXBwLCBoeWRyYXRlLCByZW5kZXIsIHVzZUNzc01vZHVsZSwgdXNlQ3NzVmFycywgdk1vZGVsQ2hlY2tib3gsIHZNb2RlbER5bmFtaWMsIHZNb2RlbFJhZGlvLCB2TW9kZWxTZWxlY3QsIHZNb2RlbFRleHQsIHZTaG93LCB3aXRoS2V5cywgd2l0aE1vZGlmaWVycyB9O1xuIiwiLyoqXHJcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxyXG4gKiBpcyBpbiB0aGF0IG1hcC5cclxuICogSU1QT1JUQU5UOiBhbGwgY2FsbHMgb2YgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIHByZWZpeGVkIHdpdGhcclxuICogXFwvXFwqI1xcX1xcX1BVUkVcXF9cXF9cXCpcXC9cclxuICogU28gdGhhdCByb2xsdXAgY2FuIHRyZWUtc2hha2UgdGhlbSBpZiBuZWNlc3NhcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xyXG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/IHZhbCA9PiAhIW1hcFt2YWwudG9Mb3dlckNhc2UoKV0gOiB2YWwgPT4gISFtYXBbdmFsXTtcclxufVxuXG4vKipcclxuICogZGV2IG9ubHkgZmxhZyAtPiBuYW1lIG1hcHBpbmdcclxuICovXHJcbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xyXG4gICAgWzEgLyogVEVYVCAqL106IGBURVhUYCxcclxuICAgIFsyIC8qIENMQVNTICovXTogYENMQVNTYCxcclxuICAgIFs0IC8qIFNUWUxFICovXTogYFNUWUxFYCxcclxuICAgIFs4IC8qIFBST1BTICovXTogYFBST1BTYCxcclxuICAgIFsxNiAvKiBGVUxMX1BST1BTICovXTogYEZVTExfUFJPUFNgLFxyXG4gICAgWzMyIC8qIEhZRFJBVEVfRVZFTlRTICovXTogYEhZRFJBVEVfRVZFTlRTYCxcclxuICAgIFs2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dOiBgU1RBQkxFX0ZSQUdNRU5UYCxcclxuICAgIFsxMjggLyogS0VZRURfRlJBR01FTlQgKi9dOiBgS0VZRURfRlJBR01FTlRgLFxyXG4gICAgWzI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovXTogYFVOS0VZRURfRlJBR01FTlRgLFxyXG4gICAgWzUxMiAvKiBORUVEX1BBVENIICovXTogYE5FRURfUEFUQ0hgLFxyXG4gICAgWzEwMjQgLyogRFlOQU1JQ19TTE9UUyAqL106IGBEWU5BTUlDX1NMT1RTYCxcclxuICAgIFsyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovXTogYERFVl9ST09UX0ZSQUdNRU5UYCxcclxuICAgIFstMSAvKiBIT0lTVEVEICovXTogYEhPSVNURURgLFxyXG4gICAgWy0yIC8qIEJBSUwgKi9dOiBgQkFJTGBcclxufTtcblxuLyoqXHJcbiAqIERldiBvbmx5XHJcbiAqL1xyXG5jb25zdCBzbG90RmxhZ3NUZXh0ID0ge1xyXG4gICAgWzEgLyogU1RBQkxFICovXTogJ1NUQUJMRScsXHJcbiAgICBbMiAvKiBEWU5BTUlDICovXTogJ0RZTkFNSUMnLFxyXG4gICAgWzMgLyogRk9SV0FSREVEICovXTogJ0ZPUldBUkRFRCdcclxufTtcblxuY29uc3QgR0xPQkFMU19XSElURV9MSVNURUQgPSAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTixwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSwnICtcclxuICAgICdkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LCcgK1xyXG4gICAgJ09iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50JztcclxuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEdMT0JBTFNfV0hJVEVfTElTVEVEKTtcblxuY29uc3QgcmFuZ2UgPSAyO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xyXG4gICAgLy8gU3BsaXQgdGhlIGNvbnRlbnQgaW50byBpbmRpdmlkdWFsIGxpbmVzIGJ1dCBjYXB0dXJlIHRoZSBuZXdsaW5lIHNlcXVlbmNlXHJcbiAgICAvLyB0aGF0IHNlcGFyYXRlZCBlYWNoIGxpbmUuIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIGFjdHVhbCBzZXF1ZW5jZSBpc1xyXG4gICAgLy8gbmVlZGVkIHRvIHByb3Blcmx5IHRha2UgaW50byBhY2NvdW50IHRoZSBmdWxsIGxpbmUgbGVuZ3RoIGZvciBvZmZzZXRcclxuICAgIC8vIGNvbXBhcmlzb25cclxuICAgIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvKFxccj9cXG4pLyk7XHJcbiAgICAvLyBTZXBhcmF0ZSB0aGUgbGluZXMgYW5kIG5ld2xpbmUgc2VxdWVuY2VzIGludG8gc2VwYXJhdGUgYXJyYXlzIGZvciBlYXNpZXIgcmVmZXJlbmNpbmdcclxuICAgIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMSk7XHJcbiAgICBsaW5lcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAwKTtcclxuICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICBjb25zdCByZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb3VudCArPVxyXG4gICAgICAgICAgICBsaW5lc1tpXS5sZW5ndGggK1xyXG4gICAgICAgICAgICAgICAgKChuZXdsaW5lU2VxdWVuY2VzW2ldICYmIG5ld2xpbmVTZXF1ZW5jZXNbaV0ubGVuZ3RoKSB8fCAwKTtcclxuICAgICAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGogKyAxO1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goYCR7bGluZX0keycgJy5yZXBlYXQoTWF0aC5tYXgoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgsIDApKX18ICAke2xpbmVzW2pdfWApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmVTZXFMZW5ndGggPSAobmV3bGluZVNlcXVlbmNlc1tqXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2pdLmxlbmd0aCkgfHwgMDtcclxuICAgICAgICAgICAgICAgIGlmIChqID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KDEsIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICcgJy5yZXBlYXQocGFkKSArICdeJy5yZXBlYXQobGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqID4gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICdeJy5yZXBlYXQobGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXMuam9pbignXFxuJyk7XHJcbn1cblxuLyoqXHJcbiAqIE9uIHRoZSBjbGllbnQgd2Ugb25seSBuZWVkIHRvIG9mZmVyIHNwZWNpYWwgY2FzZXMgZm9yIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0XHJcbiAqIGhhdmUgZGlmZmVyZW50IG5hbWVzIGZyb20gdGhlaXIgY29ycmVzcG9uZGluZyBkb20gcHJvcGVydGllczpcclxuICogLSBpdGVtc2NvcGUgLT4gTi9BXHJcbiAqIC0gYWxsb3dmdWxsc2NyZWVuIC0+IGFsbG93RnVsbHNjcmVlblxyXG4gKiAtIGZvcm1ub3ZhbGlkYXRlIC0+IGZvcm1Ob1ZhbGlkYXRlXHJcbiAqIC0gaXNtYXAgLT4gaXNNYXBcclxuICogLSBub21vZHVsZSAtPiBub01vZHVsZVxyXG4gKiAtIG5vdmFsaWRhdGUgLT4gbm9WYWxpZGF0ZVxyXG4gKiAtIHJlYWRvbmx5IC0+IHJlYWRPbmx5XHJcbiAqL1xyXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XHJcbmNvbnN0IGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xyXG4vKipcclxuICogVGhlIGZ1bGwgbGlzdCBpcyBuZWVkZWQgZHVyaW5nIFNTUiB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGluaXRpYWwgbWFya3VwLlxyXG4gKi9cclxuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzICtcclxuICAgIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGAgK1xyXG4gICAgYGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsYCArXHJcbiAgICBgY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGApO1xyXG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XHJcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcclxuZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xyXG4gICAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGlzVW5zYWZlID0gdW5zYWZlQXR0ckNoYXJSRS50ZXN0KG5hbWUpO1xyXG4gICAgaWYgKGlzVW5zYWZlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmUpO1xyXG59XHJcbmNvbnN0IHByb3BzVG9BdHRyTWFwID0ge1xyXG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcclxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcclxuICAgIGh0bWxGb3I6ICdmb3InLFxyXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcclxufTtcclxuLyoqXHJcbiAqIENTUyBwcm9wZXJ0aWVzIHRoYXQgYWNjZXB0IHBsYWluIG51bWJlcnNcclxuICovXHJcbmNvbnN0IGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCxib3JkZXItaW1hZ2Utb3V0c2V0LGJvcmRlci1pbWFnZS1zbGljZSxgICtcclxuICAgIGBib3JkZXItaW1hZ2Utd2lkdGgsYm94LWZsZXgsYm94LWZsZXgtZ3JvdXAsYm94LW9yZGluYWwtZ3JvdXAsY29sdW1uLWNvdW50LGAgK1xyXG4gICAgYGNvbHVtbnMsZmxleCxmbGV4LWdyb3csZmxleC1wb3NpdGl2ZSxmbGV4LXNocmluayxmbGV4LW5lZ2F0aXZlLGZsZXgtb3JkZXIsYCArXHJcbiAgICBgZ3JpZC1yb3csZ3JpZC1yb3ctZW5kLGdyaWQtcm93LXNwYW4sZ3JpZC1yb3ctc3RhcnQsZ3JpZC1jb2x1bW4sYCArXHJcbiAgICBgZ3JpZC1jb2x1bW4tZW5kLGdyaWQtY29sdW1uLXNwYW4sZ3JpZC1jb2x1bW4tc3RhcnQsZm9udC13ZWlnaHQsbGluZS1jbGFtcCxgICtcclxuICAgIGBsaW5lLWhlaWdodCxvcGFjaXR5LG9yZGVyLG9ycGhhbnMsdGFiLXNpemUsd2lkb3dzLHotaW5kZXgsem9vbSxgICtcclxuICAgIC8vIFNWR1xyXG4gICAgYGZpbGwtb3BhY2l0eSxmbG9vZC1vcGFjaXR5LHN0b3Atb3BhY2l0eSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LGAgK1xyXG4gICAgYHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aGApO1xyXG4vKipcclxuICogS25vd24gYXR0cmlidXRlcywgdGhpcyBpcyB1c2VkIGZvciBzdHJpbmdpZmljYXRpb24gb2YgcnVudGltZSBzdGF0aWMgbm9kZXNcclxuICogc28gdGhhdCB3ZSBkb24ndCBzdHJpbmdpZnkgYmluZGluZ3MgdGhhdCBjYW5ub3QgYmUgc2V0IGZyb20gSFRNTC5cclxuICogRG9uJ3QgYWxzbyBmb3JnZXQgdG8gYWxsb3cgYGRhdGEtKmAgYW5kIGBhcmlhLSpgIVxyXG4gKiBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0F0dHJpYnV0ZXNcclxuICovXHJcbmNvbnN0IGlzS25vd25BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYCArXHJcbiAgICBgYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLGF1dG9mb2N1cyxhdXRvcGxheSxiYWNrZ3JvdW5kLGJnY29sb3IsYCArXHJcbiAgICBgYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsYCArXHJcbiAgICBgY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGAgK1xyXG4gICAgYGNvb3Jkcyxjcm9zc29yaWdpbixjc3AsZGF0YSxkYXRldGltZSxkZWNvZGluZyxkZWZhdWx0LGRlZmVyLGRpcixkaXJuYW1lLGAgK1xyXG4gICAgYGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxgICtcclxuICAgIGBmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGAgK1xyXG4gICAgYGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsaWNvbixpZCxpbXBvcnRhbmNlLGludGVncml0eSxgICtcclxuICAgIGBpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csYCArXHJcbiAgICBgbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxgICtcclxuICAgIGBvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlcixwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHksYCArXHJcbiAgICBgcmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxgICtcclxuICAgIGBzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsYCArXHJcbiAgICBgc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0cmFuc2xhdGUsdHlwZSx1c2VtYXAsYCArXHJcbiAgICBgdmFsdWUsd2lkdGgsd3JhcGApO1xuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTdHlsZShpc1N0cmluZyhpdGVtKSA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSkgOiBpdGVtKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XHJcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOiguKykvO1xyXG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyUkUpLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcclxuICAgICAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcclxuICAgIGxldCByZXQgPSAnJztcclxuICAgIGlmICghc3R5bGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05vVW5pdE51bWVyaWNTdHlsZVByb3Aobm9ybWFsaXplZEtleSkpKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgcmVuZGVyIHZhbGlkIHZhbHVlc1xyXG4gICAgICAgICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XHJcbiAgICBsZXQgcmVzID0gJyc7XHJcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgcmVzID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgJyAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IG5hbWUgKyAnICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzLnRyaW0oKTtcclxufVxuXG4vLyBUaGVzZSB0YWcgY29uZmlncyBhcmUgc2hhcmVkIGJldHdlZW4gY29tcGlsZXItZG9tIGFuZCBydW50aW1lLWRvbSwgc28gdGhleVxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnRcclxuY29uc3QgSFRNTF9UQUdTID0gJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsJyArXHJcbiAgICAnaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbiwnICtcclxuICAgICdmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSwnICtcclxuICAgICdkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsJyArXHJcbiAgICAndGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSwnICtcclxuICAgICdjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsJyArXHJcbiAgICAndGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLCcgK1xyXG4gICAgJ29wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsJyArXHJcbiAgICAnc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCc7XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50XHJcbmNvbnN0IFNWR19UQUdTID0gJ3N2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSwnICtcclxuICAgICdkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLCcgK1xyXG4gICAgJ2ZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsJyArXHJcbiAgICAnZmVEaXN0YW5jZUxpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsJyArXHJcbiAgICAnZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCwnICtcclxuICAgICdmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLCcgK1xyXG4gICAgJ2ZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzaywnICtcclxuICAgICdtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4sJyArXHJcbiAgICAncG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCwnICtcclxuICAgICd0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXcnO1xyXG5jb25zdCBWT0lEX1RBR1MgPSAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInO1xyXG5jb25zdCBpc0hUTUxUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoSFRNTF9UQUdTKTtcclxuY29uc3QgaXNTVkdUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoU1ZHX1RBR1MpO1xyXG5jb25zdCBpc1ZvaWRUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuY29uc3QgZXNjYXBlUkUgPSAvW1wiJyY8Pl0vO1xyXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xyXG4gICAgY29uc3Qgc3RyID0gJycgKyBzdHJpbmc7XHJcbiAgICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcclxuICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgbGV0IGh0bWwgPSAnJztcclxuICAgIGxldCBlc2NhcGVkO1xyXG4gICAgbGV0IGluZGV4O1xyXG4gICAgbGV0IGxhc3RJbmRleCA9IDA7XHJcbiAgICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMzQ6IC8vIFwiXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZxdW90Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzODogLy8gJlxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmYW1wOyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOTogLy8gJ1xyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmIzM5Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2MDogLy8gPFxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmbHQ7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDYyOiAvLyA+XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZndDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgaHRtbCArPSBlc2NhcGVkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XHJcbn1cclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1Mi9zeW50YXguaHRtbCNjb21tZW50c1xyXG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xyXG5mdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcclxuICAgIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgJycpO1xyXG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XHJcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCBlcXVhbCA9IHRydWU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBlcXVhbCA9IGxvb3NlRXF1YWwoYVtpXSwgYltpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXF1YWw7XHJcbn1cclxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYilcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xyXG4gICAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XHJcbiAgICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XHJcbiAgICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB0aGlzIGlmIHdpbGwgcHJvYmFibHkgbmV2ZXIgYmUgY2FsbGVkICovXHJcbiAgICAgICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xyXG4gICAgICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xyXG4gICAgICAgICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xyXG4gICAgICAgICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xyXG4gICAgICAgICAgICBpZiAoKGFIYXNLZXkgJiYgIWJIYXNLZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAoIWFIYXNLZXkgJiYgYkhhc0tleSkgfHxcclxuICAgICAgICAgICAgICAgICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xyXG59XHJcbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xyXG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoaXRlbSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xyXG59XG5cbi8qKlxyXG4gKiBGb3IgY29udmVydGluZyB7eyBpbnRlcnBvbGF0aW9uIH19IHZhbHVlcyB0byBkaXNwbGF5ZWQgc3RyaW5ncy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcclxuICAgIHJldHVybiB2YWwgPT0gbnVsbFxyXG4gICAgICAgID8gJydcclxuICAgICAgICA6IGlzT2JqZWN0KHZhbClcclxuICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKVxyXG4gICAgICAgICAgICA6IFN0cmluZyh2YWwpO1xyXG59O1xyXG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcclxuICAgIGlmIChpc01hcCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoKGVudHJpZXMsIFtrZXksIHZhbF0pID0+IHtcclxuICAgICAgICAgICAgICAgIGVudHJpZXNbYCR7a2V5fSA9PmBdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XHJcbiAgICAgICAgICAgIH0sIHt9KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxufTtcblxuLyoqXHJcbiAqIExpc3Qgb2YgQGJhYmVsL3BhcnNlciBwbHVnaW5zIHRoYXQgYXJlIHVzZWQgZm9yIHRlbXBsYXRlIGV4cHJlc3Npb25cclxuICogdHJhbnNmb3JtcyBhbmQgU0ZDIHNjcmlwdCB0cmFuc2Zvcm1zLiBCeSBkZWZhdWx0IHdlIGVuYWJsZSBwcm9wb3NhbHMgc2xhdGVkXHJcbiAqIGZvciBFUzIwMjAuIFRoaXMgd2lsbCBuZWVkIHRvIGJlIHVwZGF0ZWQgYXMgdGhlIHNwZWMgbW92ZXMgZm9yd2FyZC5cclxuICogRnVsbCBsaXN0IGF0IGh0dHBzOi8vYmFiZWxqcy5pby9kb2NzL2VuL25leHQvYmFiZWwtcGFyc2VyI3BsdWdpbnNcclxuICovXHJcbmNvbnN0IGJhYmVsUGFyc2VyRGVmYXVsdFBsdWdpbnMgPSBbXHJcbiAgICAnYmlnSW50JyxcclxuICAgICdvcHRpb25hbENoYWluaW5nJyxcclxuICAgICdudWxsaXNoQ29hbGVzY2luZ09wZXJhdG9yJ1xyXG5dO1xyXG5jb25zdCBFTVBUWV9PQkogPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcclxuICAgIDoge307XHJcbmNvbnN0IEVNUFRZX0FSUiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XHJcbmNvbnN0IE5PT1AgPSAoKSA9PiB7IH07XHJcbi8qKlxyXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxyXG4gKi9cclxuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcclxuY29uc3Qgb25SRSA9IC9eb25bXmEtel0vO1xyXG5jb25zdCBpc09uID0gKGtleSkgPT4gb25SRS50ZXN0KGtleSk7XHJcbmNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKCdvblVwZGF0ZTonKTtcclxuY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcclxuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcclxuICAgIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XHJcbiAgICBpZiAoaSA+IC0xKSB7XHJcbiAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xyXG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcclxuY29uc3QgaXNNYXAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgTWFwXSc7XHJcbmNvbnN0IGlzU2V0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IFNldF0nO1xyXG5jb25zdCBpc0RhdGUgPSAodmFsKSA9PiB2YWwgaW5zdGFuY2VvZiBEYXRlO1xyXG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcclxuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcclxuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3ltYm9sJztcclxuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XHJcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcclxuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnRoZW4pICYmIGlzRnVuY3Rpb24odmFsLmNhdGNoKTtcclxufTtcclxuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5jb25zdCB0b1R5cGVTdHJpbmcgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xyXG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcclxuICAgIC8vIGV4dHJhY3QgXCJSYXdUeXBlXCIgZnJvbSBzdHJpbmdzIGxpa2UgXCJbb2JqZWN0IFJhd1R5cGVdXCJcclxuICAgIHJldHVybiB0b1R5cGVTdHJpbmcodmFsdWUpLnNsaWNlKDgsIC0xKTtcclxufTtcclxuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcclxuY29uc3QgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJlxyXG4gICAga2V5ICE9PSAnTmFOJyAmJlxyXG4gICAga2V5WzBdICE9PSAnLScgJiZcclxuICAgICcnICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcclxuY29uc3QgaXNSZXNlcnZlZFByb3AgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoXHJcbi8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcclxuJyxrZXkscmVmLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCwnICtcclxuICAgICdvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWQnKTtcclxuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xyXG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgcmV0dXJuICgoc3RyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcclxuICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKSk7XHJcbn0pO1xyXG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCkpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiAoc3RyID8gYG9uJHtjYXBpdGFsaXplKHN0cil9YCA6IGBgKSk7XHJcbi8vIGNvbXBhcmUgd2hldGhlciBhIHZhbHVlIGhhcyBjaGFuZ2VkLCBhY2NvdW50aW5nIGZvciBOYU4uXHJcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiB2YWx1ZSAhPT0gb2xkVmFsdWUgJiYgKHZhbHVlID09PSB2YWx1ZSB8fCBvbGRWYWx1ZSA9PT0gb2xkVmFsdWUpO1xyXG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIGFyZykgPT4ge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBmbnNbaV0oYXJnKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHZhbHVlXHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XHJcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcclxufTtcclxubGV0IF9nbG9iYWxUaGlzO1xyXG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIChfZ2xvYmFsVGhpcyB8fFxyXG4gICAgICAgIChfZ2xvYmFsVGhpcyA9XHJcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzXHJcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZlxyXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB3aW5kb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnbG9iYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30pKTtcclxufTtcblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgYmFiZWxQYXJzZXJEZWZhdWx0UGx1Z2lucywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIGlzSFRNTFRhZywgaXNJbnRlZ2VyS2V5LCBpc0tub3duQXR0ciwgaXNNYXAsIGlzTW9kZWxMaXN0ZW5lciwgaXNOb1VuaXROdW1lcmljU3R5bGVQcm9wLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XG4iLCI8dGVtcGxhdGU+XHJcbiAgPGgxPkludGVyY2F0aXZlIFdwIFZ1ZSBQbG90bHkgQ2hhcnRzPC9oMT5cclxuXHJcbiAgPGRpdj5cclxuICAgIHt7IGNoYXJ0cyB9fVxyXG4gICAge3sgc2hlZXRzIH19XHJcbiAgPC9kaXY+XHJcblxyXG4gIDxkaXYgaWQ9XCJuYXZcIj5cclxuICAgICAgPHJvdXRlci1saW5rIHRvPVwiL3dwLWFkbWluL2FkbWluLnBocD9wYWdlPXlybF93cF92dWVfcGxvdGx5X2NoYXJ0c1wiPkNoYXJ0IExpYnJhcnk8L3JvdXRlci1saW5rPlxyXG4gICAgICA8cm91dGVyLWxpbmsgdG89XCIvc2V0dGluZ3NcIj5TZXR0aW5nczwvcm91dGVyLWxpbms+XHJcbiAgICAgIDxyb3V0ZXItbGluayB0bz1cIi9zdXBwb3J0XCI+U3VwcG9ydDwvcm91dGVyLWxpbms+XHJcbiAgPC9kaXY+XHJcbiAgPHJvdXRlci12aWV3IC8+XHJcblxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuICBcclxuaW1wb3J0IHsgcmVmLCBvbk1vdW50ZWQgfSBmcm9tICd2dWUnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgc2V0dXAgKCkge1xyXG4gICAgXHJcbiAgICBsZXQgcGF5bG9hZCA9IHJlZihbXSlcclxuXHJcbiAgICBjb25zdCBjaGFydHMgPSByZWYoeXJsX3dwX3Z1ZV9wbG90bHlfY2hhcnRzX29iai5jaGFydHMpXHJcbiAgICBjb25zdCBzaGVldHMgPSByZWYoeXJsX3dwX3Z1ZV9wbG90bHlfY2hhcnRzX29iai5zaGVldHMpXHJcblxyXG4gICAgY29uc29sZS5sb2coeXJsX3dwX3Z1ZV9wbG90bHlfY2hhcnRzX29iailcclxuICAgIC8vIG9uTW91bnRlZChhc3luYyAoKSA9PiB7XHJcbiAgICAvLyAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goIGAke3lybF93cF92dWVfcGxvdGx5X2NoYXJ0c19vYmoud3BSZXN0VXJsfSR7eXJsX3dwX3Z1ZV9wbG90bHlfY2hhcnRzX29iai5wbHVnaW59L3YxL2NoYXJ0c2AsIHtcclxuICAgIC8vICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgLy8gICAgIC8vIGJvZHk6IGJvZHksXHJcbiAgICAvLyAgICAgaGVhZGVyczogeydYLVdQLU5vbmNlJzogeXJsX3dwX3Z1ZV9wbG90bHlfY2hhcnRzX29iai53cFJlc3ROb25jZSB9XHJcbiAgICAvLyAgIH0gKVxyXG4gICAgLy8gICBwYXlsb2FkLnZhbHVlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXHJcbiAgICAvLyAgIGNvbnNvbGUubG9nKHBheWxvYWQudmFsdWUpXHJcbiAgICAvLyB9KVxyXG4gIFxyXG4gICAgcmV0dXJuIHsgY2hhcnRzLCBzaGVldHMgfVxyXG4gIH1cclxufVxyXG5cclxuXHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIGxhbmc9XCJzY3NzXCIgc2NvcGVkPlxyXG5cclxuPC9zdHlsZT5cclxuXHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8aDE+Q2hhcnQgTGlicmFyeTwvaDE+XHJcbjwvdGVtcGxhdGU+IiwiPHRlbXBsYXRlPlxyXG4gIDxoMT5TZXR0aW5ncyBQYWdlPC9oMT5cclxuPC90ZW1wbGF0ZT4iLCI8dGVtcGxhdGU+XHJcbiAgPGgxPiBTdXBwb3J0IFBhZ2U8L2gxPlxyXG48L3RlbXBsYXRlPiIsImltcG9ydCB7IGNyZWF0ZVdlYkhpc3RvcnksIGNyZWF0ZVJvdXRlciB9IGZyb20gXCJ2dWUtcm91dGVyXCI7XHJcbmltcG9ydCBDaGFydExpYnJhcnkgZnJvbSBcIi4uL3ZpZXdzL0NoYXJ0TGlicmFyeS52dWVcIjtcclxuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuLi92aWV3cy9TZXR0aW5ncy52dWVcIjtcclxuaW1wb3J0IFN1cHBvcnQgZnJvbSBcIi4uL3ZpZXdzL1N1cHBvcnQudnVlXCI7XHJcblxyXG5jb25zdCByb3V0ZXMgPSBbXHJcbiAge1xyXG4gICAgcGF0aDogXCIvd3AtYWRtaW4vYWRtaW4ucGhwP3BhZ2U9eXJsX3dwX3Z1ZV9wbG90bHlfY2hhcnRzXCIsXHJcbiAgICBuYW1lOiBcIkNoYXJ0IExpYnJhcnlcIixcclxuICAgIGNvbXBvbmVudDogQ2hhcnRMaWJyYXJ5LFxyXG4gICAgcmVkaXJlY3Q6ICcvJ1xyXG4gIH0sXHJcbiAge1xyXG4gICAgcGF0aDogXCIvc2V0dGluZ3NcIixcclxuICAgIG5hbWU6IFwiU2V0dGluZ3NcIixcclxuICAgIGNvbXBvbmVudDogU2V0dGluZ3NcclxuICB9LFxyXG4gIHtcclxuICAgIHBhdGg6IFwiL3N1cHBvcnRcIixcclxuICAgIG5hbWU6IFwiU3VwcG9ydFwiLFxyXG4gICAgY29tcG9uZW50OiBTdXBwb3J0XHJcbiAgfSxcclxuXTtcclxuXHJcbmNvbnN0IHJvdXRlciA9IGNyZWF0ZVJvdXRlcih7XHJcbiAgaGlzdG9yeTogY3JlYXRlV2ViSGlzdG9yeSgpLFxyXG4gIHJvdXRlcyxcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCByb3V0ZXI7IiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vQWRtaW5BcHAudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTcxM2EzNjFlJnNjb3BlZD10cnVlXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQWRtaW5BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL0FkbWluQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5zY3JpcHQucmVuZGVyID0gcmVuZGVyXG5zY3JpcHQuX19zY29wZUlkID0gXCJkYXRhLXYtNzEzYTM2MWVcIlxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgc2NyaXB0Ll9faG1ySWQgPSBcIjcxM2EzNjFlXCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnNzEzYTM2MWUnLCBzY3JpcHQpKSB7XG4gICAgYXBpLnJlbG9hZCgnNzEzYTM2MWUnLCBzY3JpcHQpXG4gIH1cbiAgXG4gIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9BZG1pbkFwcC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NzEzYTM2MWUmc2NvcGVkPXRydWVcIiwgKCkgPT4ge1xuICAgIGFwaS5yZXJlbmRlcignNzEzYTM2MWUnLCByZW5kZXIpXG4gIH0pXG5cbn1cblxuc2NyaXB0Ll9fZmlsZSA9IFwic3JjL2pzL2NvbXBvbmVudHMvQWRtaW5BcHAudnVlXCJcblxuZXhwb3J0IGRlZmF1bHQgc2NyaXB0IiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vQ2hhcnRMaWJyYXJ5LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wZDU2MTliN1wiXG5jb25zdCBzY3JpcHQgPSB7fVxuc2NyaXB0LnJlbmRlciA9IHJlbmRlclxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgc2NyaXB0Ll9faG1ySWQgPSBcIjBkNTYxOWI3XCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnMGQ1NjE5YjcnLCBzY3JpcHQpKSB7XG4gICAgYXBpLnJlbG9hZCgnMGQ1NjE5YjcnLCBzY3JpcHQpXG4gIH1cbiAgXG4gIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9DaGFydExpYnJhcnkudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTBkNTYxOWI3XCIsICgpID0+IHtcbiAgICBhcGkucmVyZW5kZXIoJzBkNTYxOWI3JywgcmVuZGVyKVxuICB9KVxuXG59XG5cbnNjcmlwdC5fX2ZpbGUgPSBcInNyYy92aWV3cy9DaGFydExpYnJhcnkudnVlXCJcblxuZXhwb3J0IGRlZmF1bHQgc2NyaXB0IiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vU2V0dGluZ3MudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTUzY2M4NGRkXCJcbmNvbnN0IHNjcmlwdCA9IHt9XG5zY3JpcHQucmVuZGVyID0gcmVuZGVyXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICBzY3JpcHQuX19obXJJZCA9IFwiNTNjYzg0ZGRcIlxuICBjb25zdCBhcGkgPSBfX1ZVRV9ITVJfUlVOVElNRV9fXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFhcGkuY3JlYXRlUmVjb3JkKCc1M2NjODRkZCcsIHNjcmlwdCkpIHtcbiAgICBhcGkucmVsb2FkKCc1M2NjODRkZCcsIHNjcmlwdClcbiAgfVxuICBcbiAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL1NldHRpbmdzLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01M2NjODRkZFwiLCAoKSA9PiB7XG4gICAgYXBpLnJlcmVuZGVyKCc1M2NjODRkZCcsIHJlbmRlcilcbiAgfSlcblxufVxuXG5zY3JpcHQuX19maWxlID0gXCJzcmMvdmlld3MvU2V0dGluZ3MudnVlXCJcblxuZXhwb3J0IGRlZmF1bHQgc2NyaXB0IiwiaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSBcIi4vU3VwcG9ydC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MWZhNzU3MDVcIlxuY29uc3Qgc2NyaXB0ID0ge31cbnNjcmlwdC5yZW5kZXIgPSByZW5kZXJcbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHNjcmlwdC5fX2htcklkID0gXCIxZmE3NTcwNVwiXG4gIGNvbnN0IGFwaSA9IF9fVlVFX0hNUl9SVU5USU1FX19cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIWFwaS5jcmVhdGVSZWNvcmQoJzFmYTc1NzA1Jywgc2NyaXB0KSkge1xuICAgIGFwaS5yZWxvYWQoJzFmYTc1NzA1Jywgc2NyaXB0KVxuICB9XG4gIFxuICBtb2R1bGUuaG90LmFjY2VwdChcIi4vU3VwcG9ydC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MWZhNzU3MDVcIiwgKCkgPT4ge1xuICAgIGFwaS5yZXJlbmRlcignMWZhNzU3MDUnLCByZW5kZXIpXG4gIH0pXG5cbn1cblxuc2NyaXB0Ll9fZmlsZSA9IFwic3JjL3ZpZXdzL1N1cHBvcnQudnVlXCJcblxuZXhwb3J0IGRlZmF1bHQgc2NyaXB0IiwiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTMudXNlIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0udXNlWzBdIS4vQWRtaW5BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTMudXNlIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbOF0udXNlWzBdIS4vQWRtaW5BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiLCIvKiFcbiAgKiB2dWUtcm91dGVyIHY0LjAuMTBcbiAgKiAoYykgMjAyMSBFZHVhcmRvIFNhbiBNYXJ0aW4gTW9yb3RlXG4gICogQGxpY2Vuc2UgTUlUXG4gICovXG5pbXBvcnQgeyBnZXRDdXJyZW50SW5zdGFuY2UsIGluamVjdCwgb25Vbm1vdW50ZWQsIG9uRGVhY3RpdmF0ZWQsIG9uQWN0aXZhdGVkLCBjb21wdXRlZCwgdW5yZWYsIHdhdGNoRWZmZWN0LCBkZWZpbmVDb21wb25lbnQsIHJlYWN0aXZlLCBoLCBwcm92aWRlLCByZWYsIHdhdGNoLCBzaGFsbG93UmVmLCBuZXh0VGljayB9IGZyb20gJ3Z1ZSc7XG5pbXBvcnQgeyBzZXR1cERldnRvb2xzUGx1Z2luIH0gZnJvbSAnQHZ1ZS9kZXZ0b29scy1hcGknO1xuXG5jb25zdCBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xyXG5jb25zdCBQb2x5U3ltYm9sID0gKG5hbWUpID0+IFxyXG4vLyB2ciA9IHZ1ZSByb3V0ZXJcclxuaGFzU3ltYm9sXHJcbiAgICA/IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnW3Z1ZS1yb3V0ZXJdOiAnICsgbmFtZSA6IG5hbWUpXHJcbiAgICA6ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnW3Z1ZS1yb3V0ZXJdOiAnIDogJ192cl8nKSArIG5hbWU7XHJcbi8vIHJ2bG0gPSBSb3V0ZXIgVmlldyBMb2NhdGlvbiBNYXRjaGVkXHJcbi8qKlxyXG4gKiBSb3V0ZVJlY29yZCBiZWluZyByZW5kZXJlZCBieSB0aGUgY2xvc2VzdCBhbmNlc3RvciBSb3V0ZXIgVmlldy4gVXNlZCBmb3JcclxuICogYG9uQmVmb3JlUm91dGVVcGRhdGVgIGFuZCBgb25CZWZvcmVSb3V0ZUxlYXZlYC4gcnZsbSBzdGFuZHMgZm9yIFJvdXRlciBWaWV3XHJcbiAqIExvY2F0aW9uIE1hdGNoZWRcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBtYXRjaGVkUm91dGVLZXkgPSAvKiNfX1BVUkVfXyovIFBvbHlTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ3JvdXRlciB2aWV3IGxvY2F0aW9uIG1hdGNoZWQnIDogJ3J2bG0nKTtcclxuLyoqXHJcbiAqIEFsbG93cyBvdmVycmlkaW5nIHRoZSByb3V0ZXIgdmlldyBkZXB0aCB0byBjb250cm9sIHdoaWNoIGNvbXBvbmVudCBpblxyXG4gKiBgbWF0Y2hlZGAgaXMgcmVuZGVyZWQuIHJ2ZCBzdGFuZHMgZm9yIFJvdXRlciBWaWV3IERlcHRoXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3Qgdmlld0RlcHRoS2V5ID0gLyojX19QVVJFX18qLyBQb2x5U3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdyb3V0ZXIgdmlldyBkZXB0aCcgOiAncnZkJyk7XHJcbi8qKlxyXG4gKiBBbGxvd3Mgb3ZlcnJpZGluZyB0aGUgcm91dGVyIGluc3RhbmNlIHJldHVybmVkIGJ5IGB1c2VSb3V0ZXJgIGluIHRlc3RzLiByXHJcbiAqIHN0YW5kcyBmb3Igcm91dGVyXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3Qgcm91dGVyS2V5ID0gLyojX19QVVJFX18qLyBQb2x5U3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdyb3V0ZXInIDogJ3InKTtcclxuLyoqXHJcbiAqIEFsbG93cyBvdmVycmlkaW5nIHRoZSBjdXJyZW50IHJvdXRlIHJldHVybmVkIGJ5IGB1c2VSb3V0ZWAgaW4gdGVzdHMuIHJsXHJcbiAqIHN0YW5kcyBmb3Igcm91dGUgbG9jYXRpb25cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCByb3V0ZUxvY2F0aW9uS2V5ID0gLyojX19QVVJFX18qLyBQb2x5U3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdyb3V0ZSBsb2NhdGlvbicgOiAncmwnKTtcclxuLyoqXHJcbiAqIEFsbG93cyBvdmVycmlkaW5nIHRoZSBjdXJyZW50IHJvdXRlIHVzZWQgYnkgcm91dGVyLXZpZXcuIEludGVybmFsbHkgdGhpcyBpc1xyXG4gKiB1c2VkIHdoZW4gdGhlIGByb3V0ZWAgcHJvcCBpcyBwYXNzZWQuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3Qgcm91dGVyVmlld0xvY2F0aW9uS2V5ID0gLyojX19QVVJFX18qLyBQb2x5U3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdyb3V0ZXIgdmlldyBsb2NhdGlvbicgOiAncnZsJyk7XG5cbmNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG5mdW5jdGlvbiBpc0VTTW9kdWxlKG9iaikge1xyXG4gICAgcmV0dXJuIG9iai5fX2VzTW9kdWxlIHx8IChoYXNTeW1ib2wgJiYgb2JqW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKTtcclxufVxyXG5jb25zdCBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xyXG5mdW5jdGlvbiBhcHBseVRvUGFyYW1zKGZuLCBwYXJhbXMpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcclxuICAgICAgICBuZXdQYXJhbXNba2V5XSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKGZuKSA6IGZuKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxubGV0IG5vb3AgPSAoKSA9PiB7IH07XG5cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XHJcbiAgICAvLyBhdm9pZCB1c2luZyAuLi5hcmdzIGFzIGl0IGJyZWFrcyBpbiBvbGRlciBFZGdlIGJ1aWxkc1xyXG4gICAgY29uc3QgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKS5zbGljZSgxKTtcclxuICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBbJ1tWdWUgUm91dGVyIHdhcm5dOiAnICsgbXNnXS5jb25jYXQoYXJncykpO1xyXG59XG5cbmNvbnN0IFRSQUlMSU5HX1NMQVNIX1JFID0gL1xcLyQvO1xyXG5jb25zdCByZW1vdmVUcmFpbGluZ1NsYXNoID0gKHBhdGgpID0+IHBhdGgucmVwbGFjZShUUkFJTElOR19TTEFTSF9SRSwgJycpO1xyXG4vKipcclxuICogVHJhbnNmb3JtcyBhbiBVUkkgaW50byBhIG5vcm1hbGl6ZWQgaGlzdG9yeSBsb2NhdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0gcGFyc2VRdWVyeVxyXG4gKiBAcGFyYW0gbG9jYXRpb24gLSBVUkkgdG8gbm9ybWFsaXplXHJcbiAqIEBwYXJhbSBjdXJyZW50TG9jYXRpb24gLSBjdXJyZW50IGFic29sdXRlIGxvY2F0aW9uLiBBbGxvd3MgcmVzb2x2aW5nIHJlbGF0aXZlXHJcbiAqIHBhdGhzLiBNdXN0IHN0YXJ0IHdpdGggYC9gLiBEZWZhdWx0cyB0byBgL2BcclxuICogQHJldHVybnMgYSBub3JtYWxpemVkIGhpc3RvcnkgbG9jYXRpb25cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlVVJMKHBhcnNlUXVlcnksIGxvY2F0aW9uLCBjdXJyZW50TG9jYXRpb24gPSAnLycpIHtcclxuICAgIGxldCBwYXRoLCBxdWVyeSA9IHt9LCBzZWFyY2hTdHJpbmcgPSAnJywgaGFzaCA9ICcnO1xyXG4gICAgLy8gQ291bGQgdXNlIFVSTCBhbmQgVVJMU2VhcmNoUGFyYW1zIGJ1dCBJRSAxMSBkb2Vzbid0IHN1cHBvcnQgaXRcclxuICAgIGNvbnN0IHNlYXJjaFBvcyA9IGxvY2F0aW9uLmluZGV4T2YoJz8nKTtcclxuICAgIGNvbnN0IGhhc2hQb3MgPSBsb2NhdGlvbi5pbmRleE9mKCcjJywgc2VhcmNoUG9zID4gLTEgPyBzZWFyY2hQb3MgOiAwKTtcclxuICAgIGlmIChzZWFyY2hQb3MgPiAtMSkge1xyXG4gICAgICAgIHBhdGggPSBsb2NhdGlvbi5zbGljZSgwLCBzZWFyY2hQb3MpO1xyXG4gICAgICAgIHNlYXJjaFN0cmluZyA9IGxvY2F0aW9uLnNsaWNlKHNlYXJjaFBvcyArIDEsIGhhc2hQb3MgPiAtMSA/IGhhc2hQb3MgOiBsb2NhdGlvbi5sZW5ndGgpO1xyXG4gICAgICAgIHF1ZXJ5ID0gcGFyc2VRdWVyeShzZWFyY2hTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgaWYgKGhhc2hQb3MgPiAtMSkge1xyXG4gICAgICAgIHBhdGggPSBwYXRoIHx8IGxvY2F0aW9uLnNsaWNlKDAsIGhhc2hQb3MpO1xyXG4gICAgICAgIC8vIGtlZXAgdGhlICMgY2hhcmFjdGVyXHJcbiAgICAgICAgaGFzaCA9IGxvY2F0aW9uLnNsaWNlKGhhc2hQb3MsIGxvY2F0aW9uLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICAvLyBubyBzZWFyY2ggYW5kIG5vIHF1ZXJ5XHJcbiAgICBwYXRoID0gcmVzb2x2ZVJlbGF0aXZlUGF0aChwYXRoICE9IG51bGwgPyBwYXRoIDogbG9jYXRpb24sIGN1cnJlbnRMb2NhdGlvbik7XHJcbiAgICAvLyBlbXB0eSBwYXRoIG1lYW5zIGEgcmVsYXRpdmUgcXVlcnkgb3IgaGFzaCBgP2Zvbz1mYCwgYCN0aGluZ2BcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZnVsbFBhdGg6IHBhdGggKyAoc2VhcmNoU3RyaW5nICYmICc/JykgKyBzZWFyY2hTdHJpbmcgKyBoYXNoLFxyXG4gICAgICAgIHBhdGgsXHJcbiAgICAgICAgcXVlcnksXHJcbiAgICAgICAgaGFzaCxcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFN0cmluZ2lmaWVzIGEgVVJMIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0gc3RyaW5naWZ5UXVlcnlcclxuICogQHBhcmFtIGxvY2F0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpbmdpZnlVUkwoc3RyaW5naWZ5UXVlcnksIGxvY2F0aW9uKSB7XHJcbiAgICBsZXQgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeSA/IHN0cmluZ2lmeVF1ZXJ5KGxvY2F0aW9uLnF1ZXJ5KSA6ICcnO1xyXG4gICAgcmV0dXJuIGxvY2F0aW9uLnBhdGggKyAocXVlcnkgJiYgJz8nKSArIHF1ZXJ5ICsgKGxvY2F0aW9uLmhhc2ggfHwgJycpO1xyXG59XHJcbi8qKlxyXG4gKiBTdHJpcHMgb2ZmIHRoZSBiYXNlIGZyb20gdGhlIGJlZ2lubmluZyBvZiBhIGxvY2F0aW9uLnBhdGhuYW1lIGluIGEgbm9uXHJcbiAqIGNhc2Utc2Vuc2l0aXZlIHdheS5cclxuICpcclxuICogQHBhcmFtIHBhdGhuYW1lIC0gbG9jYXRpb24ucGF0aG5hbWVcclxuICogQHBhcmFtIGJhc2UgLSBiYXNlIHRvIHN0cmlwIG9mZlxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaXBCYXNlKHBhdGhuYW1lLCBiYXNlKSB7XHJcbiAgICAvLyBubyBiYXNlIG9yIGJhc2UgaXMgbm90IGZvdW5kIGF0IHRoZSBiZWdpbm5pbmdcclxuICAgIGlmICghYmFzZSB8fCAhcGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGJhc2UudG9Mb3dlckNhc2UoKSkpXHJcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lO1xyXG4gICAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKGJhc2UubGVuZ3RoKSB8fCAnLyc7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0d28gUm91dGVMb2NhdGlvbiBhcmUgZXF1YWwuIFRoaXMgbWVhbnMgdGhhdCBib3RoIGxvY2F0aW9ucyBhcmVcclxuICogcG9pbnRpbmcgdG93YXJkcyB0aGUgc2FtZSB7QGxpbmsgUm91dGVSZWNvcmR9IGFuZCB0aGF0IGFsbCBgcGFyYW1zYCwgYHF1ZXJ5YFxyXG4gKiBwYXJhbWV0ZXJzIGFuZCBgaGFzaGAgYXJlIHRoZSBzYW1lXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gZmlyc3Qge0BsaW5rIFJvdXRlTG9jYXRpb259XHJcbiAqIEBwYXJhbSBiIC0gc2Vjb25kIHtAbGluayBSb3V0ZUxvY2F0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNTYW1lUm91dGVMb2NhdGlvbihzdHJpbmdpZnlRdWVyeSwgYSwgYikge1xyXG4gICAgbGV0IGFMYXN0SW5kZXggPSBhLm1hdGNoZWQubGVuZ3RoIC0gMTtcclxuICAgIGxldCBiTGFzdEluZGV4ID0gYi5tYXRjaGVkLmxlbmd0aCAtIDE7XHJcbiAgICByZXR1cm4gKGFMYXN0SW5kZXggPiAtMSAmJlxyXG4gICAgICAgIGFMYXN0SW5kZXggPT09IGJMYXN0SW5kZXggJiZcclxuICAgICAgICBpc1NhbWVSb3V0ZVJlY29yZChhLm1hdGNoZWRbYUxhc3RJbmRleF0sIGIubWF0Y2hlZFtiTGFzdEluZGV4XSkgJiZcclxuICAgICAgICBpc1NhbWVSb3V0ZUxvY2F0aW9uUGFyYW1zKGEucGFyYW1zLCBiLnBhcmFtcykgJiZcclxuICAgICAgICBzdHJpbmdpZnlRdWVyeShhLnF1ZXJ5KSA9PT0gc3RyaW5naWZ5UXVlcnkoYi5xdWVyeSkgJiZcclxuICAgICAgICBhLmhhc2ggPT09IGIuaGFzaCk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byBgUm91dGVSZWNvcmRzYCBhcmUgZXF1YWwuIFRha2VzIGludG8gYWNjb3VudCBhbGlhc2VzOiB0aGV5IGFyZVxyXG4gKiBjb25zaWRlcmVkIGVxdWFsIHRvIHRoZSBgUm91dGVSZWNvcmRgIHRoZXkgYXJlIGFsaWFzaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSAtIGZpcnN0IHtAbGluayBSb3V0ZVJlY29yZH1cclxuICogQHBhcmFtIGIgLSBzZWNvbmQge0BsaW5rIFJvdXRlUmVjb3JkfVxyXG4gKi9cclxuZnVuY3Rpb24gaXNTYW1lUm91dGVSZWNvcmQoYSwgYikge1xyXG4gICAgLy8gc2luY2UgdGhlIG9yaWdpbmFsIHJlY29yZCBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGZvciBhbGlhc09mXHJcbiAgICAvLyBidXQgYWxsIGFsaWFzZXMgcG9pbnQgdG8gdGhlIG9yaWdpbmFsIHJlY29yZCwgdGhpcyB3aWxsIGFsd2F5cyBjb21wYXJlXHJcbiAgICAvLyB0aGUgb3JpZ2luYWwgcmVjb3JkXHJcbiAgICByZXR1cm4gKGEuYWxpYXNPZiB8fCBhKSA9PT0gKGIuYWxpYXNPZiB8fCBiKTtcclxufVxyXG5mdW5jdGlvbiBpc1NhbWVSb3V0ZUxvY2F0aW9uUGFyYW1zKGEsIGIpIHtcclxuICAgIGlmIChPYmplY3Qua2V5cyhhKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBmb3IgKGxldCBrZXkgaW4gYSkge1xyXG4gICAgICAgIGlmICghaXNTYW1lUm91dGVMb2NhdGlvblBhcmFtc1ZhbHVlKGFba2V5XSwgYltrZXldKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lUm91dGVMb2NhdGlvblBhcmFtc1ZhbHVlKGEsIGIpIHtcclxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGEpXHJcbiAgICAgICAgPyBpc0VxdWl2YWxlbnRBcnJheShhLCBiKVxyXG4gICAgICAgIDogQXJyYXkuaXNBcnJheShiKVxyXG4gICAgICAgICAgICA/IGlzRXF1aXZhbGVudEFycmF5KGIsIGEpXHJcbiAgICAgICAgICAgIDogYSA9PT0gYjtcclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgdHdvIGFycmF5cyBhcmUgdGhlIHNhbWUgb3IgaWYgYW4gYXJyYXkgd2l0aCBvbmUgc2luZ2xlIGVudHJ5IGlzIHRoZVxyXG4gKiBzYW1lIGFzIGFub3RoZXIgcHJpbWl0aXZlIHZhbHVlLiBVc2VkIHRvIGNoZWNrIHF1ZXJ5IGFuZCBwYXJhbWV0ZXJzXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gYXJyYXkgb2YgdmFsdWVzXHJcbiAqIEBwYXJhbSBiIC0gYXJyYXkgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0VxdWl2YWxlbnRBcnJheShhLCBiKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShiKVxyXG4gICAgICAgID8gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoKHZhbHVlLCBpKSA9PiB2YWx1ZSA9PT0gYltpXSlcclxuICAgICAgICA6IGEubGVuZ3RoID09PSAxICYmIGFbMF0gPT09IGI7XHJcbn1cclxuLyoqXHJcbiAqIFJlc29sdmVzIGEgcmVsYXRpdmUgcGF0aCB0aGF0IHN0YXJ0cyB3aXRoIGAuYC5cclxuICpcclxuICogQHBhcmFtIHRvIC0gcGF0aCBsb2NhdGlvbiB3ZSBhcmUgcmVzb2x2aW5nXHJcbiAqIEBwYXJhbSBmcm9tIC0gY3VycmVudExvY2F0aW9uLnBhdGgsIHNob3VsZCBzdGFydCB3aXRoIGAvYFxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZVJlbGF0aXZlUGF0aCh0bywgZnJvbSkge1xyXG4gICAgaWYgKHRvLnN0YXJ0c1dpdGgoJy8nKSlcclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFmcm9tLnN0YXJ0c1dpdGgoJy8nKSkge1xyXG4gICAgICAgIHdhcm4oYENhbm5vdCByZXNvbHZlIGEgcmVsYXRpdmUgbG9jYXRpb24gd2l0aG91dCBhbiBhYnNvbHV0ZSBwYXRoLiBUcnlpbmcgdG8gcmVzb2x2ZSBcIiR7dG99XCIgZnJvbSBcIiR7ZnJvbX1cIi4gSXQgc2hvdWxkIGxvb2sgbGlrZSBcIi8ke2Zyb219XCIuYCk7XHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0bylcclxuICAgICAgICByZXR1cm4gZnJvbTtcclxuICAgIGNvbnN0IGZyb21TZWdtZW50cyA9IGZyb20uc3BsaXQoJy8nKTtcclxuICAgIGNvbnN0IHRvU2VnbWVudHMgPSB0by5zcGxpdCgnLycpO1xyXG4gICAgbGV0IHBvc2l0aW9uID0gZnJvbVNlZ21lbnRzLmxlbmd0aCAtIDE7XHJcbiAgICBsZXQgdG9Qb3NpdGlvbjtcclxuICAgIGxldCBzZWdtZW50O1xyXG4gICAgZm9yICh0b1Bvc2l0aW9uID0gMDsgdG9Qb3NpdGlvbiA8IHRvU2VnbWVudHMubGVuZ3RoOyB0b1Bvc2l0aW9uKyspIHtcclxuICAgICAgICBzZWdtZW50ID0gdG9TZWdtZW50c1t0b1Bvc2l0aW9uXTtcclxuICAgICAgICAvLyBjYW4ndCBnbyBiZWxvdyB6ZXJvXHJcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAxIHx8IHNlZ21lbnQgPT09ICcuJylcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKHNlZ21lbnQgPT09ICcuLicpXHJcbiAgICAgICAgICAgIHBvc2l0aW9uLS07XHJcbiAgICAgICAgLy8gZm91bmQgc29tZXRoaW5nIHRoYXQgaXMgbm90IHJlbGF0aXZlIHBhdGhcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChmcm9tU2VnbWVudHMuc2xpY2UoMCwgcG9zaXRpb24pLmpvaW4oJy8nKSArXHJcbiAgICAgICAgJy8nICtcclxuICAgICAgICB0b1NlZ21lbnRzXHJcbiAgICAgICAgICAgIC5zbGljZSh0b1Bvc2l0aW9uIC0gKHRvUG9zaXRpb24gPT09IHRvU2VnbWVudHMubGVuZ3RoID8gMSA6IDApKVxyXG4gICAgICAgICAgICAuam9pbignLycpKTtcclxufVxuXG52YXIgTmF2aWdhdGlvblR5cGU7XHJcbihmdW5jdGlvbiAoTmF2aWdhdGlvblR5cGUpIHtcclxuICAgIE5hdmlnYXRpb25UeXBlW1wicG9wXCJdID0gXCJwb3BcIjtcclxuICAgIE5hdmlnYXRpb25UeXBlW1wicHVzaFwiXSA9IFwicHVzaFwiO1xyXG59KShOYXZpZ2F0aW9uVHlwZSB8fCAoTmF2aWdhdGlvblR5cGUgPSB7fSkpO1xyXG52YXIgTmF2aWdhdGlvbkRpcmVjdGlvbjtcclxuKGZ1bmN0aW9uIChOYXZpZ2F0aW9uRGlyZWN0aW9uKSB7XHJcbiAgICBOYXZpZ2F0aW9uRGlyZWN0aW9uW1wiYmFja1wiXSA9IFwiYmFja1wiO1xyXG4gICAgTmF2aWdhdGlvbkRpcmVjdGlvbltcImZvcndhcmRcIl0gPSBcImZvcndhcmRcIjtcclxuICAgIE5hdmlnYXRpb25EaXJlY3Rpb25bXCJ1bmtub3duXCJdID0gXCJcIjtcclxufSkoTmF2aWdhdGlvbkRpcmVjdGlvbiB8fCAoTmF2aWdhdGlvbkRpcmVjdGlvbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBTdGFydGluZyBsb2NhdGlvbiBmb3IgSGlzdG9yaWVzXHJcbiAqL1xyXG5jb25zdCBTVEFSVCA9ICcnO1xyXG4vLyBHZW5lcmljIHV0aWxzXHJcbi8qKlxyXG4gKiBOb3JtYWxpemVzIGEgYmFzZSBieSByZW1vdmluZyBhbnkgdHJhaWxpbmcgc2xhc2ggYW5kIHJlYWRpbmcgdGhlIGJhc2UgdGFnIGlmXHJcbiAqIHByZXNlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBiYXNlIC0gYmFzZSB0byBub3JtYWxpemVcclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUJhc2UoYmFzZSkge1xyXG4gICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xyXG4gICAgICAgICAgICAvLyByZXNwZWN0IDxiYXNlPiB0YWdcclxuICAgICAgICAgICAgY29uc3QgYmFzZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xyXG4gICAgICAgICAgICBiYXNlID0gKGJhc2VFbCAmJiBiYXNlRWwuZ2V0QXR0cmlidXRlKCdocmVmJykpIHx8ICcvJztcclxuICAgICAgICAgICAgLy8gc3RyaXAgZnVsbCBVUkwgb3JpZ2luXHJcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlLnJlcGxhY2UoL15cXHcrOlxcL1xcL1teXFwvXSsvLCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBiYXNlID0gJy8nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoIHdoZW4gaXQgd2FzIHJlbW92ZWQgYnkgdGhlIHJlZ2V4IGFib3ZlIGF2b2lkIGxlYWRpbmdcclxuICAgIC8vIHNsYXNoIHdpdGggaGFzaCBiZWNhdXNlIHRoZSBmaWxlIGNvdWxkIGJlIHJlYWQgZnJvbSB0aGUgZGlzayBsaWtlIGZpbGU6Ly9cclxuICAgIC8vIGFuZCB0aGUgbGVhZGluZyBzbGFzaCB3b3VsZCBjYXVzZSBwcm9ibGVtc1xyXG4gICAgaWYgKGJhc2VbMF0gIT09ICcvJyAmJiBiYXNlWzBdICE9PSAnIycpXHJcbiAgICAgICAgYmFzZSA9ICcvJyArIGJhc2U7XHJcbiAgICAvLyByZW1vdmUgdGhlIHRyYWlsaW5nIHNsYXNoIHNvIGFsbCBvdGhlciBtZXRob2QgY2FuIGp1c3QgZG8gYGJhc2UgKyBmdWxsUGF0aGBcclxuICAgIC8vIHRvIGJ1aWxkIGFuIGhyZWZcclxuICAgIHJldHVybiByZW1vdmVUcmFpbGluZ1NsYXNoKGJhc2UpO1xyXG59XHJcbi8vIHJlbW92ZSBhbnkgY2hhcmFjdGVyIGJlZm9yZSB0aGUgaGFzaFxyXG5jb25zdCBCRUZPUkVfSEFTSF9SRSA9IC9eW14jXSsjLztcclxuZnVuY3Rpb24gY3JlYXRlSHJlZihiYXNlLCBsb2NhdGlvbikge1xyXG4gICAgcmV0dXJuIGJhc2UucmVwbGFjZShCRUZPUkVfSEFTSF9SRSwgJyMnKSArIGxvY2F0aW9uO1xyXG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRQb3NpdGlvbihlbCwgb2Zmc2V0KSB7XHJcbiAgICBjb25zdCBkb2NSZWN0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgY29uc3QgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGJlaGF2aW9yOiBvZmZzZXQuYmVoYXZpb3IsXHJcbiAgICAgICAgbGVmdDogZWxSZWN0LmxlZnQgLSBkb2NSZWN0LmxlZnQgLSAob2Zmc2V0LmxlZnQgfHwgMCksXHJcbiAgICAgICAgdG9wOiBlbFJlY3QudG9wIC0gZG9jUmVjdC50b3AgLSAob2Zmc2V0LnRvcCB8fCAwKSxcclxuICAgIH07XHJcbn1cclxuY29uc3QgY29tcHV0ZVNjcm9sbFBvc2l0aW9uID0gKCkgPT4gKHtcclxuICAgIGxlZnQ6IHdpbmRvdy5wYWdlWE9mZnNldCxcclxuICAgIHRvcDogd2luZG93LnBhZ2VZT2Zmc2V0LFxyXG59KTtcclxuZnVuY3Rpb24gc2Nyb2xsVG9Qb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgbGV0IHNjcm9sbFRvT3B0aW9ucztcclxuICAgIGlmICgnZWwnIGluIHBvc2l0aW9uKSB7XHJcbiAgICAgICAgbGV0IHBvc2l0aW9uRWwgPSBwb3NpdGlvbi5lbDtcclxuICAgICAgICBjb25zdCBpc0lkU2VsZWN0b3IgPSB0eXBlb2YgcG9zaXRpb25FbCA9PT0gJ3N0cmluZycgJiYgcG9zaXRpb25FbC5zdGFydHNXaXRoKCcjJyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYGlkYHMgY2FuIGFjY2VwdCBwcmV0dHkgbXVjaCBhbnkgY2hhcmFjdGVycywgaW5jbHVkaW5nIENTUyBjb21iaW5hdG9yc1xyXG4gICAgICAgICAqIGxpa2UgYD5gIG9yIGB+YC4gSXQncyBzdGlsbCBwb3NzaWJsZSB0byByZXRyaWV2ZSBlbGVtZW50cyB1c2luZ1xyXG4gICAgICAgICAqIGBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnficpYCBidXQgaXQgbmVlZHMgdG8gYmUgZXNjYXBlZCB3aGVuIHVzaW5nXHJcbiAgICAgICAgICogYGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNcXFxcficpYCBmb3IgaXQgdG8gYmUgdmFsaWQuIFRoZSBvbmx5XHJcbiAgICAgICAgICogcmVxdWlyZW1lbnRzIGZvciBgaWRgcyBhcmUgdGhlbSB0byBiZSB1bmlxdWUgb24gdGhlIHBhZ2UgYW5kIHRvIG5vdCBiZVxyXG4gICAgICAgICAqIGVtcHR5IChgaWQ9XCJcImApLiBCZWNhdXNlIG9mIHRoYXQsIHdoZW4gcGFzc2luZyBhbiBpZCBzZWxlY3RvciwgaXQgc2hvdWxkXHJcbiAgICAgICAgICogYmUgcHJvcGVybHkgZXNjYXBlZCBmb3IgaXQgdG8gd29yayB3aXRoIGBxdWVyeVNlbGVjdG9yYC4gV2UgY291bGQgY2hlY2tcclxuICAgICAgICAgKiBmb3IgdGhlIGlkIHNlbGVjdG9yIHRvIGJlIHNpbXBsZSAobm8gQ1NTIGNvbWJpbmF0b3JzIGArID5+YCkgYnV0IHRoYXRcclxuICAgICAgICAgKiB3b3VsZCBtYWtlIHRoaW5ncyBpbmNvbnNpc3RlbnQgc2luY2UgdGhleSBhcmUgdmFsaWQgY2hhcmFjdGVycyBmb3IgYW5cclxuICAgICAgICAgKiBgaWRgIGJ1dCB3b3VsZCBuZWVkIHRvIGJlIGVzY2FwZWQgd2hlbiB1c2luZyBgcXVlcnlTZWxlY3RvcmAsIGJyZWFraW5nXHJcbiAgICAgICAgICogdGhlaXIgdXNhZ2UgYW5kIGVuZGluZyB1cCBpbiBubyBzZWxlY3RvciByZXR1cm5lZC4gU2VsZWN0b3JzIG5lZWQgdG8gYmVcclxuICAgICAgICAgKiBlc2NhcGVkOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLSBgIzEtdGhpbmdgIGJlY29tZXMgYCNcXDMxIC10aGluZ2BcclxuICAgICAgICAgKiAtIGAjd2l0aH5zeW1ib2xzYCBiZWNvbWVzIGAjd2l0aFxcXFx+c3ltYm9sc2BcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIC0gTW9yZSBpbmZvcm1hdGlvbiBhYm91dCAgdGhlIHRvcGljIGNhbiBiZSBmb3VuZCBhdFxyXG4gICAgICAgICAqICAgaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2h0bWw1LWlkLWNsYXNzLlxyXG4gICAgICAgICAqIC0gUHJhY3RpY2FsIGV4YW1wbGU6IGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9kZW1vL2h0bWw1LWlkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0eXBlb2YgcG9zaXRpb24uZWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNJZFNlbGVjdG9yIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwb3NpdGlvbi5lbC5zbGljZSgxKSkpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBvc2l0aW9uLmVsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJZFNlbGVjdG9yICYmIGZvdW5kRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgVGhlIHNlbGVjdG9yIFwiJHtwb3NpdGlvbi5lbH1cIiBzaG91bGQgYmUgcGFzc2VkIGFzIFwiZWw6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyR7cG9zaXRpb24uZWx9JylcIiBiZWNhdXNlIGl0IHN0YXJ0cyB3aXRoIFwiI1wiLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gdG8gYXZvaWQgb3RoZXIgd2FybmluZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBUaGUgc2VsZWN0b3IgXCIke3Bvc2l0aW9uLmVsfVwiIGlzIGludmFsaWQuIElmIHlvdSBhcmUgdXNpbmcgYW4gaWQgc2VsZWN0b3IsIG1ha2Ugc3VyZSB0byBlc2NhcGUgaXQuIFlvdSBjYW4gZmluZCBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGVzY2FwaW5nIGNoYXJhY3RlcnMgaW4gc2VsZWN0b3JzIGF0IGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9jc3MtZXNjYXBlcyBvciB1c2UgQ1NTLmVzY2FwZSAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NTUy9lc2NhcGUpLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiB0byBhdm9pZCBvdGhlciB3YXJuaW5nc1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbCA9IHR5cGVvZiBwb3NpdGlvbkVsID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICA/IGlzSWRTZWxlY3RvclxyXG4gICAgICAgICAgICAgICAgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwb3NpdGlvbkVsLnNsaWNlKDEpKVxyXG4gICAgICAgICAgICAgICAgOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBvc2l0aW9uRWwpXHJcbiAgICAgICAgICAgIDogcG9zaXRpb25FbDtcclxuICAgICAgICBpZiAoIWVsKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQ291bGRuJ3QgZmluZCBlbGVtZW50IHVzaW5nIHNlbGVjdG9yIFwiJHtwb3NpdGlvbi5lbH1cIiByZXR1cm5lZCBieSBzY3JvbGxCZWhhdmlvci5gKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzY3JvbGxUb09wdGlvbnMgPSBnZXRFbGVtZW50UG9zaXRpb24oZWwsIHBvc2l0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNjcm9sbFRvT3B0aW9ucyA9IHBvc2l0aW9uO1xyXG4gICAgfVxyXG4gICAgaWYgKCdzY3JvbGxCZWhhdmlvcicgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKVxyXG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxUb09wdGlvbnMpO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHNjcm9sbFRvT3B0aW9ucy5sZWZ0ICE9IG51bGwgPyBzY3JvbGxUb09wdGlvbnMubGVmdCA6IHdpbmRvdy5wYWdlWE9mZnNldCwgc2Nyb2xsVG9PcHRpb25zLnRvcCAhPSBudWxsID8gc2Nyb2xsVG9PcHRpb25zLnRvcCA6IHdpbmRvdy5wYWdlWU9mZnNldCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2Nyb2xsS2V5KHBhdGgsIGRlbHRhKSB7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IGhpc3Rvcnkuc3RhdGUgPyBoaXN0b3J5LnN0YXRlLnBvc2l0aW9uIC0gZGVsdGEgOiAtMTtcclxuICAgIHJldHVybiBwb3NpdGlvbiArIHBhdGg7XHJcbn1cclxuY29uc3Qgc2Nyb2xsUG9zaXRpb25zID0gbmV3IE1hcCgpO1xyXG5mdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24oa2V5LCBzY3JvbGxQb3NpdGlvbikge1xyXG4gICAgc2Nyb2xsUG9zaXRpb25zLnNldChrZXksIHNjcm9sbFBvc2l0aW9uKTtcclxufVxyXG5mdW5jdGlvbiBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKGtleSkge1xyXG4gICAgY29uc3Qgc2Nyb2xsID0gc2Nyb2xsUG9zaXRpb25zLmdldChrZXkpO1xyXG4gICAgLy8gY29uc3VtZSBpdCBzbyBpdCdzIG5vdCB1c2VkIGFnYWluXHJcbiAgICBzY3JvbGxQb3NpdGlvbnMuZGVsZXRlKGtleSk7XHJcbiAgICByZXR1cm4gc2Nyb2xsO1xyXG59XHJcbi8vIFRPRE86IFJGQyBhYm91dCBob3cgdG8gc2F2ZSBzY3JvbGwgcG9zaXRpb25cclxuLyoqXHJcbiAqIFNjcm9sbEJlaGF2aW9yIGluc3RhbmNlIHVzZWQgYnkgdGhlIHJvdXRlciB0byBjb21wdXRlIGFuZCByZXN0b3JlIHRoZSBzY3JvbGxcclxuICogcG9zaXRpb24gd2hlbiBuYXZpZ2F0aW5nLlxyXG4gKi9cclxuLy8gZXhwb3J0IGludGVyZmFjZSBTY3JvbGxIYW5kbGVyPFNjcm9sbFBvc2l0aW9uRW50cnkgZXh0ZW5kcyBIaXN0b3J5U3RhdGVWYWx1ZSwgU2Nyb2xsUG9zaXRpb24gZXh0ZW5kcyBTY3JvbGxQb3NpdGlvbkVudHJ5PiB7XHJcbi8vICAgLy8gcmV0dXJucyBhIHNjcm9sbCBwb3NpdGlvbiB0aGF0IGNhbiBiZSBzYXZlZCBpbiBoaXN0b3J5XHJcbi8vICAgY29tcHV0ZSgpOiBTY3JvbGxQb3NpdGlvbkVudHJ5XHJcbi8vICAgLy8gY2FuIHRha2UgYW4gZXh0ZW5kZWQgU2Nyb2xsUG9zaXRpb25FbnRyeVxyXG4vLyAgIHNjcm9sbChwb3NpdGlvbjogU2Nyb2xsUG9zaXRpb24pOiB2b2lkXHJcbi8vIH1cclxuLy8gZXhwb3J0IGNvbnN0IHNjcm9sbEhhbmRsZXI6IFNjcm9sbEhhbmRsZXI8U2Nyb2xsUG9zaXRpb24+ID0ge1xyXG4vLyAgIGNvbXB1dGU6IGNvbXB1dGVTY3JvbGwsXHJcbi8vICAgc2Nyb2xsOiBzY3JvbGxUb1Bvc2l0aW9uLFxyXG4vLyB9XG5cbmxldCBjcmVhdGVCYXNlTG9jYXRpb24gPSAoKSA9PiBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0O1xyXG4vKipcclxuICogQ3JlYXRlcyBhIG5vcm1hbGl6ZWQgaGlzdG9yeSBsb2NhdGlvbiBmcm9tIGEgd2luZG93LmxvY2F0aW9uIG9iamVjdFxyXG4gKiBAcGFyYW0gbG9jYXRpb24gLVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQ3VycmVudExvY2F0aW9uKGJhc2UsIGxvY2F0aW9uKSB7XHJcbiAgICBjb25zdCB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSA9IGxvY2F0aW9uO1xyXG4gICAgLy8gYWxsb3dzIGhhc2ggYmFzZXMgbGlrZSAjLCAvIywgIy8sICMhLCAjIS8sIC8jIS8sIG9yIGV2ZW4gL2ZvbGRlciNlbmRcclxuICAgIGNvbnN0IGhhc2hQb3MgPSBiYXNlLmluZGV4T2YoJyMnKTtcclxuICAgIGlmIChoYXNoUG9zID4gLTEpIHtcclxuICAgICAgICBsZXQgc2xpY2VQb3MgPSBoYXNoLmluY2x1ZGVzKGJhc2Uuc2xpY2UoaGFzaFBvcykpXHJcbiAgICAgICAgICAgID8gYmFzZS5zbGljZShoYXNoUG9zKS5sZW5ndGhcclxuICAgICAgICAgICAgOiAxO1xyXG4gICAgICAgIGxldCBwYXRoRnJvbUhhc2ggPSBoYXNoLnNsaWNlKHNsaWNlUG9zKTtcclxuICAgICAgICAvLyBwcmVwZW5kIHRoZSBzdGFydGluZyBzbGFzaCB0byBoYXNoIHNvIHRoZSB1cmwgc3RhcnRzIHdpdGggLyNcclxuICAgICAgICBpZiAocGF0aEZyb21IYXNoWzBdICE9PSAnLycpXHJcbiAgICAgICAgICAgIHBhdGhGcm9tSGFzaCA9ICcvJyArIHBhdGhGcm9tSGFzaDtcclxuICAgICAgICByZXR1cm4gc3RyaXBCYXNlKHBhdGhGcm9tSGFzaCwgJycpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGF0aCA9IHN0cmlwQmFzZShwYXRobmFtZSwgYmFzZSk7XHJcbiAgICByZXR1cm4gcGF0aCArIHNlYXJjaCArIGhhc2g7XHJcbn1cclxuZnVuY3Rpb24gdXNlSGlzdG9yeUxpc3RlbmVycyhiYXNlLCBoaXN0b3J5U3RhdGUsIGN1cnJlbnRMb2NhdGlvbiwgcmVwbGFjZSkge1xyXG4gICAgbGV0IGxpc3RlbmVycyA9IFtdO1xyXG4gICAgbGV0IHRlYXJkb3ducyA9IFtdO1xyXG4gICAgLy8gVE9ETzogc2hvdWxkIGl0IGJlIGEgc3RhY2s/IGEgRGljdC4gQ2hlY2sgaWYgdGhlIHBvcHN0YXRlIGxpc3RlbmVyXHJcbiAgICAvLyBjYW4gdHJpZ2dlciB0d2ljZVxyXG4gICAgbGV0IHBhdXNlU3RhdGUgPSBudWxsO1xyXG4gICAgY29uc3QgcG9wU3RhdGVIYW5kbGVyID0gKHsgc3RhdGUsIH0pID0+IHtcclxuICAgICAgICBjb25zdCB0byA9IGNyZWF0ZUN1cnJlbnRMb2NhdGlvbihiYXNlLCBsb2NhdGlvbik7XHJcbiAgICAgICAgY29uc3QgZnJvbSA9IGN1cnJlbnRMb2NhdGlvbi52YWx1ZTtcclxuICAgICAgICBjb25zdCBmcm9tU3RhdGUgPSBoaXN0b3J5U3RhdGUudmFsdWU7XHJcbiAgICAgICAgbGV0IGRlbHRhID0gMDtcclxuICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgY3VycmVudExvY2F0aW9uLnZhbHVlID0gdG87XHJcbiAgICAgICAgICAgIGhpc3RvcnlTdGF0ZS52YWx1ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAvLyBpZ25vcmUgdGhlIHBvcHN0YXRlIGFuZCByZXNldCB0aGUgcGF1c2VTdGF0ZVxyXG4gICAgICAgICAgICBpZiAocGF1c2VTdGF0ZSAmJiBwYXVzZVN0YXRlID09PSBmcm9tKSB7XHJcbiAgICAgICAgICAgICAgICBwYXVzZVN0YXRlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWx0YSA9IGZyb21TdGF0ZSA/IHN0YXRlLnBvc2l0aW9uIC0gZnJvbVN0YXRlLnBvc2l0aW9uIDogMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcGxhY2UodG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh7IGRlbHRhRnJvbUN1cnJlbnQgfSlcclxuICAgICAgICAvLyBIZXJlIHdlIGNvdWxkIGFsc28gcmV2ZXJ0IHRoZSBuYXZpZ2F0aW9uIGJ5IGNhbGxpbmcgaGlzdG9yeS5nbygtZGVsdGEpXHJcbiAgICAgICAgLy8gdGhpcyBsaXN0ZW5lciB3aWxsIGhhdmUgdG8gYmUgYWRhcHRlZCB0byBub3QgdHJpZ2dlciBhZ2FpbiBhbmQgdG8gd2FpdCBmb3IgdGhlIHVybFxyXG4gICAgICAgIC8vIHRvIGJlIHVwZGF0ZWQgYmVmb3JlIHRyaWdnZXJpbmcgdGhlIGxpc3RlbmVycy4gU29tZSBraW5kIG9mIHZhbGlkYXRpb24gZnVuY3Rpb24gd291bGQgYWxzb1xyXG4gICAgICAgIC8vIG5lZWQgdG8gYmUgcGFzc2VkIHRvIHRoZSBsaXN0ZW5lcnMgc28gdGhlIG5hdmlnYXRpb24gY2FuIGJlIGFjY2VwdGVkXHJcbiAgICAgICAgLy8gY2FsbCBhbGwgbGlzdGVuZXJzXHJcbiAgICAgICAgbGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4ge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcihjdXJyZW50TG9jYXRpb24udmFsdWUsIGZyb20sIHtcclxuICAgICAgICAgICAgICAgIGRlbHRhLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogTmF2aWdhdGlvblR5cGUucG9wLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkZWx0YVxyXG4gICAgICAgICAgICAgICAgICAgID8gZGVsdGEgPiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gTmF2aWdhdGlvbkRpcmVjdGlvbi5mb3J3YXJkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTmF2aWdhdGlvbkRpcmVjdGlvbi5iYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgOiBOYXZpZ2F0aW9uRGlyZWN0aW9uLnVua25vd24sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHBhdXNlTGlzdGVuZXJzKCkge1xyXG4gICAgICAgIHBhdXNlU3RhdGUgPSBjdXJyZW50TG9jYXRpb24udmFsdWU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBsaXN0ZW4oY2FsbGJhY2spIHtcclxuICAgICAgICAvLyBzZXR1cCB0aGUgbGlzdGVuZXIgYW5kIHByZXBhcmUgdGVhcmRvd24gY2FsbGJhY2tzXHJcbiAgICAgICAgbGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgIGNvbnN0IHRlYXJkb3duID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRlYXJkb3ducy5wdXNoKHRlYXJkb3duKTtcclxuICAgICAgICByZXR1cm4gdGVhcmRvd247XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBiZWZvcmVVbmxvYWRMaXN0ZW5lcigpIHtcclxuICAgICAgICBjb25zdCB7IGhpc3RvcnkgfSA9IHdpbmRvdztcclxuICAgICAgICBpZiAoIWhpc3Rvcnkuc3RhdGUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShhc3NpZ24oe30sIGhpc3Rvcnkuc3RhdGUsIHsgc2Nyb2xsOiBjb21wdXRlU2Nyb2xsUG9zaXRpb24oKSB9KSwgJycpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHRlYXJkb3duIG9mIHRlYXJkb3ducylcclxuICAgICAgICAgICAgdGVhcmRvd24oKTtcclxuICAgICAgICB0ZWFyZG93bnMgPSBbXTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBwb3BTdGF0ZUhhbmRsZXIpO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBiZWZvcmVVbmxvYWRMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvLyBzZXR1cCB0aGUgbGlzdGVuZXJzIGFuZCBwcmVwYXJlIHRlYXJkb3duIGNhbGxiYWNrc1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgcG9wU3RhdGVIYW5kbGVyKTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBiZWZvcmVVbmxvYWRMaXN0ZW5lcik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHBhdXNlTGlzdGVuZXJzLFxyXG4gICAgICAgIGxpc3RlbixcclxuICAgICAgICBkZXN0cm95LFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHN0YXRlIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gYnVpbGRTdGF0ZShiYWNrLCBjdXJyZW50LCBmb3J3YXJkLCByZXBsYWNlZCA9IGZhbHNlLCBjb21wdXRlU2Nyb2xsID0gZmFsc2UpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYmFjayxcclxuICAgICAgICBjdXJyZW50LFxyXG4gICAgICAgIGZvcndhcmQsXHJcbiAgICAgICAgcmVwbGFjZWQsXHJcbiAgICAgICAgcG9zaXRpb246IHdpbmRvdy5oaXN0b3J5Lmxlbmd0aCxcclxuICAgICAgICBzY3JvbGw6IGNvbXB1dGVTY3JvbGwgPyBjb21wdXRlU2Nyb2xsUG9zaXRpb24oKSA6IG51bGwsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHVzZUhpc3RvcnlTdGF0ZU5hdmlnYXRpb24oYmFzZSkge1xyXG4gICAgY29uc3QgeyBoaXN0b3J5LCBsb2NhdGlvbiB9ID0gd2luZG93O1xyXG4gICAgLy8gcHJpdmF0ZSB2YXJpYWJsZXNcclxuICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSB7XHJcbiAgICAgICAgdmFsdWU6IGNyZWF0ZUN1cnJlbnRMb2NhdGlvbihiYXNlLCBsb2NhdGlvbiksXHJcbiAgICB9O1xyXG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IHsgdmFsdWU6IGhpc3Rvcnkuc3RhdGUgfTtcclxuICAgIC8vIGJ1aWxkIGN1cnJlbnQgaGlzdG9yeSBlbnRyeSBhcyB0aGlzIGlzIGEgZnJlc2ggbmF2aWdhdGlvblxyXG4gICAgaWYgKCFoaXN0b3J5U3RhdGUudmFsdWUpIHtcclxuICAgICAgICBjaGFuZ2VMb2NhdGlvbihjdXJyZW50TG9jYXRpb24udmFsdWUsIHtcclxuICAgICAgICAgICAgYmFjazogbnVsbCxcclxuICAgICAgICAgICAgY3VycmVudDogY3VycmVudExvY2F0aW9uLnZhbHVlLFxyXG4gICAgICAgICAgICBmb3J3YXJkOiBudWxsLFxyXG4gICAgICAgICAgICAvLyB0aGUgbGVuZ3RoIGlzIG9mZiBieSBvbmUsIHdlIG5lZWQgdG8gZGVjcmVhc2UgaXRcclxuICAgICAgICAgICAgcG9zaXRpb246IGhpc3RvcnkubGVuZ3RoIC0gMSxcclxuICAgICAgICAgICAgcmVwbGFjZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIC8vIGRvbid0IGFkZCBhIHNjcm9sbCBhcyB0aGUgdXNlciBtYXkgaGF2ZSBhbiBhbmNob3IgYW5kIHdlIHdhbnRcclxuICAgICAgICAgICAgLy8gc2Nyb2xsQmVoYXZpb3IgdG8gYmUgdHJpZ2dlcmVkIHdpdGhvdXQgYSBzYXZlZCBwb3NpdGlvblxyXG4gICAgICAgICAgICBzY3JvbGw6IG51bGwsXHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjaGFuZ2VMb2NhdGlvbih0bywgc3RhdGUsIHJlcGxhY2UpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBpZiBhIGJhc2UgdGFnIGlzIHByb3ZpZGVkIGFuZCB3ZSBhcmUgb24gYSBub3JtYWwgZG9tYWluLCB3ZSBoYXZlIHRvXHJcbiAgICAgICAgICogcmVzcGVjdCB0aGUgcHJvdmlkZWQgYGJhc2VgIGF0dHJpYnV0ZSBiZWNhdXNlIHB1c2hTdGF0ZSgpIHdpbGwgdXNlIGl0IGFuZFxyXG4gICAgICAgICAqIHBvdGVudGlhbGx5IGVyYXNlIGFueXRoaW5nIGJlZm9yZSB0aGUgYCNgIGxpa2UgYXRcclxuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLXJvdXRlci1uZXh0L2lzc3Vlcy82ODUgd2hlcmUgYSBiYXNlIG9mXHJcbiAgICAgICAgICogYC9mb2xkZXIvI2AgYnV0IGEgYmFzZSBvZiBgL2Agd291bGQgZXJhc2UgdGhlIGAvZm9sZGVyL2Agc2VjdGlvbi4gSWZcclxuICAgICAgICAgKiB0aGVyZSBpcyBubyBob3N0LCB0aGUgYDxiYXNlPmAgdGFnIG1ha2VzIG5vIHNlbnNlIGFuZCBpZiB0aGVyZSBpc24ndCBhXHJcbiAgICAgICAgICogYmFzZSB0YWcgd2UgY2FuIGp1c3QgdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGAjYC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zdCBoYXNoSW5kZXggPSBiYXNlLmluZGV4T2YoJyMnKTtcclxuICAgICAgICBjb25zdCB1cmwgPSBoYXNoSW5kZXggPiAtMVxyXG4gICAgICAgICAgICA/IChsb2NhdGlvbi5ob3N0ICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKVxyXG4gICAgICAgICAgICAgICAgPyBiYXNlXHJcbiAgICAgICAgICAgICAgICA6IGJhc2Uuc2xpY2UoaGFzaEluZGV4KSkgKyB0b1xyXG4gICAgICAgICAgICA6IGNyZWF0ZUJhc2VMb2NhdGlvbigpICsgYmFzZSArIHRvO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIEJST1dTRVIgUVVJUktcclxuICAgICAgICAgICAgLy8gTk9URTogU2FmYXJpIHRocm93cyBhIFNlY3VyaXR5RXJyb3Igd2hlbiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gMTAwIHRpbWVzIGluIDMwIHNlY29uZHNcclxuICAgICAgICAgICAgaGlzdG9yeVtyZXBsYWNlID8gJ3JlcGxhY2VTdGF0ZScgOiAncHVzaFN0YXRlJ10oc3RhdGUsICcnLCB1cmwpO1xyXG4gICAgICAgICAgICBoaXN0b3J5U3RhdGUudmFsdWUgPSBzdGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCdFcnJvciB3aXRoIHB1c2gvcmVwbGFjZSBTdGF0ZScsIGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRm9yY2UgdGhlIG5hdmlnYXRpb24sIHRoaXMgYWxzbyByZXNldHMgdGhlIGNhbGwgY291bnRcclxuICAgICAgICAgICAgbG9jYXRpb25bcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdhc3NpZ24nXSh1cmwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlcGxhY2UodG8sIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IGFzc2lnbih7fSwgaGlzdG9yeS5zdGF0ZSwgYnVpbGRTdGF0ZShoaXN0b3J5U3RhdGUudmFsdWUuYmFjaywgXHJcbiAgICAgICAgLy8ga2VlcCBiYWNrIGFuZCBmb3J3YXJkIGVudHJpZXMgYnV0IG92ZXJyaWRlIGN1cnJlbnQgcG9zaXRpb25cclxuICAgICAgICB0bywgaGlzdG9yeVN0YXRlLnZhbHVlLmZvcndhcmQsIHRydWUpLCBkYXRhLCB7IHBvc2l0aW9uOiBoaXN0b3J5U3RhdGUudmFsdWUucG9zaXRpb24gfSk7XHJcbiAgICAgICAgY2hhbmdlTG9jYXRpb24odG8sIHN0YXRlLCB0cnVlKTtcclxuICAgICAgICBjdXJyZW50TG9jYXRpb24udmFsdWUgPSB0bztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHB1c2godG8sIGRhdGEpIHtcclxuICAgICAgICAvLyBBZGQgdG8gY3VycmVudCBlbnRyeSB0aGUgaW5mb3JtYXRpb24gb2Ygd2hlcmUgd2UgYXJlIGdvaW5nXHJcbiAgICAgICAgLy8gYXMgd2VsbCBhcyBzYXZpbmcgdGhlIGN1cnJlbnQgcG9zaXRpb25cclxuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBhc3NpZ24oe30sIFxyXG4gICAgICAgIC8vIHVzZSBjdXJyZW50IGhpc3Rvcnkgc3RhdGUgdG8gZ3JhY2VmdWxseSBoYW5kbGUgYSB3cm9uZyBjYWxsIHRvXHJcbiAgICAgICAgLy8gaGlzdG9yeS5yZXBsYWNlU3RhdGVcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLXJvdXRlci1uZXh0L2lzc3Vlcy8zNjZcclxuICAgICAgICBoaXN0b3J5U3RhdGUudmFsdWUsIGhpc3Rvcnkuc3RhdGUsIHtcclxuICAgICAgICAgICAgZm9yd2FyZDogdG8sXHJcbiAgICAgICAgICAgIHNjcm9sbDogY29tcHV0ZVNjcm9sbFBvc2l0aW9uKCksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaGlzdG9yeS5zdGF0ZSkge1xyXG4gICAgICAgICAgICB3YXJuKGBoaXN0b3J5LnN0YXRlIHNlZW1zIHRvIGhhdmUgYmVlbiBtYW51YWxseSByZXBsYWNlZCB3aXRob3V0IHByZXNlcnZpbmcgdGhlIG5lY2Vzc2FyeSB2YWx1ZXMuIE1ha2Ugc3VyZSB0byBwcmVzZXJ2ZSBleGlzdGluZyBoaXN0b3J5IHN0YXRlIGlmIHlvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBoaXN0b3J5LnJlcGxhY2VTdGF0ZTpcXG5cXG5gICtcclxuICAgICAgICAgICAgICAgIGBoaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5LnN0YXRlLCAnJywgdXJsKVxcblxcbmAgK1xyXG4gICAgICAgICAgICAgICAgYFlvdSBjYW4gZmluZCBtb3JlIGluZm9ybWF0aW9uIGF0IGh0dHBzOi8vbmV4dC5yb3V0ZXIudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi8jdXNhZ2Utb2YtaGlzdG9yeS1zdGF0ZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hhbmdlTG9jYXRpb24oY3VycmVudFN0YXRlLmN1cnJlbnQsIGN1cnJlbnRTdGF0ZSwgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBhc3NpZ24oe30sIGJ1aWxkU3RhdGUoY3VycmVudExvY2F0aW9uLnZhbHVlLCB0bywgbnVsbCksIHsgcG9zaXRpb246IGN1cnJlbnRTdGF0ZS5wb3NpdGlvbiArIDEgfSwgZGF0YSk7XHJcbiAgICAgICAgY2hhbmdlTG9jYXRpb24odG8sIHN0YXRlLCBmYWxzZSk7XHJcbiAgICAgICAgY3VycmVudExvY2F0aW9uLnZhbHVlID0gdG87XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxvY2F0aW9uOiBjdXJyZW50TG9jYXRpb24sXHJcbiAgICAgICAgc3RhdGU6IGhpc3RvcnlTdGF0ZSxcclxuICAgICAgICBwdXNoLFxyXG4gICAgICAgIHJlcGxhY2UsXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIEhUTUw1IGhpc3RvcnkuIE1vc3QgY29tbW9uIGhpc3RvcnkgZm9yIHNpbmdsZSBwYWdlIGFwcGxpY2F0aW9ucy5cclxuICpcclxuICogQHBhcmFtIGJhc2UgLVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlV2ViSGlzdG9yeShiYXNlKSB7XHJcbiAgICBiYXNlID0gbm9ybWFsaXplQmFzZShiYXNlKTtcclxuICAgIGNvbnN0IGhpc3RvcnlOYXZpZ2F0aW9uID0gdXNlSGlzdG9yeVN0YXRlTmF2aWdhdGlvbihiYXNlKTtcclxuICAgIGNvbnN0IGhpc3RvcnlMaXN0ZW5lcnMgPSB1c2VIaXN0b3J5TGlzdGVuZXJzKGJhc2UsIGhpc3RvcnlOYXZpZ2F0aW9uLnN0YXRlLCBoaXN0b3J5TmF2aWdhdGlvbi5sb2NhdGlvbiwgaGlzdG9yeU5hdmlnYXRpb24ucmVwbGFjZSk7XHJcbiAgICBmdW5jdGlvbiBnbyhkZWx0YSwgdHJpZ2dlckxpc3RlbmVycyA9IHRydWUpIHtcclxuICAgICAgICBpZiAoIXRyaWdnZXJMaXN0ZW5lcnMpXHJcbiAgICAgICAgICAgIGhpc3RvcnlMaXN0ZW5lcnMucGF1c2VMaXN0ZW5lcnMoKTtcclxuICAgICAgICBoaXN0b3J5LmdvKGRlbHRhKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJvdXRlckhpc3RvcnkgPSBhc3NpZ24oe1xyXG4gICAgICAgIC8vIGl0J3Mgb3ZlcnJpZGRlbiByaWdodCBhZnRlclxyXG4gICAgICAgIGxvY2F0aW9uOiAnJyxcclxuICAgICAgICBiYXNlLFxyXG4gICAgICAgIGdvLFxyXG4gICAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYuYmluZChudWxsLCBiYXNlKSxcclxuICAgIH0sIGhpc3RvcnlOYXZpZ2F0aW9uLCBoaXN0b3J5TGlzdGVuZXJzKTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb3V0ZXJIaXN0b3J5LCAnbG9jYXRpb24nLCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6ICgpID0+IGhpc3RvcnlOYXZpZ2F0aW9uLmxvY2F0aW9uLnZhbHVlLFxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocm91dGVySGlzdG9yeSwgJ3N0YXRlJywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiAoKSA9PiBoaXN0b3J5TmF2aWdhdGlvbi5zdGF0ZS52YWx1ZSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJvdXRlckhpc3Rvcnk7XHJcbn1cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBpbi1tZW1vcnkgYmFzZWQgaGlzdG9yeS4gVGhlIG1haW4gcHVycG9zZSBvZiB0aGlzIGhpc3RvcnkgaXMgdG8gaGFuZGxlIFNTUi4gSXQgc3RhcnRzIGluIGEgc3BlY2lhbCBsb2NhdGlvbiB0aGF0IGlzIG5vd2hlcmUuXHJcbiAqIEl0J3MgdXAgdG8gdGhlIHVzZXIgdG8gcmVwbGFjZSB0aGF0IGxvY2F0aW9uIHdpdGggdGhlIHN0YXJ0ZXIgbG9jYXRpb24gYnkgZWl0aGVyIGNhbGxpbmcgYHJvdXRlci5wdXNoYCBvciBgcm91dGVyLnJlcGxhY2VgLlxyXG4gKlxyXG4gKiBAcGFyYW0gYmFzZSAtIEJhc2UgYXBwbGllZCB0byBhbGwgdXJscywgZGVmYXVsdHMgdG8gJy8nXHJcbiAqIEByZXR1cm5zIGEgaGlzdG9yeSBvYmplY3QgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSByb3V0ZXIgY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoYmFzZSA9ICcnKSB7XHJcbiAgICBsZXQgbGlzdGVuZXJzID0gW107XHJcbiAgICBsZXQgcXVldWUgPSBbU1RBUlRdO1xyXG4gICAgbGV0IHBvc2l0aW9uID0gMDtcclxuICAgIGZ1bmN0aW9uIHNldExvY2F0aW9uKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgcG9zaXRpb24rKztcclxuICAgICAgICBpZiAocG9zaXRpb24gPT09IHF1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyB3ZSBhcmUgYXQgdGhlIGVuZCwgd2UgY2FuIHNpbXBseSBhcHBlbmQgYSBuZXcgZW50cnlcclxuICAgICAgICAgICAgcXVldWUucHVzaChsb2NhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB3ZSBhcmUgaW4gdGhlIG1pZGRsZSwgd2UgcmVtb3ZlIGV2ZXJ5dGhpbmcgZnJvbSBoZXJlIGluIHRoZSBxdWV1ZVxyXG4gICAgICAgICAgICBxdWV1ZS5zcGxpY2UocG9zaXRpb24pO1xyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGxvY2F0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0cmlnZ2VyTGlzdGVuZXJzKHRvLCBmcm9tLCB7IGRpcmVjdGlvbiwgZGVsdGEgfSkge1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSB7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbixcclxuICAgICAgICAgICAgZGVsdGEsXHJcbiAgICAgICAgICAgIHR5cGU6IE5hdmlnYXRpb25UeXBlLnBvcCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAobGV0IGNhbGxiYWNrIG9mIGxpc3RlbmVycykge1xyXG4gICAgICAgICAgICBjYWxsYmFjayh0bywgZnJvbSwgaW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgcm91dGVySGlzdG9yeSA9IHtcclxuICAgICAgICAvLyByZXdyaXR0ZW4gYnkgT2JqZWN0LmRlZmluZVByb3BlcnR5XHJcbiAgICAgICAgbG9jYXRpb246IFNUQVJULFxyXG4gICAgICAgIC8vIFRPRE86IHNob3VsZCBiZSBrZXB0IGluIHF1ZXVlXHJcbiAgICAgICAgc3RhdGU6IHt9LFxyXG4gICAgICAgIGJhc2UsXHJcbiAgICAgICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZi5iaW5kKG51bGwsIGJhc2UpLFxyXG4gICAgICAgIHJlcGxhY2UodG8pIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGN1cnJlbnQgZW50cnkgYW5kIGRlY3JlbWVudCBwb3NpdGlvblxyXG4gICAgICAgICAgICBxdWV1ZS5zcGxpY2UocG9zaXRpb24tLSwgMSk7XHJcbiAgICAgICAgICAgIHNldExvY2F0aW9uKHRvKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHB1c2godG8sIGRhdGEpIHtcclxuICAgICAgICAgICAgc2V0TG9jYXRpb24odG8pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGlzdGVuKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICAgICAgcXVldWUgPSBbU1RBUlRdO1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnbyhkZWx0YSwgc2hvdWxkVHJpZ2dlciA9IHRydWUpIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbSA9IHRoaXMubG9jYXRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IFxyXG4gICAgICAgICAgICAvLyB3ZSBhcmUgY29uc2lkZXJpbmcgZGVsdGEgPT09IDAgZ29pbmcgZm9yd2FyZCwgYnV0IGluIGFic3RyYWN0IG1vZGVcclxuICAgICAgICAgICAgLy8gdXNpbmcgMCBmb3IgdGhlIGRlbHRhIGRvZXNuJ3QgbWFrZSBzZW5zZSBsaWtlIGl0IGRvZXMgaW4gaHRtbDUgd2hlcmVcclxuICAgICAgICAgICAgLy8gaXQgcmVsb2FkcyB0aGUgcGFnZVxyXG4gICAgICAgICAgICBkZWx0YSA8IDAgPyBOYXZpZ2F0aW9uRGlyZWN0aW9uLmJhY2sgOiBOYXZpZ2F0aW9uRGlyZWN0aW9uLmZvcndhcmQ7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocG9zaXRpb24gKyBkZWx0YSwgcXVldWUubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkVHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckxpc3RlbmVycyh0aGlzLmxvY2F0aW9uLCBmcm9tLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyb3V0ZXJIaXN0b3J5LCAnbG9jYXRpb24nLCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6ICgpID0+IHF1ZXVlW3Bvc2l0aW9uXSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJvdXRlckhpc3Rvcnk7XHJcbn1cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBoYXNoIGhpc3RvcnkuIFVzZWZ1bCBmb3Igd2ViIGFwcGxpY2F0aW9ucyB3aXRoIG5vIGhvc3QgKGUuZy5cclxuICogYGZpbGU6Ly9gKSBvciB3aGVuIGNvbmZpZ3VyaW5nIGEgc2VydmVyIHRvIGhhbmRsZSBhbnkgVVJMIGlzIG5vdCBwb3NzaWJsZS5cclxuICpcclxuICogQHBhcmFtIGJhc2UgLSBvcHRpb25hbCBiYXNlIHRvIHByb3ZpZGUuIERlZmF1bHRzIHRvIGBsb2NhdGlvbi5wYXRobmFtZSArXHJcbiAqIGxvY2F0aW9uLnNlYXJjaGAgSWYgdGhlcmUgaXMgYSBgPGJhc2U+YCB0YWcgaW4gdGhlIGBoZWFkYCwgaXRzIHZhbHVlIHdpbGwgYmVcclxuICogaWdub3JlZCBpbiBmYXZvciBvZiB0aGlzIHBhcmFtZXRlciAqKmJ1dCBub3RlIGl0IGFmZmVjdHMgYWxsIHRoZVxyXG4gKiBoaXN0b3J5LnB1c2hTdGF0ZSgpIGNhbGxzKiosIG1lYW5pbmcgdGhhdCBpZiB5b3UgdXNlIGEgYDxiYXNlPmAgdGFnLCBpdCdzXHJcbiAqIGBocmVmYCB2YWx1ZSAqKmhhcyB0byBtYXRjaCB0aGlzIHBhcmFtZXRlcioqIChpZ25vcmluZyBhbnl0aGluZyBhZnRlciB0aGVcclxuICogYCNgKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogLy8gYXQgaHR0cHM6Ly9leGFtcGxlLmNvbS9mb2xkZXJcclxuICogY3JlYXRlV2ViSGFzaEhpc3RvcnkoKSAvLyBnaXZlcyBhIHVybCBvZiBgaHR0cHM6Ly9leGFtcGxlLmNvbS9mb2xkZXIjYFxyXG4gKiBjcmVhdGVXZWJIYXNoSGlzdG9yeSgnL2ZvbGRlci8nKSAvLyBnaXZlcyBhIHVybCBvZiBgaHR0cHM6Ly9leGFtcGxlLmNvbS9mb2xkZXIvI2BcclxuICogLy8gaWYgdGhlIGAjYCBpcyBwcm92aWRlZCBpbiB0aGUgYmFzZSwgaXQgd29uJ3QgYmUgYWRkZWQgYnkgYGNyZWF0ZVdlYkhhc2hIaXN0b3J5YFxyXG4gKiBjcmVhdGVXZWJIYXNoSGlzdG9yeSgnL2ZvbGRlci8jL2FwcC8nKSAvLyBnaXZlcyBhIHVybCBvZiBgaHR0cHM6Ly9leGFtcGxlLmNvbS9mb2xkZXIvIy9hcHAvYFxyXG4gKiAvLyB5b3Ugc2hvdWxkIGF2b2lkIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCBjaGFuZ2VzIHRoZSBvcmlnaW5hbCB1cmwgYW5kIGJyZWFrcyBjb3B5aW5nIHVybHNcclxuICogY3JlYXRlV2ViSGFzaEhpc3RvcnkoJy9vdGhlci1mb2xkZXIvJykgLy8gZ2l2ZXMgYSB1cmwgb2YgYGh0dHBzOi8vZXhhbXBsZS5jb20vb3RoZXItZm9sZGVyLyNgXHJcbiAqXHJcbiAqIC8vIGF0IGZpbGU6Ly8vdXNyL2V0Yy9mb2xkZXIvaW5kZXguaHRtbFxyXG4gKiAvLyBmb3IgbG9jYXRpb25zIHdpdGggbm8gYGhvc3RgLCB0aGUgYmFzZSBpcyBpZ25vcmVkXHJcbiAqIGNyZWF0ZVdlYkhhc2hIaXN0b3J5KCcvaUFtSWdub3JlZCcpIC8vIGdpdmVzIGEgdXJsIG9mIGBmaWxlOi8vL3Vzci9ldGMvZm9sZGVyL2luZGV4Lmh0bWwjYFxyXG4gKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYkhhc2hIaXN0b3J5KGJhc2UpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGZpbmUgaW4gdGVybXMgb2YgZW5jb2RpbmcsIHNwZWNpYWxseSBmb3IgSUUxMVxyXG4gICAgLy8gZm9yIGBmaWxlOi8vYCwgZGlyZWN0bHkgdXNlIHRoZSBwYXRobmFtZSBhbmQgaWdub3JlIHRoZSBiYXNlXHJcbiAgICAvLyBsb2NhdGlvbi5wYXRobmFtZSBjb250YWlucyBhbiBpbml0aWFsIGAvYCBldmVuIGF0IHRoZSByb290OiBgaHR0cHM6Ly9leGFtcGxlLmNvbWBcclxuICAgIGJhc2UgPSBsb2NhdGlvbi5ob3N0ID8gYmFzZSB8fCBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCA6ICcnO1xyXG4gICAgLy8gYWxsb3cgdGhlIHVzZXIgdG8gcHJvdmlkZSBhIGAjYCBpbiB0aGUgbWlkZGxlOiBgL2Jhc2UvIy9hcHBgXHJcbiAgICBpZiAoIWJhc2UuaW5jbHVkZXMoJyMnKSlcclxuICAgICAgICBiYXNlICs9ICcjJztcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWJhc2UuZW5kc1dpdGgoJyMvJykgJiYgIWJhc2UuZW5kc1dpdGgoJyMnKSkge1xyXG4gICAgICAgIHdhcm4oYEEgaGFzaCBiYXNlIG11c3QgZW5kIHdpdGggYSBcIiNcIjpcXG5cIiR7YmFzZX1cIiBzaG91bGQgYmUgXCIke2Jhc2UucmVwbGFjZSgvIy4qJC8sICcjJyl9XCIuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlV2ViSGlzdG9yeShiYXNlKTtcclxufVxuXG5mdW5jdGlvbiBpc1JvdXRlTG9jYXRpb24ocm91dGUpIHtcclxuICAgIHJldHVybiB0eXBlb2Ygcm91dGUgPT09ICdzdHJpbmcnIHx8IChyb3V0ZSAmJiB0eXBlb2Ygcm91dGUgPT09ICdvYmplY3QnKTtcclxufVxyXG5mdW5jdGlvbiBpc1JvdXRlTmFtZShuYW1lKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuYW1lID09PSAnc3ltYm9sJztcclxufVxuXG4vKipcclxuICogSW5pdGlhbCByb3V0ZSBsb2NhdGlvbiB3aGVyZSB0aGUgcm91dGVyIGlzLiBDYW4gYmUgdXNlZCBpbiBuYXZpZ2F0aW9uIGd1YXJkc1xyXG4gKiB0byBkaWZmZXJlbnRpYXRlIHRoZSBpbml0aWFsIG5hdmlnYXRpb24uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGltcG9ydCB7IFNUQVJUX0xPQ0FUSU9OIH0gZnJvbSAndnVlLXJvdXRlcidcclxuICpcclxuICogcm91dGVyLmJlZm9yZUVhY2goKHRvLCBmcm9tKSA9PiB7XHJcbiAqICAgaWYgKGZyb20gPT09IFNUQVJUX0xPQ0FUSU9OKSB7XHJcbiAqICAgICAvLyBpbml0aWFsIG5hdmlnYXRpb25cclxuICogICB9XHJcbiAqIH0pXHJcbiAqIGBgYFxyXG4gKi9cclxuY29uc3QgU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRCA9IHtcclxuICAgIHBhdGg6ICcvJyxcclxuICAgIG5hbWU6IHVuZGVmaW5lZCxcclxuICAgIHBhcmFtczoge30sXHJcbiAgICBxdWVyeToge30sXHJcbiAgICBoYXNoOiAnJyxcclxuICAgIGZ1bGxQYXRoOiAnLycsXHJcbiAgICBtYXRjaGVkOiBbXSxcclxuICAgIG1ldGE6IHt9LFxyXG4gICAgcmVkaXJlY3RlZEZyb206IHVuZGVmaW5lZCxcclxufTtcblxuY29uc3QgTmF2aWdhdGlvbkZhaWx1cmVTeW1ib2wgPSAvKiNfX1BVUkVfXyovIFBvbHlTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ25hdmlnYXRpb24gZmFpbHVyZScgOiAnbmYnKTtcclxuLyoqXHJcbiAqIEVudW1lcmF0aW9uIHdpdGggYWxsIHBvc3NpYmxlIHR5cGVzIGZvciBuYXZpZ2F0aW9uIGZhaWx1cmVzLiBDYW4gYmUgcGFzc2VkIHRvXHJcbiAqIHtAbGluayBpc05hdmlnYXRpb25GYWlsdXJlfSB0byBjaGVjayBmb3Igc3BlY2lmaWMgZmFpbHVyZXMuXHJcbiAqL1xyXG52YXIgTmF2aWdhdGlvbkZhaWx1cmVUeXBlO1xyXG4oZnVuY3Rpb24gKE5hdmlnYXRpb25GYWlsdXJlVHlwZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhYm9ydGVkIG5hdmlnYXRpb24gaXMgYSBuYXZpZ2F0aW9uIHRoYXQgZmFpbGVkIGJlY2F1c2UgYSBuYXZpZ2F0aW9uXHJcbiAgICAgKiBndWFyZCByZXR1cm5lZCBgZmFsc2VgIG9yIGNhbGxlZCBgbmV4dChmYWxzZSlgXHJcbiAgICAgKi9cclxuICAgIE5hdmlnYXRpb25GYWlsdXJlVHlwZVtOYXZpZ2F0aW9uRmFpbHVyZVR5cGVbXCJhYm9ydGVkXCJdID0gNF0gPSBcImFib3J0ZWRcIjtcclxuICAgIC8qKlxyXG4gICAgICogQSBjYW5jZWxsZWQgbmF2aWdhdGlvbiBpcyBhIG5hdmlnYXRpb24gdGhhdCBmYWlsZWQgYmVjYXVzZSBhIG1vcmUgcmVjZW50XHJcbiAgICAgKiBuYXZpZ2F0aW9uIGZpbmlzaGVkIHN0YXJ0ZWQgKG5vdCBuZWNlc3NhcmlseSBmaW5pc2hlZCkuXHJcbiAgICAgKi9cclxuICAgIE5hdmlnYXRpb25GYWlsdXJlVHlwZVtOYXZpZ2F0aW9uRmFpbHVyZVR5cGVbXCJjYW5jZWxsZWRcIl0gPSA4XSA9IFwiY2FuY2VsbGVkXCI7XHJcbiAgICAvKipcclxuICAgICAqIEEgZHVwbGljYXRlZCBuYXZpZ2F0aW9uIGlzIGEgbmF2aWdhdGlvbiB0aGF0IGZhaWxlZCBiZWNhdXNlIGl0IHdhc1xyXG4gICAgICogaW5pdGlhdGVkIHdoaWxlIGFscmVhZHkgYmVpbmcgYXQgdGhlIGV4YWN0IHNhbWUgbG9jYXRpb24uXHJcbiAgICAgKi9cclxuICAgIE5hdmlnYXRpb25GYWlsdXJlVHlwZVtOYXZpZ2F0aW9uRmFpbHVyZVR5cGVbXCJkdXBsaWNhdGVkXCJdID0gMTZdID0gXCJkdXBsaWNhdGVkXCI7XHJcbn0pKE5hdmlnYXRpb25GYWlsdXJlVHlwZSB8fCAoTmF2aWdhdGlvbkZhaWx1cmVUeXBlID0ge30pKTtcclxuLy8gREVWIG9ubHkgZGVidWcgbWVzc2FnZXNcclxuY29uc3QgRXJyb3JUeXBlTWVzc2FnZXMgPSB7XHJcbiAgICBbMSAvKiBNQVRDSEVSX05PVF9GT1VORCAqL10oeyBsb2NhdGlvbiwgY3VycmVudExvY2F0aW9uIH0pIHtcclxuICAgICAgICByZXR1cm4gYE5vIG1hdGNoIGZvclxcbiAke0pTT04uc3RyaW5naWZ5KGxvY2F0aW9uKX0ke2N1cnJlbnRMb2NhdGlvblxyXG4gICAgICAgICAgICA/ICdcXG53aGlsZSBiZWluZyBhdFxcbicgKyBKU09OLnN0cmluZ2lmeShjdXJyZW50TG9jYXRpb24pXHJcbiAgICAgICAgICAgIDogJyd9YDtcclxuICAgIH0sXHJcbiAgICBbMiAvKiBOQVZJR0FUSU9OX0dVQVJEX1JFRElSRUNUICovXSh7IGZyb20sIHRvLCB9KSB7XHJcbiAgICAgICAgcmV0dXJuIGBSZWRpcmVjdGVkIGZyb20gXCIke2Zyb20uZnVsbFBhdGh9XCIgdG8gXCIke3N0cmluZ2lmeVJvdXRlKHRvKX1cIiB2aWEgYSBuYXZpZ2F0aW9uIGd1YXJkLmA7XHJcbiAgICB9LFxyXG4gICAgWzQgLyogTkFWSUdBVElPTl9BQk9SVEVEICovXSh7IGZyb20sIHRvIH0pIHtcclxuICAgICAgICByZXR1cm4gYE5hdmlnYXRpb24gYWJvcnRlZCBmcm9tIFwiJHtmcm9tLmZ1bGxQYXRofVwiIHRvIFwiJHt0by5mdWxsUGF0aH1cIiB2aWEgYSBuYXZpZ2F0aW9uIGd1YXJkLmA7XHJcbiAgICB9LFxyXG4gICAgWzggLyogTkFWSUdBVElPTl9DQU5DRUxMRUQgKi9dKHsgZnJvbSwgdG8gfSkge1xyXG4gICAgICAgIHJldHVybiBgTmF2aWdhdGlvbiBjYW5jZWxsZWQgZnJvbSBcIiR7ZnJvbS5mdWxsUGF0aH1cIiB0byBcIiR7dG8uZnVsbFBhdGh9XCIgd2l0aCBhIG5ldyBuYXZpZ2F0aW9uLmA7XHJcbiAgICB9LFxyXG4gICAgWzE2IC8qIE5BVklHQVRJT05fRFVQTElDQVRFRCAqL10oeyBmcm9tLCB0byB9KSB7XHJcbiAgICAgICAgcmV0dXJuIGBBdm9pZGVkIHJlZHVuZGFudCBuYXZpZ2F0aW9uIHRvIGN1cnJlbnQgbG9jYXRpb246IFwiJHtmcm9tLmZ1bGxQYXRofVwiLmA7XHJcbiAgICB9LFxyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJFcnJvcih0eXBlLCBwYXJhbXMpIHtcclxuICAgIC8vIGtlZXAgZnVsbCBlcnJvciBtZXNzYWdlcyBpbiBjanMgdmVyc2lvbnNcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWUpIHtcclxuICAgICAgICByZXR1cm4gYXNzaWduKG5ldyBFcnJvcihFcnJvclR5cGVNZXNzYWdlc1t0eXBlXShwYXJhbXMpKSwge1xyXG4gICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICBbTmF2aWdhdGlvbkZhaWx1cmVTeW1ib2xdOiB0cnVlLFxyXG4gICAgICAgIH0sIHBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYXNzaWduKG5ldyBFcnJvcigpLCB7XHJcbiAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgIFtOYXZpZ2F0aW9uRmFpbHVyZVN5bWJvbF06IHRydWUsXHJcbiAgICAgICAgfSwgcGFyYW1zKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc05hdmlnYXRpb25GYWlsdXJlKGVycm9yLCB0eXBlKSB7XHJcbiAgICByZXR1cm4gKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcclxuICAgICAgICBOYXZpZ2F0aW9uRmFpbHVyZVN5bWJvbCBpbiBlcnJvciAmJlxyXG4gICAgICAgICh0eXBlID09IG51bGwgfHwgISEoZXJyb3IudHlwZSAmIHR5cGUpKSk7XHJcbn1cclxuY29uc3QgcHJvcGVydGllc1RvTG9nID0gWydwYXJhbXMnLCAncXVlcnknLCAnaGFzaCddO1xyXG5mdW5jdGlvbiBzdHJpbmdpZnlSb3V0ZSh0bykge1xyXG4gICAgaWYgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgcmV0dXJuIHRvO1xyXG4gICAgaWYgKCdwYXRoJyBpbiB0bylcclxuICAgICAgICByZXR1cm4gdG8ucGF0aDtcclxuICAgIGNvbnN0IGxvY2F0aW9uID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBwcm9wZXJ0aWVzVG9Mb2cpIHtcclxuICAgICAgICBpZiAoa2V5IGluIHRvKVxyXG4gICAgICAgICAgICBsb2NhdGlvbltrZXldID0gdG9ba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShsb2NhdGlvbiwgbnVsbCwgMik7XHJcbn1cblxuLy8gZGVmYXVsdCBwYXR0ZXJuIGZvciBhIHBhcmFtOiBub24gZ3JlZWR5IGV2ZXJ5dGhpbmcgYnV0IC9cclxuY29uc3QgQkFTRV9QQVJBTV9QQVRURVJOID0gJ1teL10rPyc7XHJcbmNvbnN0IEJBU0VfUEFUSF9QQVJTRVJfT1BUSU9OUyA9IHtcclxuICAgIHNlbnNpdGl2ZTogZmFsc2UsXHJcbiAgICBzdHJpY3Q6IGZhbHNlLFxyXG4gICAgc3RhcnQ6IHRydWUsXHJcbiAgICBlbmQ6IHRydWUsXHJcbn07XHJcbi8vIFNwZWNpYWwgUmVnZXggY2hhcmFjdGVycyB0aGF0IG11c3QgYmUgZXNjYXBlZCBpbiBzdGF0aWMgdG9rZW5zXHJcbmNvbnN0IFJFR0VYX0NIQVJTX1JFID0gL1suKyo/XiR7fSgpW1xcXS9cXFxcXS9nO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHBhdGggcGFyc2VyIGZyb20gYW4gYXJyYXkgb2YgU2VnbWVudHMgKGEgc2VnbWVudCBpcyBhbiBhcnJheSBvZiBUb2tlbnMpXHJcbiAqXHJcbiAqIEBwYXJhbSBzZWdtZW50cyAtIGFycmF5IG9mIHNlZ21lbnRzIHJldHVybmVkIGJ5IHRva2VuaXplUGF0aFxyXG4gKiBAcGFyYW0gZXh0cmFPcHRpb25zIC0gb3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlZ2V4cFxyXG4gKiBAcmV0dXJucyBhIFBhdGhQYXJzZXJcclxuICovXHJcbmZ1bmN0aW9uIHRva2Vuc1RvUGFyc2VyKHNlZ21lbnRzLCBleHRyYU9wdGlvbnMpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBhc3NpZ24oe30sIEJBU0VfUEFUSF9QQVJTRVJfT1BUSU9OUywgZXh0cmFPcHRpb25zKTtcclxuICAgIC8vIHRoZSBhbW91bnQgb2Ygc2NvcmVzIGlzIHRoZSBzYW1lIGFzIHRoZSBsZW5ndGggb2Ygc2VnbWVudHMgZXhjZXB0IGZvciB0aGUgcm9vdCBzZWdtZW50IFwiL1wiXHJcbiAgICBsZXQgc2NvcmUgPSBbXTtcclxuICAgIC8vIHRoZSByZWdleHAgYXMgYSBzdHJpbmdcclxuICAgIGxldCBwYXR0ZXJuID0gb3B0aW9ucy5zdGFydCA/ICdeJyA6ICcnO1xyXG4gICAgLy8gZXh0cmFjdGVkIGtleXNcclxuICAgIGNvbnN0IGtleXMgPSBbXTtcclxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xyXG4gICAgICAgIC8vIHRoZSByb290IHNlZ21lbnQgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnRcclxuICAgICAgICBjb25zdCBzZWdtZW50U2NvcmVzID0gc2VnbWVudC5sZW5ndGggPyBbXSA6IFs5MCAvKiBSb290ICovXTtcclxuICAgICAgICAvLyBhbGxvdyB0cmFpbGluZyBzbGFzaFxyXG4gICAgICAgIGlmIChvcHRpb25zLnN0cmljdCAmJiAhc2VnbWVudC5sZW5ndGgpXHJcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gJy8nO1xyXG4gICAgICAgIGZvciAobGV0IHRva2VuSW5kZXggPSAwOyB0b2tlbkluZGV4IDwgc2VnbWVudC5sZW5ndGg7IHRva2VuSW5kZXgrKykge1xyXG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHNlZ21lbnRbdG9rZW5JbmRleF07XHJcbiAgICAgICAgICAgIC8vIHJlc2V0cyB0aGUgc2NvcmUgaWYgd2UgYXJlIGluc2lkZSBhIHN1YiBzZWdtZW50IC86YS1vdGhlci06YlxyXG4gICAgICAgICAgICBsZXQgc3ViU2VnbWVudFNjb3JlID0gNDAgLyogU2VnbWVudCAqLyArXHJcbiAgICAgICAgICAgICAgICAob3B0aW9ucy5zZW5zaXRpdmUgPyAwLjI1IC8qIEJvbnVzQ2FzZVNlbnNpdGl2ZSAqLyA6IDApO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMCAvKiBTdGF0aWMgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHByZXBlbmQgdGhlIHNsYXNoIGlmIHdlIGFyZSBzdGFydGluZyBhIG5ldyBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuSW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiArPSAnLyc7XHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHRva2VuLnZhbHVlLnJlcGxhY2UoUkVHRVhfQ0hBUlNfUkUsICdcXFxcJCYnKTtcclxuICAgICAgICAgICAgICAgIHN1YlNlZ21lbnRTY29yZSArPSA0MCAvKiBTdGF0aWMgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gMSAvKiBQYXJhbSAqLykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgcmVwZWF0YWJsZSwgb3B0aW9uYWwsIHJlZ2V4cCB9ID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdGFibGUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWwsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlID0gcmVnZXhwID8gcmVnZXhwIDogQkFTRV9QQVJBTV9QQVRURVJOO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVzZXIgcHJvdmlkZWQgYSBjdXN0b20gcmVnZXhwIC86aWQoXFxcXGQrKVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlICE9PSBCQVNFX1BBUkFNX1BBVFRFUk4pIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWJTZWdtZW50U2NvcmUgKz0gMTAgLyogQm9udXNDdXN0b21SZWdFeHAgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSByZWdleHAgaXMgdmFsaWQgYmVmb3JlIHVzaW5nIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChgKCR7cmV9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjdXN0b20gUmVnRXhwIGZvciBwYXJhbSBcIiR7dmFsdWV9XCIgKCR7cmV9KTogYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB3ZSByZXBlYXQgd2UgbXVzdCB0YWtlIGNhcmUgb2YgdGhlIHJlcGVhdGluZyBsZWFkaW5nIHNsYXNoXHJcbiAgICAgICAgICAgICAgICBsZXQgc3ViUGF0dGVybiA9IHJlcGVhdGFibGUgPyBgKCg/OiR7cmV9KSg/Oi8oPzoke3JlfSkpKilgIDogYCgke3JlfSlgO1xyXG4gICAgICAgICAgICAgICAgLy8gcHJlcGVuZCB0aGUgc2xhc2ggaWYgd2UgYXJlIHN0YXJ0aW5nIGEgbmV3IHNlZ21lbnRcclxuICAgICAgICAgICAgICAgIGlmICghdG9rZW5JbmRleClcclxuICAgICAgICAgICAgICAgICAgICBzdWJQYXR0ZXJuID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgYW4gb3B0aW9uYWwgLyBpZiB0aGVyZSBhcmUgbW9yZSBzZWdtZW50cyBlLmcuIC86cD8tc3RhdGljXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIC86cD8tOnAyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsICYmIHNlZ21lbnQubGVuZ3RoIDwgMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgKD86LyR7c3ViUGF0dGVybn0pYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnLycgKyBzdWJQYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIHN1YlBhdHRlcm4gKz0gJz8nO1xyXG4gICAgICAgICAgICAgICAgcGF0dGVybiArPSBzdWJQYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgc3ViU2VnbWVudFNjb3JlICs9IDIwIC8qIER5bmFtaWMgKi87XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViU2VnbWVudFNjb3JlICs9IC04IC8qIEJvbnVzT3B0aW9uYWwgKi87XHJcbiAgICAgICAgICAgICAgICBpZiAocmVwZWF0YWJsZSlcclxuICAgICAgICAgICAgICAgICAgICBzdWJTZWdtZW50U2NvcmUgKz0gLTIwIC8qIEJvbnVzUmVwZWF0YWJsZSAqLztcclxuICAgICAgICAgICAgICAgIGlmIChyZSA9PT0gJy4qJylcclxuICAgICAgICAgICAgICAgICAgICBzdWJTZWdtZW50U2NvcmUgKz0gLTUwIC8qIEJvbnVzV2lsZGNhcmQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VnbWVudFNjb3Jlcy5wdXNoKHN1YlNlZ21lbnRTY29yZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFuIGVtcHR5IGFycmF5IGxpa2UgL2hvbWUvIC0+IFtbe2hvbWV9XSwgW11dXHJcbiAgICAgICAgLy8gaWYgKCFzZWdtZW50Lmxlbmd0aCkgcGF0dGVybiArPSAnLydcclxuICAgICAgICBzY29yZS5wdXNoKHNlZ21lbnRTY29yZXMpO1xyXG4gICAgfVxyXG4gICAgLy8gb25seSBhcHBseSB0aGUgc3RyaWN0IGJvbnVzIHRvIHRoZSBsYXN0IHNjb3JlXHJcbiAgICBpZiAob3B0aW9ucy5zdHJpY3QgJiYgb3B0aW9ucy5lbmQpIHtcclxuICAgICAgICBjb25zdCBpID0gc2NvcmUubGVuZ3RoIC0gMTtcclxuICAgICAgICBzY29yZVtpXVtzY29yZVtpXS5sZW5ndGggLSAxXSArPSAwLjcwMDAwMDAwMDAwMDAwMDEgLyogQm9udXNTdHJpY3QgKi87XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBkZXYgb25seSB3YXJuIGRvdWJsZSB0cmFpbGluZyBzbGFzaFxyXG4gICAgaWYgKCFvcHRpb25zLnN0cmljdClcclxuICAgICAgICBwYXR0ZXJuICs9ICcvPyc7XHJcbiAgICBpZiAob3B0aW9ucy5lbmQpXHJcbiAgICAgICAgcGF0dGVybiArPSAnJCc7XHJcbiAgICAvLyBhbGxvdyBwYXRocyBsaWtlIC9keW5hbWljIHRvIG9ubHkgbWF0Y2ggZHluYW1pYyBvciBkeW5hbWljLy4uLiBidXQgbm90IGR5bmFtaWNfc29tZXRoaW5nX2Vsc2VcclxuICAgIGVsc2UgaWYgKG9wdGlvbnMuc3RyaWN0KVxyXG4gICAgICAgIHBhdHRlcm4gKz0gJyg/Oi98JCknO1xyXG4gICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaScpO1xyXG4gICAgZnVuY3Rpb24gcGFyc2UocGF0aCkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gcGF0aC5tYXRjaChyZSk7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge307XHJcbiAgICAgICAgaWYgKCFtYXRjaClcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtYXRjaC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1hdGNoW2ldIHx8ICcnO1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2kgLSAxXTtcclxuICAgICAgICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IHZhbHVlICYmIGtleS5yZXBlYXRhYmxlID8gdmFsdWUuc3BsaXQoJy8nKSA6IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KHBhcmFtcykge1xyXG4gICAgICAgIGxldCBwYXRoID0gJyc7XHJcbiAgICAgICAgLy8gZm9yIG9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gYWxsb3cgdG8gYmUgZW1wdHlcclxuICAgICAgICBsZXQgYXZvaWREdXBsaWNhdGVkU2xhc2ggPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcclxuICAgICAgICAgICAgaWYgKCFhdm9pZER1cGxpY2F0ZWRTbGFzaCB8fCAhcGF0aC5lbmRzV2l0aCgnLycpKVxyXG4gICAgICAgICAgICAgICAgcGF0aCArPSAnLyc7XHJcbiAgICAgICAgICAgIGF2b2lkRHVwbGljYXRlZFNsYXNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2Ygc2VnbWVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDAgLyogU3RhdGljICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDEgLyogUGFyYW0gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCByZXBlYXRhYmxlLCBvcHRpb25hbCB9ID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW0gPSB2YWx1ZSBpbiBwYXJhbXMgPyBwYXJhbXNbdmFsdWVdIDogJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0pICYmICFyZXBlYXRhYmxlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVkIHBhcmFtIFwiJHt2YWx1ZX1cIiBpcyBhbiBhcnJheSBidXQgaXQgaXMgbm90IHJlcGVhdGFibGUgKCogb3IgKyBtb2RpZmllcnMpYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IEFycmF5LmlzQXJyYXkocGFyYW0pID8gcGFyYW0uam9pbignLycpIDogcGFyYW07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lIG9wdGlvbmFsIHBhcmFtIGxpa2UgLzphPy1zdGF0aWMgd2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IG5lZWQgdG8gY2FyZSBhYm91dCB0aGUgb3B0aW9uYWwgcGFyYW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGxhc3Qgc2xhc2ggYXMgd2UgY291bGQgYmUgYXQgdGhlIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoLmVuZHNXaXRoKCcvJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgYXBwZW5kIGEgc2xhc2ggb24gdGhlIG5leHQgaXRlcmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdm9pZER1cGxpY2F0ZWRTbGFzaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVpcmVkIHBhcmFtIFwiJHt2YWx1ZX1cImApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IHRleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlLFxyXG4gICAgICAgIHNjb3JlLFxyXG4gICAgICAgIGtleXMsXHJcbiAgICAgICAgcGFyc2UsXHJcbiAgICAgICAgc3RyaW5naWZ5LFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQ29tcGFyZXMgYW4gYXJyYXkgb2YgbnVtYmVycyBhcyB1c2VkIGluIFBhdGhQYXJzZXIuc2NvcmUgYW5kIHJldHVybnMgYVxyXG4gKiBudW1iZXIuIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gYHNvcnRgIGFuIGFycmF5XHJcbiAqIEBwYXJhbSBhIC0gZmlyc3QgYXJyYXkgb2YgbnVtYmVyc1xyXG4gKiBAcGFyYW0gYiAtIHNlY29uZCBhcnJheSBvZiBudW1iZXJzXHJcbiAqIEByZXR1cm5zIDAgaWYgYm90aCBhcmUgZXF1YWwsIDwgMCBpZiBhIHNob3VsZCBiZSBzb3J0ZWQgZmlyc3QsID4gMCBpZiBiXHJcbiAqIHNob3VsZCBiZSBzb3J0ZWQgZmlyc3RcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBhcmVTY29yZUFycmF5KGEsIGIpIHtcclxuICAgIGxldCBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgYS5sZW5ndGggJiYgaSA8IGIubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgZGlmZiA9IGJbaV0gLSBhW2ldO1xyXG4gICAgICAgIC8vIG9ubHkga2VlcCBnb2luZyBpZiBkaWZmID09PSAwXHJcbiAgICAgICAgaWYgKGRpZmYpXHJcbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuICAgIC8vIGlmIHRoZSBsYXN0IHN1YnNlZ21lbnQgd2FzIFN0YXRpYywgdGhlIHNob3J0ZXIgc2VnbWVudHMgc2hvdWxkIGJlIHNvcnRlZCBmaXJzdFxyXG4gICAgLy8gb3RoZXJ3aXNlIHNvcnQgdGhlIGxvbmdlc3Qgc2VnbWVudCBmaXJzdFxyXG4gICAgaWYgKGEubGVuZ3RoIDwgYi5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IDEgJiYgYVswXSA9PT0gNDAgLyogU3RhdGljICovICsgNDAgLyogU2VnbWVudCAqL1xyXG4gICAgICAgICAgICA/IC0xXHJcbiAgICAgICAgICAgIDogMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGEubGVuZ3RoID4gYi5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gYi5sZW5ndGggPT09IDEgJiYgYlswXSA9PT0gNDAgLyogU3RhdGljICovICsgNDAgLyogU2VnbWVudCAqL1xyXG4gICAgICAgICAgICA/IDFcclxuICAgICAgICAgICAgOiAtMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wYXJlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBgc29ydGAgdG8gc29ydCBhbiBhcnJheSBvZiBQYXRoUGFyc2VyXHJcbiAqIEBwYXJhbSBhIC0gZmlyc3QgUGF0aFBhcnNlclxyXG4gKiBAcGFyYW0gYiAtIHNlY29uZCBQYXRoUGFyc2VyXHJcbiAqIEByZXR1cm5zIDAgaWYgYm90aCBhcmUgZXF1YWwsIDwgMCBpZiBhIHNob3VsZCBiZSBzb3J0ZWQgZmlyc3QsID4gMCBpZiBiXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wYXJlUGF0aFBhcnNlclNjb3JlKGEsIGIpIHtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGNvbnN0IGFTY29yZSA9IGEuc2NvcmU7XHJcbiAgICBjb25zdCBiU2NvcmUgPSBiLnNjb3JlO1xyXG4gICAgd2hpbGUgKGkgPCBhU2NvcmUubGVuZ3RoICYmIGkgPCBiU2NvcmUubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgY29tcCA9IGNvbXBhcmVTY29yZUFycmF5KGFTY29yZVtpXSwgYlNjb3JlW2ldKTtcclxuICAgICAgICAvLyBkbyBub3QgcmV0dXJuIGlmIGJvdGggYXJlIGVxdWFsXHJcbiAgICAgICAgaWYgKGNvbXApXHJcbiAgICAgICAgICAgIHJldHVybiBjb21wO1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuICAgIC8vIGlmIGEgYW5kIGIgc2hhcmUgdGhlIHNhbWUgc2NvcmUgZW50cmllcyBidXQgYiBoYXMgbW9yZSwgc29ydCBiIGZpcnN0XHJcbiAgICByZXR1cm4gYlNjb3JlLmxlbmd0aCAtIGFTY29yZS5sZW5ndGg7XHJcbiAgICAvLyB0aGlzIGlzIHRoZSB0ZXJuYXJ5IHZlcnNpb25cclxuICAgIC8vIHJldHVybiBhU2NvcmUubGVuZ3RoIDwgYlNjb3JlLmxlbmd0aFxyXG4gICAgLy8gICA/IDFcclxuICAgIC8vICAgOiBhU2NvcmUubGVuZ3RoID4gYlNjb3JlLmxlbmd0aFxyXG4gICAgLy8gICA/IC0xXHJcbiAgICAvLyAgIDogMFxyXG59XG5cbmNvbnN0IFJPT1RfVE9LRU4gPSB7XHJcbiAgICB0eXBlOiAwIC8qIFN0YXRpYyAqLyxcclxuICAgIHZhbHVlOiAnJyxcclxufTtcclxuY29uc3QgVkFMSURfUEFSQU1fUkUgPSAvW2EtekEtWjAtOV9dLztcclxuLy8gQWZ0ZXIgc29tZSBwcm9maWxpbmcsIHRoZSBjYWNoZSBzZWVtcyB0byBiZSB1bm5lY2Vzc2FyeSBiZWNhdXNlIHRva2VuaXplUGF0aFxyXG4vLyAodGhlIHNsb3dlc3QgcGFydCBvZiBhZGRpbmcgYSByb3V0ZSkgaXMgdmVyeSBmYXN0XHJcbi8vIGNvbnN0IHRva2VuQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgVG9rZW5bXVtdPigpXHJcbmZ1bmN0aW9uIHRva2VuaXplUGF0aChwYXRoKSB7XHJcbiAgICBpZiAoIXBhdGgpXHJcbiAgICAgICAgcmV0dXJuIFtbXV07XHJcbiAgICBpZiAocGF0aCA9PT0gJy8nKVxyXG4gICAgICAgIHJldHVybiBbW1JPT1RfVE9LRU5dXTtcclxuICAgIGlmICghcGF0aC5zdGFydHNXaXRoKCcvJykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgID8gYFJvdXRlIHBhdGhzIHNob3VsZCBzdGFydCB3aXRoIGEgXCIvXCI6IFwiJHtwYXRofVwiIHNob3VsZCBiZSBcIi8ke3BhdGh9XCIuYFxyXG4gICAgICAgICAgICA6IGBJbnZhbGlkIHBhdGggXCIke3BhdGh9XCJgKTtcclxuICAgIH1cclxuICAgIC8vIGlmICh0b2tlbkNhY2hlLmhhcyhwYXRoKSkgcmV0dXJuIHRva2VuQ2FjaGUuZ2V0KHBhdGgpIVxyXG4gICAgZnVuY3Rpb24gY3Jhc2gobWVzc2FnZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRVJSICgke3N0YXRlfSkvXCIke2J1ZmZlcn1cIjogJHttZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gICAgbGV0IHN0YXRlID0gMCAvKiBTdGF0aWMgKi87XHJcbiAgICBsZXQgcHJldmlvdXNTdGF0ZSA9IHN0YXRlO1xyXG4gICAgY29uc3QgdG9rZW5zID0gW107XHJcbiAgICAvLyB0aGUgc2VnbWVudCB3aWxsIGFsd2F5cyBiZSB2YWxpZCBiZWNhdXNlIHdlIGdldCBpbnRvIHRoZSBpbml0aWFsIHN0YXRlXHJcbiAgICAvLyB3aXRoIHRoZSBsZWFkaW5nIC9cclxuICAgIGxldCBzZWdtZW50O1xyXG4gICAgZnVuY3Rpb24gZmluYWxpemVTZWdtZW50KCkge1xyXG4gICAgICAgIGlmIChzZWdtZW50KVxyXG4gICAgICAgICAgICB0b2tlbnMucHVzaChzZWdtZW50KTtcclxuICAgICAgICBzZWdtZW50ID0gW107XHJcbiAgICB9XHJcbiAgICAvLyBpbmRleCBvbiB0aGUgcGF0aFxyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgLy8gY2hhciBhdCBpbmRleFxyXG4gICAgbGV0IGNoYXI7XHJcbiAgICAvLyBidWZmZXIgb2YgdGhlIHZhbHVlIHJlYWRcclxuICAgIGxldCBidWZmZXIgPSAnJztcclxuICAgIC8vIGN1c3RvbSByZWdleHAgZm9yIGEgcGFyYW1cclxuICAgIGxldCBjdXN0b21SZSA9ICcnO1xyXG4gICAgZnVuY3Rpb24gY29uc3VtZUJ1ZmZlcigpIHtcclxuICAgICAgICBpZiAoIWJ1ZmZlcilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gMCAvKiBTdGF0aWMgKi8pIHtcclxuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDAgLyogU3RhdGljICovLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGJ1ZmZlcixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAxIC8qIFBhcmFtICovIHx8XHJcbiAgICAgICAgICAgIHN0YXRlID09PSAyIC8qIFBhcmFtUmVnRXhwICovIHx8XHJcbiAgICAgICAgICAgIHN0YXRlID09PSAzIC8qIFBhcmFtUmVnRXhwRW5kICovKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEgJiYgKGNoYXIgPT09ICcqJyB8fCBjaGFyID09PSAnKycpKVxyXG4gICAgICAgICAgICAgICAgY3Jhc2goYEEgcmVwZWF0YWJsZSBwYXJhbSAoJHtidWZmZXJ9KSBtdXN0IGJlIGFsb25lIGluIGl0cyBzZWdtZW50LiBlZzogJy86aWRzKy5gKTtcclxuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDEgLyogUGFyYW0gKi8sXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogYnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgcmVnZXhwOiBjdXN0b21SZSxcclxuICAgICAgICAgICAgICAgIHJlcGVhdGFibGU6IGNoYXIgPT09ICcqJyB8fCBjaGFyID09PSAnKycsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogY2hhciA9PT0gJyonIHx8IGNoYXIgPT09ICc/JyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjcmFzaCgnSW52YWxpZCBzdGF0ZSB0byBjb25zdW1lIGJ1ZmZlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBidWZmZXIgPSAnJztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFkZENoYXJUb0J1ZmZlcigpIHtcclxuICAgICAgICBidWZmZXIgKz0gY2hhcjtcclxuICAgIH1cclxuICAgIHdoaWxlIChpIDwgcGF0aC5sZW5ndGgpIHtcclxuICAgICAgICBjaGFyID0gcGF0aFtpKytdO1xyXG4gICAgICAgIGlmIChjaGFyID09PSAnXFxcXCcgJiYgc3RhdGUgIT09IDIgLyogUGFyYW1SZWdFeHAgKi8pIHtcclxuICAgICAgICAgICAgcHJldmlvdXNTdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICBzdGF0ZSA9IDQgLyogRXNjYXBlTmV4dCAqLztcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcclxuICAgICAgICAgICAgY2FzZSAwIC8qIFN0YXRpYyAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN1bWVCdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemVTZWdtZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnOicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdW1lQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxIC8qIFBhcmFtICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2hhclRvQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0IC8qIEVzY2FwZU5leHQgKi86XHJcbiAgICAgICAgICAgICAgICBhZGRDaGFyVG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogUGFyYW0gKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJygnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAyIC8qIFBhcmFtUmVnRXhwICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoVkFMSURfUEFSQU1fUkUudGVzdChjaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZENoYXJUb0J1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3VtZUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMCAvKiBTdGF0aWMgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ28gYmFjayBvbmUgY2hhcmFjdGVyIGlmIHdlIHdlcmUgbm90IG1vZGlmeWluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyICE9PSAnKicgJiYgY2hhciAhPT0gJz8nICYmIGNoYXIgIT09ICcrJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMiAvKiBQYXJhbVJlZ0V4cCAqLzpcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlzIGl0IHdvcnRoIGhhbmRsaW5nIG5lc3RlZCByZWdleHA/IGxpa2UgOnAoPzpwcmVmaXhfKFteL10rKV9zdWZmaXgpXHJcbiAgICAgICAgICAgICAgICAvLyBpdCBhbHJlYWR5IHdvcmtzIGJ5IGVzY2FwaW5nIHRoZSBjbG9zaW5nIClcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcGF0aHMuZXNtLmRldi8/cD1BQU1lSmJpQXdRRWNES2JBb0FBa1A2MFBHMlI2UUF2Z05hQTZBRkFDTTJBQnVRQkIjXHJcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGlzIHJlYWxseSBzb21ldGhpbmcgcGVvcGxlIG5lZWQgc2luY2UgeW91IGNhbiBhbHNvIHdyaXRlXHJcbiAgICAgICAgICAgICAgICAvLyAvcHJlZml4XzpwKClfc3VmZml4XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJyknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBlc2NhcGVkIClcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tUmVbY3VzdG9tUmUubGVuZ3RoIC0gMV0gPT0gJ1xcXFwnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21SZSA9IGN1c3RvbVJlLnNsaWNlKDAsIC0xKSArIGNoYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDMgLyogUGFyYW1SZWdFeHBFbmQgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXN0b21SZSArPSBjaGFyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMyAvKiBQYXJhbVJlZ0V4cEVuZCAqLzpcclxuICAgICAgICAgICAgICAgIC8vIHNhbWUgYXMgZmluYWxpemluZyBhIHBhcmFtXHJcbiAgICAgICAgICAgICAgICBjb25zdW1lQnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDAgLyogU3RhdGljICovO1xyXG4gICAgICAgICAgICAgICAgLy8gZ28gYmFjayBvbmUgY2hhcmFjdGVyIGlmIHdlIHdlcmUgbm90IG1vZGlmeWluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgIT09ICcqJyAmJiBjaGFyICE9PSAnPycgJiYgY2hhciAhPT0gJysnKVxyXG4gICAgICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgIGN1c3RvbVJlID0gJyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNyYXNoKCdVbmtub3duIHN0YXRlJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhdGUgPT09IDIgLyogUGFyYW1SZWdFeHAgKi8pXHJcbiAgICAgICAgY3Jhc2goYFVuZmluaXNoZWQgY3VzdG9tIFJlZ0V4cCBmb3IgcGFyYW0gXCIke2J1ZmZlcn1cImApO1xyXG4gICAgY29uc3VtZUJ1ZmZlcigpO1xyXG4gICAgZmluYWxpemVTZWdtZW50KCk7XHJcbiAgICAvLyB0b2tlbkNhY2hlLnNldChwYXRoLCB0b2tlbnMpXHJcbiAgICByZXR1cm4gdG9rZW5zO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlUmVjb3JkTWF0Y2hlcihyZWNvcmQsIHBhcmVudCwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgcGFyc2VyID0gdG9rZW5zVG9QYXJzZXIodG9rZW5pemVQYXRoKHJlY29yZC5wYXRoKSwgb3B0aW9ucyk7XHJcbiAgICAvLyB3YXJuIGFnYWluc3QgcGFyYW1zIHdpdGggdGhlIHNhbWUgbmFtZVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IG5ldyBTZXQoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXJzZXIua2V5cykge1xyXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdLZXlzLmhhcyhrZXkubmFtZSkpXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBGb3VuZCBkdXBsaWNhdGVkIHBhcmFtcyB3aXRoIG5hbWUgXCIke2tleS5uYW1lfVwiIGZvciBwYXRoIFwiJHtyZWNvcmQucGF0aH1cIi4gT25seSB0aGUgbGFzdCBvbmUgd2lsbCBiZSBhdmFpbGFibGUgb24gXCIkcm91dGUucGFyYW1zXCIuYCk7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nS2V5cy5hZGQoa2V5Lm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG1hdGNoZXIgPSBhc3NpZ24ocGFyc2VyLCB7XHJcbiAgICAgICAgcmVjb3JkLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICAvLyB0aGVzZSBuZWVkcyB0byBiZSBwb3B1bGF0ZWQgYnkgdGhlIHBhcmVudFxyXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcclxuICAgICAgICBhbGlhczogW10sXHJcbiAgICB9KTtcclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAvLyBib3RoIGFyZSBhbGlhc2VzIG9yIGJvdGggYXJlIG5vdCBhbGlhc2VzXHJcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBtaXggdGhlbSBiZWNhdXNlIHRoZSBvcmRlciBpcyB1c2VkIHdoZW5cclxuICAgICAgICAvLyBwYXNzaW5nIG9yaWdpbmFsUmVjb3JkIGluIE1hdGNoZXIuYWRkUm91dGVcclxuICAgICAgICBpZiAoIW1hdGNoZXIucmVjb3JkLmFsaWFzT2YgPT09ICFwYXJlbnQucmVjb3JkLmFsaWFzT2YpXHJcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG1hdGNoZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hdGNoZXI7XHJcbn1cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBSb3V0ZXIgTWF0Y2hlci5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSByb3V0ZXMgLSBhcnJheSBvZiBpbml0aWFsIHJvdXRlc1xyXG4gKiBAcGFyYW0gZ2xvYmFsT3B0aW9ucyAtIGdsb2JhbCByb3V0ZSBvcHRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJNYXRjaGVyKHJvdXRlcywgZ2xvYmFsT3B0aW9ucykge1xyXG4gICAgLy8gbm9ybWFsaXplZCBvcmRlcmVkIGFycmF5IG9mIG1hdGNoZXJzXHJcbiAgICBjb25zdCBtYXRjaGVycyA9IFtdO1xyXG4gICAgY29uc3QgbWF0Y2hlck1hcCA9IG5ldyBNYXAoKTtcclxuICAgIGdsb2JhbE9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoeyBzdHJpY3Q6IGZhbHNlLCBlbmQ6IHRydWUsIHNlbnNpdGl2ZTogZmFsc2UgfSwgZ2xvYmFsT3B0aW9ucyk7XHJcbiAgICBmdW5jdGlvbiBnZXRSZWNvcmRNYXRjaGVyKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlck1hcC5nZXQobmFtZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRSb3V0ZShyZWNvcmQsIHBhcmVudCwgb3JpZ2luYWxSZWNvcmQpIHtcclxuICAgICAgICAvLyB1c2VkIGxhdGVyIG9uIHRvIHJlbW92ZSBieSBuYW1lXHJcbiAgICAgICAgbGV0IGlzUm9vdEFkZCA9ICFvcmlnaW5hbFJlY29yZDtcclxuICAgICAgICBsZXQgbWFpbk5vcm1hbGl6ZWRSZWNvcmQgPSBub3JtYWxpemVSb3V0ZVJlY29yZChyZWNvcmQpO1xyXG4gICAgICAgIC8vIHdlIG1pZ2h0IGJlIHRoZSBjaGlsZCBvZiBhbiBhbGlhc1xyXG4gICAgICAgIG1haW5Ob3JtYWxpemVkUmVjb3JkLmFsaWFzT2YgPSBvcmlnaW5hbFJlY29yZCAmJiBvcmlnaW5hbFJlY29yZC5yZWNvcmQ7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhnbG9iYWxPcHRpb25zLCByZWNvcmQpO1xyXG4gICAgICAgIC8vIGdlbmVyYXRlIGFuIGFycmF5IG9mIHJlY29yZHMgdG8gY29ycmVjdGx5IGhhbmRsZSBhbGlhc2VzXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFJlY29yZHMgPSBbXHJcbiAgICAgICAgICAgIG1haW5Ob3JtYWxpemVkUmVjb3JkLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKCdhbGlhcycgaW4gcmVjb3JkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFsaWFzZXMgPSB0eXBlb2YgcmVjb3JkLmFsaWFzID09PSAnc3RyaW5nJyA/IFtyZWNvcmQuYWxpYXNdIDogcmVjb3JkLmFsaWFzO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGFsaWFzZXMpIHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRSZWNvcmRzLnB1c2goYXNzaWduKHt9LCBtYWluTm9ybWFsaXplZFJlY29yZCwge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYWxsb3dzIHVzIHRvIGhvbGQgYSBjb3B5IG9mIHRoZSBgY29tcG9uZW50c2Agb3B0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhhdCBhc3luYyBjb21wb25lbnRzIGNhY2hlIGlzIGhvbGQgb24gdGhlIG9yaWdpbmFsIHJlY29yZFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IG9yaWdpbmFsUmVjb3JkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gb3JpZ2luYWxSZWNvcmQucmVjb3JkLmNvbXBvbmVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBtYWluTm9ybWFsaXplZFJlY29yZC5jb21wb25lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGFsaWFzLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGJlIHRoZSBjaGlsZCBvZiBhbiBhbGlhc1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzT2Y6IG9yaWdpbmFsUmVjb3JkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gb3JpZ2luYWxSZWNvcmQucmVjb3JkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbWFpbk5vcm1hbGl6ZWRSZWNvcmQsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFsaWFzZXMgYXJlIGFsd2F5cyBvZiB0aGUgc2FtZSBraW5kIGFzIHRoZSBvcmlnaW5hbCBzaW5jZSB0aGV5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgcmVjb3JkXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG1hdGNoZXI7XHJcbiAgICAgICAgbGV0IG9yaWdpbmFsTWF0Y2hlcjtcclxuICAgICAgICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRSZWNvcmQgb2Ygbm9ybWFsaXplZFJlY29yZHMpIHtcclxuICAgICAgICAgICAgbGV0IHsgcGF0aCB9ID0gbm9ybWFsaXplZFJlY29yZDtcclxuICAgICAgICAgICAgLy8gQnVpbGQgdXAgdGhlIHBhdGggZm9yIG5lc3RlZCByb3V0ZXMgaWYgdGhlIGNoaWxkIGlzbid0IGFuIGFic29sdXRlXHJcbiAgICAgICAgICAgIC8vIHJvdXRlLiBPbmx5IGFkZCB0aGUgLyBkZWxpbWl0ZXIgaWYgdGhlIGNoaWxkIHBhdGggaXNuJ3QgZW1wdHkgYW5kIGlmIHRoZVxyXG4gICAgICAgICAgICAvLyBwYXJlbnQgcGF0aCBkb2Vzbid0IGhhdmUgYSB0cmFpbGluZyBzbGFzaFxyXG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhdGhbMF0gIT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudFBhdGggPSBwYXJlbnQucmVjb3JkLnBhdGg7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29ubmVjdGluZ1NsYXNoID0gcGFyZW50UGF0aFtwYXJlbnRQYXRoLmxlbmd0aCAtIDFdID09PSAnLycgPyAnJyA6ICcvJztcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRSZWNvcmQucGF0aCA9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlY29yZC5wYXRoICsgKHBhdGggJiYgY29ubmVjdGluZ1NsYXNoICsgcGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBub3JtYWxpemVkUmVjb3JkLnBhdGggPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXRjaCBhbGwgcm91dGVzIChcIipcIikgbXVzdCBub3cgYmUgZGVmaW5lZCB1c2luZyBhIHBhcmFtIHdpdGggYSBjdXN0b20gcmVnZXhwLlxcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgICdTZWUgbW9yZSBhdCBodHRwczovL25leHQucm91dGVyLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vI3JlbW92ZWQtc3Rhci1vci1jYXRjaC1hbGwtcm91dGVzLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgb2JqZWN0IGJlZm9yZSBoYW5kIHNvIGl0IGNhbiBiZSBwYXNzZWQgdG8gY2hpbGRyZW5cclxuICAgICAgICAgICAgbWF0Y2hlciA9IGNyZWF0ZVJvdXRlUmVjb3JkTWF0Y2hlcihub3JtYWxpemVkUmVjb3JkLCBwYXJlbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHBhcmVudCAmJiBwYXRoWzBdID09PSAnLycpXHJcbiAgICAgICAgICAgICAgICBjaGVja01pc3NpbmdQYXJhbXNJbkFic29sdXRlUGF0aChtYXRjaGVyLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgYW4gYWxpYXMgd2UgbXVzdCB0ZWxsIHRoZSBvcmlnaW5hbCByZWNvcmQgdGhhdCB3ZSBleGlzdFxyXG4gICAgICAgICAgICAvLyBzbyB3ZSBjYW4gYmUgcmVtb3ZlZFxyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxSZWNvcmQpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUmVjb3JkLmFsaWFzLnB1c2gobWF0Y2hlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tTYW1lUGFyYW1zKG9yaWdpbmFsUmVjb3JkLCBtYXRjaGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgdGhlIGZpcnN0IHJlY29yZCBpcyB0aGUgb3JpZ2luYWwgYW5kIG90aGVycyBhcmUgYWxpYXNlc1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxNYXRjaGVyID0gb3JpZ2luYWxNYXRjaGVyIHx8IG1hdGNoZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxNYXRjaGVyICE9PSBtYXRjaGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsTWF0Y2hlci5hbGlhcy5wdXNoKG1hdGNoZXIpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSByb3V0ZSBpZiBuYW1lZCBhbmQgb25seSBmb3IgdGhlIHRvcCByZWNvcmQgKGF2b2lkIGluIG5lc3RlZCBjYWxscylcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgd29ya3MgYmVjYXVzZSB0aGUgb3JpZ2luYWwgcmVjb3JkIGlzIHRoZSBmaXJzdCBvbmVcclxuICAgICAgICAgICAgICAgIGlmIChpc1Jvb3RBZGQgJiYgcmVjb3JkLm5hbWUgJiYgIWlzQWxpYXNSZWNvcmQobWF0Y2hlcikpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlUm91dGUocmVjb3JkLm5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgnY2hpbGRyZW4nIGluIG1haW5Ob3JtYWxpemVkUmVjb3JkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBtYWluTm9ybWFsaXplZFJlY29yZC5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRSb3V0ZShjaGlsZHJlbltpXSwgbWF0Y2hlciwgb3JpZ2luYWxSZWNvcmQgJiYgb3JpZ2luYWxSZWNvcmQuY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBubyBvcmlnaW5hbCByZWNvcmQsIHRoZW4gdGhlIGZpcnN0IG9uZSB3YXMgbm90IGFuIGFsaWFzIGFuZCBhbGxcclxuICAgICAgICAgICAgLy8gb3RoZXIgYWxpYXMgKGlmIGFueSkgbmVlZCB0byByZWZlcmVuY2UgdGhpcyByZWNvcmQgd2hlbiBhZGRpbmcgY2hpbGRyZW5cclxuICAgICAgICAgICAgb3JpZ2luYWxSZWNvcmQgPSBvcmlnaW5hbFJlY29yZCB8fCBtYXRjaGVyO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBhZGQgbm9ybWFsaXplZCByZWNvcmRzIGZvciBtb3JlIGZsZXhpYmlsaXR5XHJcbiAgICAgICAgICAgIC8vIGlmIChwYXJlbnQgJiYgaXNBbGlhc1JlY29yZChvcmlnaW5hbFJlY29yZCkpIHtcclxuICAgICAgICAgICAgLy8gICBwYXJlbnQuY2hpbGRyZW4ucHVzaChvcmlnaW5hbFJlY29yZClcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICBpbnNlcnRNYXRjaGVyKG1hdGNoZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3JpZ2luYWxNYXRjaGVyXHJcbiAgICAgICAgICAgID8gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gc2luY2Ugb3RoZXIgbWF0Y2hlcnMgYXJlIGFsaWFzZXMsIHRoZXkgc2hvdWxkIGJlIHJlbW92ZWQgYnkgdGhlIG9yaWdpbmFsIG1hdGNoZXJcclxuICAgICAgICAgICAgICAgIHJlbW92ZVJvdXRlKG9yaWdpbmFsTWF0Y2hlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBub29wO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlUm91dGUobWF0Y2hlclJlZikge1xyXG4gICAgICAgIGlmIChpc1JvdXRlTmFtZShtYXRjaGVyUmVmKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVyID0gbWF0Y2hlck1hcC5nZXQobWF0Y2hlclJlZik7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaGVyKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVyTWFwLmRlbGV0ZShtYXRjaGVyUmVmKTtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXJzLnNwbGljZShtYXRjaGVycy5pbmRleE9mKG1hdGNoZXIpLCAxKTtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXIuY2hpbGRyZW4uZm9yRWFjaChyZW1vdmVSb3V0ZSk7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVyLmFsaWFzLmZvckVhY2gocmVtb3ZlUm91dGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBtYXRjaGVycy5pbmRleE9mKG1hdGNoZXJSZWYpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyUmVmLnJlY29yZC5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXJNYXAuZGVsZXRlKG1hdGNoZXJSZWYucmVjb3JkLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlclJlZi5jaGlsZHJlbi5mb3JFYWNoKHJlbW92ZVJvdXRlKTtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXJSZWYuYWxpYXMuZm9yRWFjaChyZW1vdmVSb3V0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRSb3V0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW5zZXJ0TWF0Y2hlcihtYXRjaGVyKSB7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpIGlzJywgeyBpIH0pXHJcbiAgICAgICAgd2hpbGUgKGkgPCBtYXRjaGVycy5sZW5ndGggJiZcclxuICAgICAgICAgICAgY29tcGFyZVBhdGhQYXJzZXJTY29yZShtYXRjaGVyLCBtYXRjaGVyc1tpXSkgPj0gMClcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdFTkQgaSBpcycsIHsgaSB9KVxyXG4gICAgICAgIC8vIHdoaWxlIChpIDwgbWF0Y2hlcnMubGVuZ3RoICYmIG1hdGNoZXIuc2NvcmUgPD0gbWF0Y2hlcnNbaV0uc2NvcmUpIGkrK1xyXG4gICAgICAgIG1hdGNoZXJzLnNwbGljZShpLCAwLCBtYXRjaGVyKTtcclxuICAgICAgICAvLyBvbmx5IGFkZCB0aGUgb3JpZ2luYWwgcmVjb3JkIHRvIHRoZSBuYW1lIG1hcFxyXG4gICAgICAgIGlmIChtYXRjaGVyLnJlY29yZC5uYW1lICYmICFpc0FsaWFzUmVjb3JkKG1hdGNoZXIpKVxyXG4gICAgICAgICAgICBtYXRjaGVyTWFwLnNldChtYXRjaGVyLnJlY29yZC5uYW1lLCBtYXRjaGVyKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc29sdmUobG9jYXRpb24sIGN1cnJlbnRMb2NhdGlvbikge1xyXG4gICAgICAgIGxldCBtYXRjaGVyO1xyXG4gICAgICAgIGxldCBwYXJhbXMgPSB7fTtcclxuICAgICAgICBsZXQgcGF0aDtcclxuICAgICAgICBsZXQgbmFtZTtcclxuICAgICAgICBpZiAoJ25hbWUnIGluIGxvY2F0aW9uICYmIGxvY2F0aW9uLm5hbWUpIHtcclxuICAgICAgICAgICAgbWF0Y2hlciA9IG1hdGNoZXJNYXAuZ2V0KGxvY2F0aW9uLm5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIW1hdGNoZXIpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVSb3V0ZXJFcnJvcigxIC8qIE1BVENIRVJfTk9UX0ZPVU5EICovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoZXIucmVjb3JkLm5hbWU7XHJcbiAgICAgICAgICAgIHBhcmFtcyA9IGFzc2lnbihcclxuICAgICAgICAgICAgLy8gcGFyYW1zRnJvbUxvY2F0aW9uIGlzIGEgbmV3IG9iamVjdFxyXG4gICAgICAgICAgICBwYXJhbXNGcm9tTG9jYXRpb24oY3VycmVudExvY2F0aW9uLnBhcmFtcywgXHJcbiAgICAgICAgICAgIC8vIG9ubHkga2VlcCBwYXJhbXMgdGhhdCBleGlzdCBpbiB0aGUgcmVzb2x2ZWQgbG9jYXRpb25cclxuICAgICAgICAgICAgLy8gVE9ETzogb25seSBrZWVwIG9wdGlvbmFsIHBhcmFtcyBjb21pbmcgZnJvbSBhIHBhcmVudCByZWNvcmRcclxuICAgICAgICAgICAgbWF0Y2hlci5rZXlzLmZpbHRlcihrID0+ICFrLm9wdGlvbmFsKS5tYXAoayA9PiBrLm5hbWUpKSwgbG9jYXRpb24ucGFyYW1zKTtcclxuICAgICAgICAgICAgLy8gdGhyb3dzIGlmIGNhbm5vdCBiZSBzdHJpbmdpZmllZFxyXG4gICAgICAgICAgICBwYXRoID0gbWF0Y2hlci5zdHJpbmdpZnkocGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ3BhdGgnIGluIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcmVzb2x2ZSB0aGUgcGF0aCB3aXRoIHRoZSBtYXRjaGVyIGFzIGl0IHdhcyBwcm92aWRlZFxyXG4gICAgICAgICAgICAvLyB0aGlzIGFsc28gYWxsb3dzIHRoZSB1c2VyIHRvIGNvbnRyb2wgdGhlIGVuY29kaW5nXHJcbiAgICAgICAgICAgIHBhdGggPSBsb2NhdGlvbi5wYXRoO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFwYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgVGhlIE1hdGNoZXIgY2Fubm90IHJlc29sdmUgcmVsYXRpdmUgcGF0aHMgYnV0IHJlY2VpdmVkIFwiJHtwYXRofVwiLiBVbmxlc3MgeW91IGRpcmVjdGx5IGNhbGxlZCBcXGBtYXRjaGVyLnJlc29sdmUoXCIke3BhdGh9XCIpXFxgLCB0aGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIHZ1ZS1yb3V0ZXIuIFBsZWFzZSBvcGVuIGFuIGlzc3VlIGF0IGh0dHBzOi8vbmV3LWlzc3VlLnZ1ZWpzLm9yZy8/cmVwbz12dWVqcy92dWUtcm91dGVyLW5leHQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWF0Y2hlciA9IG1hdGNoZXJzLmZpbmQobSA9PiBtLnJlLnRlc3QocGF0aCkpO1xyXG4gICAgICAgICAgICAvLyBtYXRjaGVyIHNob3VsZCBoYXZlIGEgdmFsdWUgYWZ0ZXIgdGhlIGxvb3BcclxuICAgICAgICAgICAgaWYgKG1hdGNoZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGRldiB3YXJuaW5nIG9mIHVudXNlZCBwYXJhbXMgaWYgcHJvdmlkZWRcclxuICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgdGhlIG1hdGNoZXIgd29ya3MgYmVjYXVzZSB3ZSB0ZXN0ZWQgdGhlIHJlZ2V4cFxyXG4gICAgICAgICAgICAgICAgcGFyYW1zID0gbWF0Y2hlci5wYXJzZShwYXRoKTtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBtYXRjaGVyLnJlY29yZC5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGxvY2F0aW9uIGlzIGEgcmVsYXRpdmUgcGF0aFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbWF0Y2ggYnkgbmFtZSBvciBwYXRoIG9mIGN1cnJlbnQgcm91dGVcclxuICAgICAgICAgICAgbWF0Y2hlciA9IGN1cnJlbnRMb2NhdGlvbi5uYW1lXHJcbiAgICAgICAgICAgICAgICA/IG1hdGNoZXJNYXAuZ2V0KGN1cnJlbnRMb2NhdGlvbi5uYW1lKVxyXG4gICAgICAgICAgICAgICAgOiBtYXRjaGVycy5maW5kKG0gPT4gbS5yZS50ZXN0KGN1cnJlbnRMb2NhdGlvbi5wYXRoKSk7XHJcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcilcclxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVJvdXRlckVycm9yKDEgLyogTUFUQ0hFUl9OT1RfRk9VTkQgKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TG9jYXRpb24sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoZXIucmVjb3JkLm5hbWU7XHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIHRoZSBzYW1lIGxvY2F0aW9uLCB3ZSBkb24ndCBuZWVkIHRvIHBpY2sgdGhlXHJcbiAgICAgICAgICAgIC8vIHBhcmFtcyBsaWtlIHdoZW4gYG5hbWVgIGlzIHByb3ZpZGVkXHJcbiAgICAgICAgICAgIHBhcmFtcyA9IGFzc2lnbih7fSwgY3VycmVudExvY2F0aW9uLnBhcmFtcywgbG9jYXRpb24ucGFyYW1zKTtcclxuICAgICAgICAgICAgcGF0aCA9IG1hdGNoZXIuc3RyaW5naWZ5KHBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1hdGNoZWQgPSBbXTtcclxuICAgICAgICBsZXQgcGFyZW50TWF0Y2hlciA9IG1hdGNoZXI7XHJcbiAgICAgICAgd2hpbGUgKHBhcmVudE1hdGNoZXIpIHtcclxuICAgICAgICAgICAgLy8gcmV2ZXJzZWQgb3JkZXIgc28gcGFyZW50cyBhcmUgYXQgdGhlIGJlZ2lubmluZ1xyXG4gICAgICAgICAgICBtYXRjaGVkLnVuc2hpZnQocGFyZW50TWF0Y2hlci5yZWNvcmQpO1xyXG4gICAgICAgICAgICBwYXJlbnRNYXRjaGVyID0gcGFyZW50TWF0Y2hlci5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIHBhdGgsXHJcbiAgICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICAgICAgbWF0Y2hlZCxcclxuICAgICAgICAgICAgbWV0YTogbWVyZ2VNZXRhRmllbGRzKG1hdGNoZWQpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBhZGQgaW5pdGlhbCByb3V0ZXNcclxuICAgIHJvdXRlcy5mb3JFYWNoKHJvdXRlID0+IGFkZFJvdXRlKHJvdXRlKSk7XHJcbiAgICByZXR1cm4geyBhZGRSb3V0ZSwgcmVzb2x2ZSwgcmVtb3ZlUm91dGUsIGdldFJvdXRlcywgZ2V0UmVjb3JkTWF0Y2hlciB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcmFtc0Zyb21Mb2NhdGlvbihwYXJhbXMsIGtleXMpIHtcclxuICAgIGxldCBuZXdQYXJhbXMgPSB7fTtcclxuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgICAgaWYgKGtleSBpbiBwYXJhbXMpXHJcbiAgICAgICAgICAgIG5ld1BhcmFtc1trZXldID0gcGFyYW1zW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3UGFyYW1zO1xyXG59XHJcbi8qKlxyXG4gKiBOb3JtYWxpemVzIGEgUm91dGVSZWNvcmRSYXcuIENyZWF0ZXMgYSBjb3B5XHJcbiAqXHJcbiAqIEBwYXJhbSByZWNvcmRcclxuICogQHJldHVybnMgdGhlIG5vcm1hbGl6ZWQgdmVyc2lvblxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplUm91dGVSZWNvcmQocmVjb3JkKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHBhdGg6IHJlY29yZC5wYXRoLFxyXG4gICAgICAgIHJlZGlyZWN0OiByZWNvcmQucmVkaXJlY3QsXHJcbiAgICAgICAgbmFtZTogcmVjb3JkLm5hbWUsXHJcbiAgICAgICAgbWV0YTogcmVjb3JkLm1ldGEgfHwge30sXHJcbiAgICAgICAgYWxpYXNPZjogdW5kZWZpbmVkLFxyXG4gICAgICAgIGJlZm9yZUVudGVyOiByZWNvcmQuYmVmb3JlRW50ZXIsXHJcbiAgICAgICAgcHJvcHM6IG5vcm1hbGl6ZVJlY29yZFByb3BzKHJlY29yZCksXHJcbiAgICAgICAgY2hpbGRyZW46IHJlY29yZC5jaGlsZHJlbiB8fCBbXSxcclxuICAgICAgICBpbnN0YW5jZXM6IHt9LFxyXG4gICAgICAgIGxlYXZlR3VhcmRzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgdXBkYXRlR3VhcmRzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgZW50ZXJDYWxsYmFja3M6IHt9LFxyXG4gICAgICAgIGNvbXBvbmVudHM6ICdjb21wb25lbnRzJyBpbiByZWNvcmRcclxuICAgICAgICAgICAgPyByZWNvcmQuY29tcG9uZW50cyB8fCB7fVxyXG4gICAgICAgICAgICA6IHsgZGVmYXVsdDogcmVjb3JkLmNvbXBvbmVudCB9LFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogTm9ybWFsaXplIHRoZSBvcHRpb25hbCBgcHJvcHNgIGluIGEgcmVjb3JkIHRvIGFsd2F5cyBiZSBhbiBvYmplY3Qgc2ltaWxhciB0b1xyXG4gKiBjb21wb25lbnRzLiBBbHNvIGFjY2VwdCBhIGJvb2xlYW4gZm9yIGNvbXBvbmVudHMuXHJcbiAqIEBwYXJhbSByZWNvcmRcclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlY29yZFByb3BzKHJlY29yZCkge1xyXG4gICAgY29uc3QgcHJvcHNPYmplY3QgPSB7fTtcclxuICAgIC8vIHByb3BzIGRvZXMgbm90IGV4aXN0IG9uIHJlZGlyZWN0IHJlY29yZHMgYnV0IHdlIGNhbiBzZXQgZmFsc2UgZGlyZWN0bHlcclxuICAgIGNvbnN0IHByb3BzID0gcmVjb3JkLnByb3BzIHx8IGZhbHNlO1xyXG4gICAgaWYgKCdjb21wb25lbnQnIGluIHJlY29yZCkge1xyXG4gICAgICAgIHByb3BzT2JqZWN0LmRlZmF1bHQgPSBwcm9wcztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIE5PVEU6IHdlIGNvdWxkIGFsc28gYWxsb3cgYSBmdW5jdGlvbiB0byBiZSBhcHBsaWVkIHRvIGV2ZXJ5IGNvbXBvbmVudC5cclxuICAgICAgICAvLyBXb3VsZCBuZWVkIHVzZXIgZmVlZGJhY2sgZm9yIHVzZSBjYXNlc1xyXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gcmVjb3JkLmNvbXBvbmVudHMpXHJcbiAgICAgICAgICAgIHByb3BzT2JqZWN0W25hbWVdID0gdHlwZW9mIHByb3BzID09PSAnYm9vbGVhbicgPyBwcm9wcyA6IHByb3BzW25hbWVdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BzT2JqZWN0O1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSByZWNvcmQgb3IgYW55IG9mIGl0cyBwYXJlbnQgaXMgYW4gYWxpYXNcclxuICogQHBhcmFtIHJlY29yZFxyXG4gKi9cclxuZnVuY3Rpb24gaXNBbGlhc1JlY29yZChyZWNvcmQpIHtcclxuICAgIHdoaWxlIChyZWNvcmQpIHtcclxuICAgICAgICBpZiAocmVjb3JkLnJlY29yZC5hbGlhc09mKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICByZWNvcmQgPSByZWNvcmQucGFyZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBNZXJnZSBtZXRhIGZpZWxkcyBvZiBhbiBhcnJheSBvZiByZWNvcmRzXHJcbiAqXHJcbiAqIEBwYXJhbSBtYXRjaGVkIC0gYXJyYXkgb2YgbWF0Y2hlZCByZWNvcmRzXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZU1ldGFGaWVsZHMobWF0Y2hlZCkge1xyXG4gICAgcmV0dXJuIG1hdGNoZWQucmVkdWNlKChtZXRhLCByZWNvcmQpID0+IGFzc2lnbihtZXRhLCByZWNvcmQubWV0YSksIHt9KTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMoZGVmYXVsdHMsIHBhcnRpYWxPcHRpb25zKSB7XHJcbiAgICBsZXQgb3B0aW9ucyA9IHt9O1xyXG4gICAgZm9yIChsZXQga2V5IGluIGRlZmF1bHRzKSB7XHJcbiAgICAgICAgb3B0aW9uc1trZXldID1cclxuICAgICAgICAgICAga2V5IGluIHBhcnRpYWxPcHRpb25zID8gcGFydGlhbE9wdGlvbnNba2V5XSA6IGRlZmF1bHRzW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3B0aW9ucztcclxufVxyXG5mdW5jdGlvbiBpc1NhbWVQYXJhbShhLCBiKSB7XHJcbiAgICByZXR1cm4gKGEubmFtZSA9PT0gYi5uYW1lICYmXHJcbiAgICAgICAgYS5vcHRpb25hbCA9PT0gYi5vcHRpb25hbCAmJlxyXG4gICAgICAgIGEucmVwZWF0YWJsZSA9PT0gYi5yZXBlYXRhYmxlKTtcclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgYSBwYXRoIGFuZCBpdHMgYWxpYXMgaGF2ZSB0aGUgc2FtZSByZXF1aXJlZCBwYXJhbXNcclxuICpcclxuICogQHBhcmFtIGEgLSBvcmlnaW5hbCByZWNvcmRcclxuICogQHBhcmFtIGIgLSBhbGlhcyByZWNvcmRcclxuICovXHJcbmZ1bmN0aW9uIGNoZWNrU2FtZVBhcmFtcyhhLCBiKSB7XHJcbiAgICBmb3IgKGxldCBrZXkgb2YgYS5rZXlzKSB7XHJcbiAgICAgICAgaWYgKCFrZXkub3B0aW9uYWwgJiYgIWIua2V5cy5maW5kKGlzU2FtZVBhcmFtLmJpbmQobnVsbCwga2V5KSkpXHJcbiAgICAgICAgICAgIHJldHVybiB3YXJuKGBBbGlhcyBcIiR7Yi5yZWNvcmQucGF0aH1cIiBhbmQgdGhlIG9yaWdpbmFsIHJlY29yZDogXCIke2EucmVjb3JkLnBhdGh9XCIgc2hvdWxkIGhhdmUgdGhlIGV4YWN0IHNhbWUgcGFyYW0gbmFtZWQgXCIke2tleS5uYW1lfVwiYCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBrZXkgb2YgYi5rZXlzKSB7XHJcbiAgICAgICAgaWYgKCFrZXkub3B0aW9uYWwgJiYgIWEua2V5cy5maW5kKGlzU2FtZVBhcmFtLmJpbmQobnVsbCwga2V5KSkpXHJcbiAgICAgICAgICAgIHJldHVybiB3YXJuKGBBbGlhcyBcIiR7Yi5yZWNvcmQucGF0aH1cIiBhbmQgdGhlIG9yaWdpbmFsIHJlY29yZDogXCIke2EucmVjb3JkLnBhdGh9XCIgc2hvdWxkIGhhdmUgdGhlIGV4YWN0IHNhbWUgcGFyYW0gbmFtZWQgXCIke2tleS5uYW1lfVwiYCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tNaXNzaW5nUGFyYW1zSW5BYnNvbHV0ZVBhdGgocmVjb3JkLCBwYXJlbnQpIHtcclxuICAgIGZvciAobGV0IGtleSBvZiBwYXJlbnQua2V5cykge1xyXG4gICAgICAgIGlmICghcmVjb3JkLmtleXMuZmluZChpc1NhbWVQYXJhbS5iaW5kKG51bGwsIGtleSkpKVxyXG4gICAgICAgICAgICByZXR1cm4gd2FybihgQWJzb2x1dGUgcGF0aCBcIiR7cmVjb3JkLnJlY29yZC5wYXRofVwiIHNob3VsZCBoYXZlIHRoZSBleGFjdCBzYW1lIHBhcmFtIG5hbWVkIFwiJHtrZXkubmFtZX1cIiBhcyBpdHMgcGFyZW50IFwiJHtwYXJlbnQucmVjb3JkLnBhdGh9XCIuYCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEVuY29kaW5nIFJ1bGVzIOKQoyA9IFNwYWNlIFBhdGg6IOKQoyBcIiA8ID4gIyA/IHsgfSBRdWVyeTog4pCjIFwiIDwgPiAjICYgPSBIYXNoOiDikKMgXCJcclxuICogPCA+IGBcclxuICpcclxuICogT24gdG9wIG9mIHRoYXQsIHRoZSBSRkMzOTg2IChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTIuMilcclxuICogZGVmaW5lcyBzb21lIGV4dHJhIGNoYXJhY3RlcnMgdG8gYmUgZW5jb2RlZC4gTW9zdCBicm93c2VycyBkbyBub3QgZW5jb2RlIHRoZW1cclxuICogaW4gZW5jb2RlVVJJIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvdXJsL2lzc3Vlcy8zNjksIHNvIGl0IG1heSBiZSBzYWZlciB0b1xyXG4gKiBhbHNvIGVuY29kZSBgIScoKSpgLiBMZWF2aW5nIHVuZW5jb2RlZCBvbmx5IEFTQ0lJIGFscGhhbnVtZXJpYyhgYS16QS1aMC05YClcclxuICogcGx1cyBgLS5ffmAuIFRoaXMgZXh0cmEgc2FmZXR5IHNob3VsZCBiZSBhcHBsaWVkIHRvIHF1ZXJ5IGJ5IHBhdGNoaW5nIHRoZVxyXG4gKiBzdHJpbmcgcmV0dXJuZWQgYnkgZW5jb2RlVVJJQ29tcG9uZW50IGVuY29kZVVSSSBhbHNvIGVuY29kZXMgYFtcXF1eYC4gYFxcYFxyXG4gKiBzaG91bGQgYmUgZW5jb2RlZCB0byBhdm9pZCBhbWJpZ3VpdHkuIEJyb3dzZXJzIChJRSwgRkYsIEMpIHRyYW5zZm9ybSBhIGBcXGBcclxuICogaW50byBhIGAvYCBpZiBkaXJlY3RseSB0eXBlZCBpbi4gVGhlIF9iYWNrdGlja18gKGBgYGBgKSBzaG91bGQgYWxzbyBiZVxyXG4gKiBlbmNvZGVkIGV2ZXJ5d2hlcmUgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGxpa2UgRkYgZW5jb2RlIGl0IHdoZW4gZGlyZWN0bHlcclxuICogd3JpdHRlbiB3aGlsZSBvdGhlcnMgZG9uJ3QuIFNhZmFyaSBhbmQgSUUgZG9uJ3QgZW5jb2RlIGBgXCI8Pnt9YGBgIGluIGhhc2guXHJcbiAqL1xyXG4vLyBjb25zdCBFWFRSQV9SRVNFUlZFRF9SRSA9IC9bIScoKSpdL2dcclxuLy8gY29uc3QgZW5jb2RlUmVzZXJ2ZWRSZXBsYWNlciA9IChjOiBzdHJpbmcpID0+ICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNilcclxuY29uc3QgSEFTSF9SRSA9IC8jL2c7IC8vICUyM1xyXG5jb25zdCBBTVBFUlNBTkRfUkUgPSAvJi9nOyAvLyAlMjZcclxuY29uc3QgU0xBU0hfUkUgPSAvXFwvL2c7IC8vICUyRlxyXG5jb25zdCBFUVVBTF9SRSA9IC89L2c7IC8vICUzRFxyXG5jb25zdCBJTV9SRSA9IC9cXD8vZzsgLy8gJTNGXHJcbmNvbnN0IFBMVVNfUkUgPSAvXFwrL2c7IC8vICUyQlxyXG4vKipcclxuICogTk9URTogSXQncyBub3QgY2xlYXIgdG8gbWUgaWYgd2Ugc2hvdWxkIGVuY29kZSB0aGUgKyBzeW1ib2wgaW4gcXVlcmllcywgaXRcclxuICogc2VlbXMgdG8gYmUgbGVzcyBmbGV4aWJsZSB0aGFuIG5vdCBkb2luZyBzbyBhbmQgSSBjYW4ndCBmaW5kIG91dCB0aGUgbGVnYWN5XHJcbiAqIHN5c3RlbXMgcmVxdWlyaW5nIHRoaXMgZm9yIHJlZ3VsYXIgcmVxdWVzdHMgbGlrZSB0ZXh0L2h0bWwuIEluIHRoZSBzdGFuZGFyZCxcclxuICogdGhlIGVuY29kaW5nIG9mIHRoZSBwbHVzIGNoYXJhY3RlciBpcyBvbmx5IG1lbnRpb25lZCBmb3JcclxuICogYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXHJcbiAqIChodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybGVuY29kZWQtcGFyc2luZykgYW5kIG1vc3QgYnJvd3NlcnMgc2VlbXMgbG9cclxuICogbGVhdmUgdGhlIHBsdXMgY2hhcmFjdGVyIGFzIGlzIGluIHF1ZXJpZXMuIFRvIGJlIG1vcmUgZmxleGlibGUsIHdlIGFsbG93IHRoZVxyXG4gKiBwbHVzIGNoYXJhY3RlciBvbiB0aGUgcXVlcnkgYnV0IGl0IGNhbiBhbHNvIGJlIG1hbnVhbGx5IGVuY29kZWQgYnkgdGhlIHVzZXIuXHJcbiAqXHJcbiAqIFJlc291cmNlczpcclxuICogLSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybGVuY29kZWQtcGFyc2luZ1xyXG4gKiAtIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2MzQyNzEvdXJsLWVuY29kaW5nLXRoZS1zcGFjZS1jaGFyYWN0ZXItb3ItMjBcclxuICovXHJcbmNvbnN0IEVOQ19CUkFDS0VUX09QRU5fUkUgPSAvJTVCL2c7IC8vIFtcclxuY29uc3QgRU5DX0JSQUNLRVRfQ0xPU0VfUkUgPSAvJTVEL2c7IC8vIF1cclxuY29uc3QgRU5DX0NBUkVUX1JFID0gLyU1RS9nOyAvLyBeXHJcbmNvbnN0IEVOQ19CQUNLVElDS19SRSA9IC8lNjAvZzsgLy8gYFxyXG5jb25zdCBFTkNfQ1VSTFlfT1BFTl9SRSA9IC8lN0IvZzsgLy8ge1xyXG5jb25zdCBFTkNfUElQRV9SRSA9IC8lN0MvZzsgLy8gfFxyXG5jb25zdCBFTkNfQ1VSTFlfQ0xPU0VfUkUgPSAvJTdEL2c7IC8vIH1cclxuY29uc3QgRU5DX1NQQUNFX1JFID0gLyUyMC9nOyAvLyB9XHJcbi8qKlxyXG4gKiBFbmNvZGUgY2hhcmFjdGVycyB0aGF0IG5lZWQgdG8gYmUgZW5jb2RlZCBvbiB0aGUgcGF0aCwgc2VhcmNoIGFuZCBoYXNoXHJcbiAqIHNlY3Rpb25zIG9mIHRoZSBVUkwuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiBAcGFyYW0gdGV4dCAtIHN0cmluZyB0byBlbmNvZGVcclxuICogQHJldHVybnMgZW5jb2RlZCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGNvbW1vbkVuY29kZSh0ZXh0KSB7XHJcbiAgICByZXR1cm4gZW5jb2RlVVJJKCcnICsgdGV4dClcclxuICAgICAgICAucmVwbGFjZShFTkNfUElQRV9SRSwgJ3wnKVxyXG4gICAgICAgIC5yZXBsYWNlKEVOQ19CUkFDS0VUX09QRU5fUkUsICdbJylcclxuICAgICAgICAucmVwbGFjZShFTkNfQlJBQ0tFVF9DTE9TRV9SRSwgJ10nKTtcclxufVxyXG4vKipcclxuICogRW5jb2RlIGNoYXJhY3RlcnMgdGhhdCBuZWVkIHRvIGJlIGVuY29kZWQgb24gdGhlIGhhc2ggc2VjdGlvbiBvZiB0aGUgVVJMLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGV4dCAtIHN0cmluZyB0byBlbmNvZGVcclxuICogQHJldHVybnMgZW5jb2RlZCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGVuY29kZUhhc2godGV4dCkge1xyXG4gICAgcmV0dXJuIGNvbW1vbkVuY29kZSh0ZXh0KVxyXG4gICAgICAgIC5yZXBsYWNlKEVOQ19DVVJMWV9PUEVOX1JFLCAneycpXHJcbiAgICAgICAgLnJlcGxhY2UoRU5DX0NVUkxZX0NMT1NFX1JFLCAnfScpXHJcbiAgICAgICAgLnJlcGxhY2UoRU5DX0NBUkVUX1JFLCAnXicpO1xyXG59XHJcbi8qKlxyXG4gKiBFbmNvZGUgY2hhcmFjdGVycyB0aGF0IG5lZWQgdG8gYmUgZW5jb2RlZCBxdWVyeSB2YWx1ZXMgb24gdGhlIHF1ZXJ5XHJcbiAqIHNlY3Rpb24gb2YgdGhlIFVSTC5cclxuICpcclxuICogQHBhcmFtIHRleHQgLSBzdHJpbmcgdG8gZW5jb2RlXHJcbiAqIEByZXR1cm5zIGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmNvZGVRdWVyeVZhbHVlKHRleHQpIHtcclxuICAgIHJldHVybiAoY29tbW9uRW5jb2RlKHRleHQpXHJcbiAgICAgICAgLy8gRW5jb2RlIHRoZSBzcGFjZSBhcyArLCBlbmNvZGUgdGhlICsgdG8gZGlmZmVyZW50aWF0ZSBpdCBmcm9tIHRoZSBzcGFjZVxyXG4gICAgICAgIC5yZXBsYWNlKFBMVVNfUkUsICclMkInKVxyXG4gICAgICAgIC5yZXBsYWNlKEVOQ19TUEFDRV9SRSwgJysnKVxyXG4gICAgICAgIC5yZXBsYWNlKEhBU0hfUkUsICclMjMnKVxyXG4gICAgICAgIC5yZXBsYWNlKEFNUEVSU0FORF9SRSwgJyUyNicpXHJcbiAgICAgICAgLnJlcGxhY2UoRU5DX0JBQ0tUSUNLX1JFLCAnYCcpXHJcbiAgICAgICAgLnJlcGxhY2UoRU5DX0NVUkxZX09QRU5fUkUsICd7JylcclxuICAgICAgICAucmVwbGFjZShFTkNfQ1VSTFlfQ0xPU0VfUkUsICd9JylcclxuICAgICAgICAucmVwbGFjZShFTkNfQ0FSRVRfUkUsICdeJykpO1xyXG59XHJcbi8qKlxyXG4gKiBMaWtlIGBlbmNvZGVRdWVyeVZhbHVlYCBidXQgYWxzbyBlbmNvZGVzIHRoZSBgPWAgY2hhcmFjdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGV4dCAtIHN0cmluZyB0byBlbmNvZGVcclxuICovXHJcbmZ1bmN0aW9uIGVuY29kZVF1ZXJ5S2V5KHRleHQpIHtcclxuICAgIHJldHVybiBlbmNvZGVRdWVyeVZhbHVlKHRleHQpLnJlcGxhY2UoRVFVQUxfUkUsICclM0QnKTtcclxufVxyXG4vKipcclxuICogRW5jb2RlIGNoYXJhY3RlcnMgdGhhdCBuZWVkIHRvIGJlIGVuY29kZWQgb24gdGhlIHBhdGggc2VjdGlvbiBvZiB0aGUgVVJMLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGV4dCAtIHN0cmluZyB0byBlbmNvZGVcclxuICogQHJldHVybnMgZW5jb2RlZCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGVuY29kZVBhdGgodGV4dCkge1xyXG4gICAgcmV0dXJuIGNvbW1vbkVuY29kZSh0ZXh0KS5yZXBsYWNlKEhBU0hfUkUsICclMjMnKS5yZXBsYWNlKElNX1JFLCAnJTNGJyk7XHJcbn1cclxuLyoqXHJcbiAqIEVuY29kZSBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlbmNvZGVkIG9uIHRoZSBwYXRoIHNlY3Rpb24gb2YgdGhlIFVSTCBhcyBhXHJcbiAqIHBhcmFtLiBUaGlzIGZ1bmN0aW9uIGVuY29kZXMgZXZlcnl0aGluZyB7QGxpbmsgZW5jb2RlUGF0aH0gZG9lcyBwbHVzIHRoZVxyXG4gKiBzbGFzaCAoYC9gKSBjaGFyYWN0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB0ZXh0IC0gc3RyaW5nIHRvIGVuY29kZVxyXG4gKiBAcmV0dXJucyBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gZW5jb2RlUGFyYW0odGV4dCkge1xyXG4gICAgcmV0dXJuIGVuY29kZVBhdGgodGV4dCkucmVwbGFjZShTTEFTSF9SRSwgJyUyRicpO1xyXG59XHJcbi8qKlxyXG4gKiBEZWNvZGUgdGV4dCB1c2luZyBgZGVjb2RlVVJJQ29tcG9uZW50YC4gUmV0dXJucyB0aGUgb3JpZ2luYWwgdGV4dCBpZiBpdFxyXG4gKiBmYWlscy5cclxuICpcclxuICogQHBhcmFtIHRleHQgLSBzdHJpbmcgdG8gZGVjb2RlXHJcbiAqIEByZXR1cm5zIGRlY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNvZGUodGV4dCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KCcnICsgdGV4dCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYEVycm9yIGRlY29kaW5nIFwiJHt0ZXh0fVwiLiBVc2luZyBvcmlnaW5hbCB2YWx1ZWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcnICsgdGV4dDtcclxufVxuXG4vKipcclxuICogVHJhbnNmb3JtcyBhIHF1ZXJ5U3RyaW5nIGludG8gYSB7QGxpbmsgTG9jYXRpb25RdWVyeX0gb2JqZWN0LiBBY2NlcHQgYm90aCwgYVxyXG4gKiB2ZXJzaW9uIHdpdGggdGhlIGxlYWRpbmcgYD9gIGFuZCB3aXRob3V0IFNob3VsZCB3b3JrIGFzIFVSTFNlYXJjaFBhcmFtc1xyXG5cbiAqIEBpbnRlcm5hbFxyXG4gKlxyXG4gKiBAcGFyYW0gc2VhcmNoIC0gc2VhcmNoIHN0cmluZyB0byBwYXJzZVxyXG4gKiBAcmV0dXJucyBhIHF1ZXJ5IG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VRdWVyeShzZWFyY2gpIHtcclxuICAgIGNvbnN0IHF1ZXJ5ID0ge307XHJcbiAgICAvLyBhdm9pZCBjcmVhdGluZyBhbiBvYmplY3Qgd2l0aCBhbiBlbXB0eSBrZXkgYW5kIGVtcHR5IHZhbHVlXHJcbiAgICAvLyBiZWNhdXNlIG9mIHNwbGl0KCcmJylcclxuICAgIGlmIChzZWFyY2ggPT09ICcnIHx8IHNlYXJjaCA9PT0gJz8nKVxyXG4gICAgICAgIHJldHVybiBxdWVyeTtcclxuICAgIGNvbnN0IGhhc0xlYWRpbmdJTSA9IHNlYXJjaFswXSA9PT0gJz8nO1xyXG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gKGhhc0xlYWRpbmdJTSA/IHNlYXJjaC5zbGljZSgxKSA6IHNlYXJjaCkuc3BsaXQoJyYnKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhcmNoUGFyYW1zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgLy8gcHJlIGRlY29kZSB0aGUgKyBpbnRvIHNwYWNlXHJcbiAgICAgICAgY29uc3Qgc2VhcmNoUGFyYW0gPSBzZWFyY2hQYXJhbXNbaV0ucmVwbGFjZShQTFVTX1JFLCAnICcpO1xyXG4gICAgICAgIC8vIGFsbG93IHRoZSA9IGNoYXJhY3RlclxyXG4gICAgICAgIGxldCBlcVBvcyA9IHNlYXJjaFBhcmFtLmluZGV4T2YoJz0nKTtcclxuICAgICAgICBsZXQga2V5ID0gZGVjb2RlKGVxUG9zIDwgMCA/IHNlYXJjaFBhcmFtIDogc2VhcmNoUGFyYW0uc2xpY2UoMCwgZXFQb3MpKTtcclxuICAgICAgICBsZXQgdmFsdWUgPSBlcVBvcyA8IDAgPyBudWxsIDogZGVjb2RlKHNlYXJjaFBhcmFtLnNsaWNlKGVxUG9zICsgMSkpO1xyXG4gICAgICAgIGlmIChrZXkgaW4gcXVlcnkpIHtcclxuICAgICAgICAgICAgLy8gYW4gZXh0cmEgdmFyaWFibGUgZm9yIHRzIHR5cGVzXHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSBxdWVyeVtrZXldO1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gcXVlcnlba2V5XSA9IFtjdXJyZW50VmFsdWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZS5wdXNoKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVlcnk7XHJcbn1cclxuLyoqXHJcbiAqIFN0cmluZ2lmaWVzIGEge0BsaW5rIExvY2F0aW9uUXVlcnlSYXd9IG9iamVjdC4gTGlrZSBgVVJMU2VhcmNoUGFyYW1zYCwgaXRcclxuICogZG9lc24ndCBwcmVwZW5kIGEgYD9gXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnkgLSBxdWVyeSBvYmplY3QgdG8gc3RyaW5naWZ5XHJcbiAqIEByZXR1cm5zIHN0cmluZyB2ZXJzaW9uIG9mIHRoZSBxdWVyeSB3aXRob3V0IHRoZSBsZWFkaW5nIGA/YFxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcclxuICAgIGxldCBzZWFyY2ggPSAnJztcclxuICAgIGZvciAobGV0IGtleSBpbiBxdWVyeSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlba2V5XTtcclxuICAgICAgICBrZXkgPSBlbmNvZGVRdWVyeUtleShrZXkpO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgbnVsbCBhZGRzIHRoZSB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgc2VhcmNoICs9IChzZWFyY2gubGVuZ3RoID8gJyYnIDogJycpICsga2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBrZWVwIG51bGwgdmFsdWVzXHJcbiAgICAgICAgbGV0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkodmFsdWUpXHJcbiAgICAgICAgICAgID8gdmFsdWUubWFwKHYgPT4gdiAmJiBlbmNvZGVRdWVyeVZhbHVlKHYpKVxyXG4gICAgICAgICAgICA6IFt2YWx1ZSAmJiBlbmNvZGVRdWVyeVZhbHVlKHZhbHVlKV07XHJcbiAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAvLyBza2lwIHVuZGVmaW5lZCB2YWx1ZXMgaW4gYXJyYXlzIGFzIGlmIHRoZXkgd2VyZSBub3QgcHJlc2VudFxyXG4gICAgICAgICAgICAvLyBzbWFsbGVyIGNvZGUgdGhhbiB1c2luZyBmaWx0ZXJcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgYXBwZW5kICYgd2l0aCBub24tZW1wdHkgc2VhcmNoXHJcbiAgICAgICAgICAgICAgICBzZWFyY2ggKz0gKHNlYXJjaC5sZW5ndGggPyAnJicgOiAnJykgKyBrZXk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBzZWFyY2ggKz0gJz0nICsgdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzZWFyY2g7XHJcbn1cclxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgYSB7QGxpbmsgTG9jYXRpb25RdWVyeVJhd30gaW50byBhIHtAbGluayBMb2NhdGlvblF1ZXJ5fSBieSBjYXN0aW5nXHJcbiAqIG51bWJlcnMgaW50byBzdHJpbmdzLCByZW1vdmluZyBrZXlzIHdpdGggYW4gdW5kZWZpbmVkIHZhbHVlIGFuZCByZXBsYWNpbmdcclxuICogdW5kZWZpbmVkIHdpdGggbnVsbCBpbiBhcnJheXNcclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gcXVlcnkgb2JqZWN0IHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyBhIG5vcm1hbGl6ZWQgcXVlcnkgb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVRdWVyeShxdWVyeSkge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZFF1ZXJ5ID0ge307XHJcbiAgICBmb3IgKGxldCBrZXkgaW4gcXVlcnkpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSBxdWVyeVtrZXldO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRRdWVyeVtrZXldID0gQXJyYXkuaXNBcnJheSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgID8gdmFsdWUubWFwKHYgPT4gKHYgPT0gbnVsbCA/IG51bGwgOiAnJyArIHYpKVxyXG4gICAgICAgICAgICAgICAgOiB2YWx1ZSA9PSBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIDogJycgKyB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZFF1ZXJ5O1xyXG59XG5cbi8qKlxyXG4gKiBDcmVhdGUgYSBsaXN0IG9mIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSByZXNldC4gVXNlZCB0byBjcmVhdGUgYmVmb3JlIGFuZCBhZnRlciBuYXZpZ2F0aW9uIGd1YXJkcyBsaXN0XHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VDYWxsYmFja3MoKSB7XHJcbiAgICBsZXQgaGFuZGxlcnMgPSBbXTtcclxuICAgIGZ1bmN0aW9uIGFkZChoYW5kbGVyKSB7XHJcbiAgICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpID0gaGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKTtcclxuICAgICAgICAgICAgaWYgKGkgPiAtMSlcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XHJcbiAgICAgICAgaGFuZGxlcnMgPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYWRkLFxyXG4gICAgICAgIGxpc3Q6ICgpID0+IGhhbmRsZXJzLFxyXG4gICAgICAgIHJlc2V0LFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiByZWdpc3Rlckd1YXJkKHJlY29yZCwgbmFtZSwgZ3VhcmQpIHtcclxuICAgIGNvbnN0IHJlbW92ZUZyb21MaXN0ID0gKCkgPT4ge1xyXG4gICAgICAgIHJlY29yZFtuYW1lXS5kZWxldGUoZ3VhcmQpO1xyXG4gICAgfTtcclxuICAgIG9uVW5tb3VudGVkKHJlbW92ZUZyb21MaXN0KTtcclxuICAgIG9uRGVhY3RpdmF0ZWQocmVtb3ZlRnJvbUxpc3QpO1xyXG4gICAgb25BY3RpdmF0ZWQoKCkgPT4ge1xyXG4gICAgICAgIHJlY29yZFtuYW1lXS5hZGQoZ3VhcmQpO1xyXG4gICAgfSk7XHJcbiAgICByZWNvcmRbbmFtZV0uYWRkKGd1YXJkKTtcclxufVxyXG4vKipcclxuICogQWRkIGEgbmF2aWdhdGlvbiBndWFyZCB0aGF0IHRyaWdnZXJzIHdoZW5ldmVyIHRoZSBjb21wb25lbnQgZm9yIHRoZSBjdXJyZW50XHJcbiAqIGxvY2F0aW9uIGlzIGFib3V0IHRvIGJlIGxlZnQuIFNpbWlsYXIgdG8ge0BsaW5rIGJlZm9yZVJvdXRlTGVhdmV9IGJ1dCBjYW4gYmVcclxuICogdXNlZCBpbiBhbnkgY29tcG9uZW50LiBUaGUgZ3VhcmQgaXMgcmVtb3ZlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gbGVhdmVHdWFyZCAtIHtAbGluayBOYXZpZ2F0aW9uR3VhcmR9XHJcbiAqL1xyXG5mdW5jdGlvbiBvbkJlZm9yZVJvdXRlTGVhdmUobGVhdmVHdWFyZCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZ2V0Q3VycmVudEluc3RhbmNlKCkpIHtcclxuICAgICAgICB3YXJuKCdnZXRDdXJyZW50SW5zdGFuY2UoKSByZXR1cm5lZCBudWxsLiBvbkJlZm9yZVJvdXRlTGVhdmUoKSBtdXN0IGJlIGNhbGxlZCBhdCB0aGUgdG9wIG9mIGEgc2V0dXAgZnVuY3Rpb24nKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBhY3RpdmVSZWNvcmQgPSBpbmplY3QobWF0Y2hlZFJvdXRlS2V5LCB7fSkudmFsdWU7XHJcbiAgICBpZiAoIWFjdGl2ZVJlY29yZCkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuKCdObyBhY3RpdmUgcm91dGUgcmVjb3JkIHdhcyBmb3VuZC4gQXJlIHlvdSBtaXNzaW5nIGEgPHJvdXRlci12aWV3PiBjb21wb25lbnQ/Jyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJHdWFyZChhY3RpdmVSZWNvcmQsICdsZWF2ZUd1YXJkcycsIGxlYXZlR3VhcmQpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGQgYSBuYXZpZ2F0aW9uIGd1YXJkIHRoYXQgdHJpZ2dlcnMgd2hlbmV2ZXIgdGhlIGN1cnJlbnQgbG9jYXRpb24gaXMgYWJvdXRcclxuICogdG8gYmUgdXBkYXRlZC4gU2ltaWxhciB0byB7QGxpbmsgYmVmb3JlUm91dGVVcGRhdGV9IGJ1dCBjYW4gYmUgdXNlZCBpbiBhbnlcclxuICogY29tcG9uZW50LiBUaGUgZ3VhcmQgaXMgcmVtb3ZlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gdXBkYXRlR3VhcmQgLSB7QGxpbmsgTmF2aWdhdGlvbkd1YXJkfVxyXG4gKi9cclxuZnVuY3Rpb24gb25CZWZvcmVSb3V0ZVVwZGF0ZSh1cGRhdGVHdWFyZCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZ2V0Q3VycmVudEluc3RhbmNlKCkpIHtcclxuICAgICAgICB3YXJuKCdnZXRDdXJyZW50SW5zdGFuY2UoKSByZXR1cm5lZCBudWxsLiBvbkJlZm9yZVJvdXRlVXBkYXRlKCkgbXVzdCBiZSBjYWxsZWQgYXQgdGhlIHRvcCBvZiBhIHNldHVwIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYWN0aXZlUmVjb3JkID0gaW5qZWN0KG1hdGNoZWRSb3V0ZUtleSwge30pLnZhbHVlO1xyXG4gICAgaWYgKCFhY3RpdmVSZWNvcmQpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybignTm8gYWN0aXZlIHJvdXRlIHJlY29yZCB3YXMgZm91bmQuIEFyZSB5b3UgbWlzc2luZyBhIDxyb3V0ZXItdmlldz4gY29tcG9uZW50PycpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyR3VhcmQoYWN0aXZlUmVjb3JkLCAndXBkYXRlR3VhcmRzJywgdXBkYXRlR3VhcmQpO1xyXG59XHJcbmZ1bmN0aW9uIGd1YXJkVG9Qcm9taXNlRm4oZ3VhcmQsIHRvLCBmcm9tLCByZWNvcmQsIG5hbWUpIHtcclxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGVudGVyQ2FsbGJhY2tBcnJheSB0byBwcmV2ZW50IHB1c2hpbmcgY2FsbGJhY2tzIGlmIGEgbmV3IG5hdmlnYXRpb24gdG9vayBwbGFjZVxyXG4gICAgY29uc3QgZW50ZXJDYWxsYmFja0FycmF5ID0gcmVjb3JkICYmXHJcbiAgICAgICAgLy8gbmFtZSBpcyBkZWZpbmVkIGlmIHJlY29yZCBpcyBiZWNhdXNlIG9mIHRoZSBmdW5jdGlvbiBvdmVybG9hZFxyXG4gICAgICAgIChyZWNvcmQuZW50ZXJDYWxsYmFja3NbbmFtZV0gPSByZWNvcmQuZW50ZXJDYWxsYmFja3NbbmFtZV0gfHwgW10pO1xyXG4gICAgcmV0dXJuICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBjb25zdCBuZXh0ID0gKHZhbGlkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZCA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICByZWplY3QoY3JlYXRlUm91dGVyRXJyb3IoNCAvKiBOQVZJR0FUSU9OX0FCT1JURUQgKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICBmcm9tLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvLFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWxpZCBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QodmFsaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUm91dGVMb2NhdGlvbih2YWxpZCkpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChjcmVhdGVSb3V0ZXJFcnJvcigyIC8qIE5BVklHQVRJT05fR1VBUkRfUkVESVJFQ1QgKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICBmcm9tOiB0byxcclxuICAgICAgICAgICAgICAgICAgICB0bzogdmFsaWQsXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50ZXJDYWxsYmFja0FycmF5ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgZW50ZXJDYWxsYmFja0FycmF5IGlzIHRydXRoeSwgYm90aCByZWNvcmQgYW5kIG5hbWUgYWxzbyBhcmVcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmQuZW50ZXJDYWxsYmFja3NbbmFtZV0gPT09IGVudGVyQ2FsbGJhY2tBcnJheSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWxpZCA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICBlbnRlckNhbGxiYWNrQXJyYXkucHVzaCh2YWxpZCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHdyYXBwaW5nIHdpdGggUHJvbWlzZS5yZXNvbHZlIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYm90aCBhc3luYyBhbmQgc3luYyBndWFyZHNcclxuICAgICAgICBjb25zdCBndWFyZFJldHVybiA9IGd1YXJkLmNhbGwocmVjb3JkICYmIHJlY29yZC5pbnN0YW5jZXNbbmFtZV0sIHRvLCBmcm9tLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjYW5Pbmx5QmVDYWxsZWRPbmNlKG5leHQsIHRvLCBmcm9tKSA6IG5leHQpO1xyXG4gICAgICAgIGxldCBndWFyZENhbGwgPSBQcm9taXNlLnJlc29sdmUoZ3VhcmRSZXR1cm4pO1xyXG4gICAgICAgIGlmIChndWFyZC5sZW5ndGggPCAzKVxyXG4gICAgICAgICAgICBndWFyZENhbGwgPSBndWFyZENhbGwudGhlbihuZXh0KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGd1YXJkLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaGUgXCJuZXh0XCIgY2FsbGJhY2sgd2FzIG5ldmVyIGNhbGxlZCBpbnNpZGUgb2YgJHtndWFyZC5uYW1lID8gJ1wiJyArIGd1YXJkLm5hbWUgKyAnXCInIDogJyd9OlxcbiR7Z3VhcmQudG9TdHJpbmcoKX1cXG4uIElmIHlvdSBhcmUgcmV0dXJuaW5nIGEgdmFsdWUgaW5zdGVhZCBvZiBjYWxsaW5nIFwibmV4dFwiLCBtYWtlIHN1cmUgdG8gcmVtb3ZlIHRoZSBcIm5leHRcIiBwYXJhbWV0ZXIgZnJvbSB5b3VyIGZ1bmN0aW9uLmA7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ3VhcmRSZXR1cm4gPT09ICdvYmplY3QnICYmICd0aGVuJyBpbiBndWFyZFJldHVybikge1xyXG4gICAgICAgICAgICAgICAgZ3VhcmRDYWxsID0gZ3VhcmRDYWxsLnRoZW4ocmVzb2x2ZWRWYWx1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogX2NhbGxlZCBpcyBhZGRlZCBhdCBjYW5Pbmx5QmVDYWxsZWRPbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0Ll9jYWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBuYXZpZ2F0aW9uIGd1YXJkJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGVzdCBtZSFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChndWFyZFJldHVybiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBfY2FsbGVkIGlzIGFkZGVkIGF0IGNhbk9ubHlCZUNhbGxlZE9uY2VcclxuICAgICAgICAgICAgICAgIGlmICghbmV4dC5fY2FsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIG5hdmlnYXRpb24gZ3VhcmQnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGd1YXJkQ2FsbC5jYXRjaChlcnIgPT4gcmVqZWN0KGVycikpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY2FuT25seUJlQ2FsbGVkT25jZShuZXh0LCB0bywgZnJvbSkge1xyXG4gICAgbGV0IGNhbGxlZCA9IDA7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChjYWxsZWQrKyA9PT0gMSlcclxuICAgICAgICAgICAgd2FybihgVGhlIFwibmV4dFwiIGNhbGxiYWNrIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgaW4gb25lIG5hdmlnYXRpb24gZ3VhcmQgd2hlbiBnb2luZyBmcm9tIFwiJHtmcm9tLmZ1bGxQYXRofVwiIHRvIFwiJHt0by5mdWxsUGF0aH1cIi4gSXQgc2hvdWxkIGJlIGNhbGxlZCBleGFjdGx5IG9uZSB0aW1lIGluIGVhY2ggbmF2aWdhdGlvbiBndWFyZC4gVGhpcyB3aWxsIGZhaWwgaW4gcHJvZHVjdGlvbi5gKTtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZSBwdXQgaXQgaW4gdGhlIG9yaWdpbmFsIG9uZSBiZWNhdXNlIGl0J3MgZWFzaWVyIHRvIGNoZWNrXHJcbiAgICAgICAgbmV4dC5fY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAoY2FsbGVkID09PSAxKVxyXG4gICAgICAgICAgICBuZXh0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RDb21wb25lbnRzR3VhcmRzKG1hdGNoZWQsIGd1YXJkVHlwZSwgdG8sIGZyb20pIHtcclxuICAgIGNvbnN0IGd1YXJkcyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCByZWNvcmQgb2YgbWF0Y2hlZCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiByZWNvcmQuY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICBsZXQgcmF3Q29tcG9uZW50ID0gcmVjb3JkLmNvbXBvbmVudHNbbmFtZV07XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcmF3Q29tcG9uZW50IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiByYXdDb21wb25lbnQgIT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiByYXdDb21wb25lbnQgIT09ICdmdW5jdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IFwiJHtuYW1lfVwiIGluIHJlY29yZCB3aXRoIHBhdGggXCIke3JlY29yZC5wYXRofVwiIGlzIG5vdGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgIGEgdmFsaWQgY29tcG9uZW50LiBSZWNlaXZlZCBcIiR7U3RyaW5nKHJhd0NvbXBvbmVudCl9XCIuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgdG8gZW5zdXJlIHdlIHN0b3AgaGVyZSBidXQgd2FybiB0byBlbnN1cmUgdGhlIG1lc3NhZ2UgaXNuJ3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBtaXNzZWQgYnkgdGhlIHVzZXJcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcm91dGUgY29tcG9uZW50Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgndGhlbicgaW4gcmF3Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FybiBpZiB1c2VyIHdyb3RlIGltcG9ydCgnL2NvbXBvbmVudC52dWUnKSBpbnN0ZWFkIG9mICgpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0KCcuL2NvbXBvbmVudC52dWUnKVxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBcIiR7bmFtZX1cIiBpbiByZWNvcmQgd2l0aCBwYXRoIFwiJHtyZWNvcmQucGF0aH1cIiBpcyBhIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgUHJvbWlzZSBpbnN0ZWFkIG9mIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZS4gRGlkIHlvdSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHdyaXRlIFwiaW1wb3J0KCcuL015UGFnZS52dWUnKVwiIGluc3RlYWQgb2YgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcIigpID0+IGltcG9ydCgnLi9NeVBhZ2UudnVlJylcIiA/IFRoaXMgd2lsbCBicmVhayBpbiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHByb2R1Y3Rpb24gaWYgbm90IGZpeGVkLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwcm9taXNlID0gcmF3Q29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHJhd0NvbXBvbmVudCA9ICgpID0+IHByb21pc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyYXdDb21wb25lbnQuX19hc3luY0xvYWRlciAmJlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhcm4gb25seSBvbmNlIHBlciBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAhcmF3Q29tcG9uZW50Ll9fd2FybmVkRGVmaW5lQXN5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICByYXdDb21wb25lbnQuX193YXJuZWREZWZpbmVBc3luYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IFwiJHtuYW1lfVwiIGluIHJlY29yZCB3aXRoIHBhdGggXCIke3JlY29yZC5wYXRofVwiIGlzIGRlZmluZWQgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGB1c2luZyBcImRlZmluZUFzeW5jQ29tcG9uZW50KClcIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBXcml0ZSBcIigpID0+IGltcG9ydCgnLi9NeVBhZ2UudnVlJylcIiBpbnN0ZWFkIG9mIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgXCJkZWZpbmVBc3luY0NvbXBvbmVudCgoKSA9PiBpbXBvcnQoJy4vTXlQYWdlLnZ1ZScpKVwiLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNraXAgdXBkYXRlIGFuZCBsZWF2ZSBndWFyZHMgaWYgdGhlIHJvdXRlIGNvbXBvbmVudCBpcyBub3QgbW91bnRlZFxyXG4gICAgICAgICAgICBpZiAoZ3VhcmRUeXBlICE9PSAnYmVmb3JlUm91dGVFbnRlcicgJiYgIXJlY29yZC5pbnN0YW5jZXNbbmFtZV0pXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKGlzUm91dGVDb21wb25lbnQocmF3Q29tcG9uZW50KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gX192Y2NPcHRzIGlzIGFkZGVkIGJ5IHZ1ZS1jbGFzcy1jb21wb25lbnQgYW5kIGNvbnRhaW4gdGhlIHJlZ3VsYXIgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSByYXdDb21wb25lbnQuX192Y2NPcHRzIHx8IHJhd0NvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGd1YXJkID0gb3B0aW9uc1tndWFyZFR5cGVdO1xyXG4gICAgICAgICAgICAgICAgZ3VhcmQgJiYgZ3VhcmRzLnB1c2goZ3VhcmRUb1Byb21pc2VGbihndWFyZCwgdG8sIGZyb20sIHJlY29yZCwgbmFtZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgcmVxdWVzdGluZyB0aGUgY2h1bmsgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgbGV0IGNvbXBvbmVudFByb21pc2UgPSByYXdDb21wb25lbnQoKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgISgnY2F0Y2gnIGluIGNvbXBvbmVudFByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IFwiJHtuYW1lfVwiIGluIHJlY29yZCB3aXRoIHBhdGggXCIke3JlY29yZC5wYXRofVwiIGlzIGEgZnVuY3Rpb24gdGhhdCBkb2VzIG5vdCByZXR1cm4gYSBQcm9taXNlLiBJZiB5b3Ugd2VyZSBwYXNzaW5nIGEgZnVuY3Rpb25hbCBjb21wb25lbnQsIG1ha2Ugc3VyZSB0byBhZGQgYSBcImRpc3BsYXlOYW1lXCIgdG8gdGhlIGNvbXBvbmVudC4gVGhpcyB3aWxsIGJyZWFrIGluIHByb2R1Y3Rpb24gaWYgbm90IGZpeGVkLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29tcG9uZW50UHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBndWFyZHMucHVzaCgoKSA9PiBjb21wb25lbnRQcm9taXNlLnRoZW4ocmVzb2x2ZWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYENvdWxkbid0IHJlc29sdmUgY29tcG9uZW50IFwiJHtuYW1lfVwiIGF0IFwiJHtyZWNvcmQucGF0aH1cImApKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZENvbXBvbmVudCA9IGlzRVNNb2R1bGUocmVzb2x2ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzb2x2ZWQuZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlc29sdmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHJlc29sdmVkIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5jb21wb25lbnRzW25hbWVdID0gcmVzb2x2ZWRDb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gX192Y2NPcHRzIGlzIGFkZGVkIGJ5IHZ1ZS1jbGFzcy1jb21wb25lbnQgYW5kIGNvbnRhaW4gdGhlIHJlZ3VsYXIgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvcHRpb25zID0gcmVzb2x2ZWRDb21wb25lbnQuX192Y2NPcHRzIHx8IHJlc29sdmVkQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGd1YXJkID0gb3B0aW9uc1tndWFyZFR5cGVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBndWFyZCAmJiBndWFyZFRvUHJvbWlzZUZuKGd1YXJkLCB0bywgZnJvbSwgcmVjb3JkLCBuYW1lKSgpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGd1YXJkcztcclxufVxyXG4vKipcclxuICogQWxsb3dzIGRpZmZlcmVudGlhdGluZyBsYXp5IGNvbXBvbmVudHMgZnJvbSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYW5kIHZ1ZS1jbGFzcy1jb21wb25lbnRcclxuICogQHBhcmFtIGNvbXBvbmVudFxyXG4gKi9cclxuZnVuY3Rpb24gaXNSb3V0ZUNvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgfHxcclxuICAgICAgICAnZGlzcGxheU5hbWUnIGluIGNvbXBvbmVudCB8fFxyXG4gICAgICAgICdwcm9wcycgaW4gY29tcG9uZW50IHx8XHJcbiAgICAgICAgJ19fdmNjT3B0cycgaW4gY29tcG9uZW50KTtcclxufVxuXG4vLyBUT0RPOiB3ZSBjb3VsZCBhbGxvdyBjdXJyZW50Um91dGUgYXMgYSBwcm9wIHRvIGV4cG9zZSBgaXNBY3RpdmVgIGFuZFxyXG4vLyBgaXNFeGFjdEFjdGl2ZWAgYmVoYXZpb3Igc2hvdWxkIGdvIHRocm91Z2ggYW4gUkZDXHJcbmZ1bmN0aW9uIHVzZUxpbmsocHJvcHMpIHtcclxuICAgIGNvbnN0IHJvdXRlciA9IGluamVjdChyb3V0ZXJLZXkpO1xyXG4gICAgY29uc3QgY3VycmVudFJvdXRlID0gaW5qZWN0KHJvdXRlTG9jYXRpb25LZXkpO1xyXG4gICAgY29uc3Qgcm91dGUgPSBjb21wdXRlZCgoKSA9PiByb3V0ZXIucmVzb2x2ZSh1bnJlZihwcm9wcy50bykpKTtcclxuICAgIGNvbnN0IGFjdGl2ZVJlY29yZEluZGV4ID0gY29tcHV0ZWQoKCkgPT4ge1xyXG4gICAgICAgIGxldCB7IG1hdGNoZWQgfSA9IHJvdXRlLnZhbHVlO1xyXG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gbWF0Y2hlZDtcclxuICAgICAgICBjb25zdCByb3V0ZU1hdGNoZWQgPSBtYXRjaGVkW2xlbmd0aCAtIDFdO1xyXG4gICAgICAgIGxldCBjdXJyZW50TWF0Y2hlZCA9IGN1cnJlbnRSb3V0ZS5tYXRjaGVkO1xyXG4gICAgICAgIGlmICghcm91dGVNYXRjaGVkIHx8ICFjdXJyZW50TWF0Y2hlZC5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBsZXQgaW5kZXggPSBjdXJyZW50TWF0Y2hlZC5maW5kSW5kZXgoaXNTYW1lUm91dGVSZWNvcmQuYmluZChudWxsLCByb3V0ZU1hdGNoZWQpKTtcclxuICAgICAgICBpZiAoaW5kZXggPiAtMSlcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgIC8vIHBvc3NpYmxlIHBhcmVudCByZWNvcmRcclxuICAgICAgICBsZXQgcGFyZW50UmVjb3JkUGF0aCA9IGdldE9yaWdpbmFsUGF0aChtYXRjaGVkW2xlbmd0aCAtIDJdKTtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgIC8vIHdlIGFyZSBkZWFsaW5nIHdpdGggbmVzdGVkIHJvdXRlc1xyXG4gICAgICAgIGxlbmd0aCA+IDEgJiZcclxuICAgICAgICAgICAgLy8gaWYgdGhlIHBhcmVudCBhbmQgbWF0Y2hlZCByb3V0ZSBoYXZlIHRoZSBzYW1lIHBhdGgsIHRoaXMgbGluayBpc1xyXG4gICAgICAgICAgICAvLyByZWZlcnJpbmcgdG8gdGhlIGVtcHR5IGNoaWxkLiBPciB3ZSBjdXJyZW50bHkgYXJlIG9uIGEgZGlmZmVyZW50XHJcbiAgICAgICAgICAgIC8vIGNoaWxkIG9mIHRoZSBzYW1lIHBhcmVudFxyXG4gICAgICAgICAgICBnZXRPcmlnaW5hbFBhdGgocm91dGVNYXRjaGVkKSA9PT0gcGFyZW50UmVjb3JkUGF0aCAmJlxyXG4gICAgICAgICAgICAvLyBhdm9pZCBjb21wYXJpbmcgdGhlIGNoaWxkIHdpdGggaXRzIHBhcmVudFxyXG4gICAgICAgICAgICBjdXJyZW50TWF0Y2hlZFtjdXJyZW50TWF0Y2hlZC5sZW5ndGggLSAxXS5wYXRoICE9PSBwYXJlbnRSZWNvcmRQYXRoXHJcbiAgICAgICAgICAgID8gY3VycmVudE1hdGNoZWQuZmluZEluZGV4KGlzU2FtZVJvdXRlUmVjb3JkLmJpbmQobnVsbCwgbWF0Y2hlZFtsZW5ndGggLSAyXSkpXHJcbiAgICAgICAgICAgIDogaW5kZXgpO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGNvbXB1dGVkKCgpID0+IGFjdGl2ZVJlY29yZEluZGV4LnZhbHVlID4gLTEgJiZcclxuICAgICAgICBpbmNsdWRlc1BhcmFtcyhjdXJyZW50Um91dGUucGFyYW1zLCByb3V0ZS52YWx1ZS5wYXJhbXMpKTtcclxuICAgIGNvbnN0IGlzRXhhY3RBY3RpdmUgPSBjb21wdXRlZCgoKSA9PiBhY3RpdmVSZWNvcmRJbmRleC52YWx1ZSA+IC0xICYmXHJcbiAgICAgICAgYWN0aXZlUmVjb3JkSW5kZXgudmFsdWUgPT09IGN1cnJlbnRSb3V0ZS5tYXRjaGVkLmxlbmd0aCAtIDEgJiZcclxuICAgICAgICBpc1NhbWVSb3V0ZUxvY2F0aW9uUGFyYW1zKGN1cnJlbnRSb3V0ZS5wYXJhbXMsIHJvdXRlLnZhbHVlLnBhcmFtcykpO1xyXG4gICAgZnVuY3Rpb24gbmF2aWdhdGUoZSA9IHt9KSB7XHJcbiAgICAgICAgaWYgKGd1YXJkRXZlbnQoZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdXRlclt1bnJlZihwcm9wcy5yZXBsYWNlKSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10odW5yZWYocHJvcHMudG8pXHJcbiAgICAgICAgICAgIC8vIGF2b2lkIHVuY2F1Z2h0IGVycm9ycyBhcmUgdGhleSBhcmUgbG9nZ2VkIGFueXdheVxyXG4gICAgICAgICAgICApLmNhdGNoKG5vb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICAvLyBkZXZ0b29scyBvbmx5XHJcbiAgICBpZiAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pICYmIGlzQnJvd3Nlcikge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmtDb250ZXh0RGV2dG9vbHMgPSB7XHJcbiAgICAgICAgICAgICAgICByb3V0ZTogcm91dGUudmFsdWUsXHJcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZTogaXNBY3RpdmUudmFsdWUsXHJcbiAgICAgICAgICAgICAgICBpc0V4YWN0QWN0aXZlOiBpc0V4YWN0QWN0aXZlLnZhbHVlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB0aGlzIGlzIGludGVybmFsXHJcbiAgICAgICAgICAgIGluc3RhbmNlLl9fdnJsX2RldnRvb2xzID0gaW5zdGFuY2UuX192cmxfZGV2dG9vbHMgfHwgW107XHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRoaXMgaXMgaW50ZXJuYWxcclxuICAgICAgICAgICAgaW5zdGFuY2UuX192cmxfZGV2dG9vbHMucHVzaChsaW5rQ29udGV4dERldnRvb2xzKTtcclxuICAgICAgICAgICAgd2F0Y2hFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGlua0NvbnRleHREZXZ0b29scy5yb3V0ZSA9IHJvdXRlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgbGlua0NvbnRleHREZXZ0b29scy5pc0FjdGl2ZSA9IGlzQWN0aXZlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgbGlua0NvbnRleHREZXZ0b29scy5pc0V4YWN0QWN0aXZlID0gaXNFeGFjdEFjdGl2ZS52YWx1ZTtcclxuICAgICAgICAgICAgfSwgeyBmbHVzaDogJ3Bvc3QnIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcm91dGUsXHJcbiAgICAgICAgaHJlZjogY29tcHV0ZWQoKCkgPT4gcm91dGUudmFsdWUuaHJlZiksXHJcbiAgICAgICAgaXNBY3RpdmUsXHJcbiAgICAgICAgaXNFeGFjdEFjdGl2ZSxcclxuICAgICAgICBuYXZpZ2F0ZSxcclxuICAgIH07XHJcbn1cclxuY29uc3QgUm91dGVyTGlua0ltcGwgPSAvKiNfX1BVUkVfXyovIGRlZmluZUNvbXBvbmVudCh7XHJcbiAgICBuYW1lOiAnUm91dGVyTGluaycsXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIHRvOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE9iamVjdF0sXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVwbGFjZTogQm9vbGVhbixcclxuICAgICAgICBhY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgICAgIC8vIGluYWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgICAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICAgICAgY3VzdG9tOiBCb29sZWFuLFxyXG4gICAgICAgIGFyaWFDdXJyZW50VmFsdWU6IHtcclxuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiAncGFnZScsXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbiAgICB1c2VMaW5rLFxyXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgICAgIGNvbnN0IGxpbmsgPSByZWFjdGl2ZSh1c2VMaW5rKHByb3BzKSk7XHJcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBpbmplY3Qocm91dGVyS2V5KTtcclxuICAgICAgICBjb25zdCBlbENsYXNzID0gY29tcHV0ZWQoKCkgPT4gKHtcclxuICAgICAgICAgICAgW2dldExpbmtDbGFzcyhwcm9wcy5hY3RpdmVDbGFzcywgb3B0aW9ucy5saW5rQWN0aXZlQ2xhc3MsICdyb3V0ZXItbGluay1hY3RpdmUnKV06IGxpbmsuaXNBY3RpdmUsXHJcbiAgICAgICAgICAgIC8vIFtnZXRMaW5rQ2xhc3MoXHJcbiAgICAgICAgICAgIC8vICAgcHJvcHMuaW5hY3RpdmVDbGFzcyxcclxuICAgICAgICAgICAgLy8gICBvcHRpb25zLmxpbmtJbmFjdGl2ZUNsYXNzLFxyXG4gICAgICAgICAgICAvLyAgICdyb3V0ZXItbGluay1pbmFjdGl2ZSdcclxuICAgICAgICAgICAgLy8gKV06ICFsaW5rLmlzRXhhY3RBY3RpdmUsXHJcbiAgICAgICAgICAgIFtnZXRMaW5rQ2xhc3MocHJvcHMuZXhhY3RBY3RpdmVDbGFzcywgb3B0aW9ucy5saW5rRXhhY3RBY3RpdmVDbGFzcywgJ3JvdXRlci1saW5rLWV4YWN0LWFjdGl2ZScpXTogbGluay5pc0V4YWN0QWN0aXZlLFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgc2xvdHMuZGVmYXVsdChsaW5rKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmN1c3RvbVxyXG4gICAgICAgICAgICAgICAgPyBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgOiBoKCdhJywge1xyXG4gICAgICAgICAgICAgICAgICAgICdhcmlhLWN1cnJlbnQnOiBsaW5rLmlzRXhhY3RBY3RpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwcm9wcy5hcmlhQ3VycmVudFZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBocmVmOiBsaW5rLmhyZWYsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3b3VsZCBvdmVycmlkZSB1c2VyIGFkZGVkIGF0dHJzIGJ1dCBWdWUgd2lsbCBzdGlsbCBhZGRcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbGlzdGVuZXIgc28gd2UgZW5kIHVwIHRyaWdnZXJpbmcgYm90aFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGxpbmsubmF2aWdhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGVsQ2xhc3MudmFsdWUsXHJcbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbik7XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbn0pO1xyXG4vLyBleHBvcnQgdGhlIHB1YmxpYyB0eXBlIGZvciBoL3RzeCBpbmZlcmVuY2VcclxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcclxuLyoqXHJcbiAqIENvbXBvbmVudCB0byByZW5kZXIgYSBsaW5rIHRoYXQgdHJpZ2dlcnMgYSBuYXZpZ2F0aW9uIG9uIGNsaWNrLlxyXG4gKi9cclxuY29uc3QgUm91dGVyTGluayA9IFJvdXRlckxpbmtJbXBsO1xyXG5mdW5jdGlvbiBndWFyZEV2ZW50KGUpIHtcclxuICAgIC8vIGRvbid0IHJlZGlyZWN0IHdpdGggY29udHJvbCBrZXlzXHJcbiAgICBpZiAoZS5tZXRhS2V5IHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXHJcbiAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIC8vIGRvbid0IHJlZGlyZWN0IG9uIHJpZ2h0IGNsaWNrXHJcbiAgICBpZiAoZS5idXR0b24gIT09IHVuZGVmaW5lZCAmJiBlLmJ1dHRvbiAhPT0gMClcclxuICAgICAgICByZXR1cm47XHJcbiAgICAvLyBkb24ndCByZWRpcmVjdCBpZiBgdGFyZ2V0PVwiX2JsYW5rXCJgXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGdldEF0dHJpYnV0ZSBkb2VzIGV4aXN0XHJcbiAgICBpZiAoZS5jdXJyZW50VGFyZ2V0ICYmIGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUpIHtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGdldEF0dHJpYnV0ZSBleGlzdHNcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcclxuICAgICAgICBpZiAoL1xcYl9ibGFua1xcYi9pLnRlc3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gdGhpcyBtYXkgYmUgYSBXZWV4IGV2ZW50IHdoaWNoIGRvZXNuJ3QgaGF2ZSB0aGlzIG1ldGhvZFxyXG4gICAgaWYgKGUucHJldmVudERlZmF1bHQpXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gaW5jbHVkZXNQYXJhbXMob3V0ZXIsIGlubmVyKSB7XHJcbiAgICBmb3IgKGxldCBrZXkgaW4gaW5uZXIpIHtcclxuICAgICAgICBsZXQgaW5uZXJWYWx1ZSA9IGlubmVyW2tleV07XHJcbiAgICAgICAgbGV0IG91dGVyVmFsdWUgPSBvdXRlcltrZXldO1xyXG4gICAgICAgIGlmICh0eXBlb2YgaW5uZXJWYWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKGlubmVyVmFsdWUgIT09IG91dGVyVmFsdWUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3V0ZXJWYWx1ZSkgfHxcclxuICAgICAgICAgICAgICAgIG91dGVyVmFsdWUubGVuZ3RoICE9PSBpbm5lclZhbHVlLmxlbmd0aCB8fFxyXG4gICAgICAgICAgICAgICAgaW5uZXJWYWx1ZS5zb21lKCh2YWx1ZSwgaSkgPT4gdmFsdWUgIT09IG91dGVyVmFsdWVbaV0pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBHZXQgdGhlIG9yaWdpbmFsIHBhdGggdmFsdWUgb2YgYSByZWNvcmQgYnkgZm9sbG93aW5nIGl0cyBhbGlhc09mXHJcbiAqIEBwYXJhbSByZWNvcmRcclxuICovXHJcbmZ1bmN0aW9uIGdldE9yaWdpbmFsUGF0aChyZWNvcmQpIHtcclxuICAgIHJldHVybiByZWNvcmQgPyAocmVjb3JkLmFsaWFzT2YgPyByZWNvcmQuYWxpYXNPZi5wYXRoIDogcmVjb3JkLnBhdGgpIDogJyc7XHJcbn1cclxuLyoqXHJcbiAqIFV0aWxpdHkgY2xhc3MgdG8gZ2V0IHRoZSBhY3RpdmUgY2xhc3MgYmFzZWQgb24gZGVmYXVsdHMuXHJcbiAqIEBwYXJhbSBwcm9wQ2xhc3NcclxuICogQHBhcmFtIGdsb2JhbENsYXNzXHJcbiAqIEBwYXJhbSBkZWZhdWx0Q2xhc3NcclxuICovXHJcbmNvbnN0IGdldExpbmtDbGFzcyA9IChwcm9wQ2xhc3MsIGdsb2JhbENsYXNzLCBkZWZhdWx0Q2xhc3MpID0+IHByb3BDbGFzcyAhPSBudWxsXHJcbiAgICA/IHByb3BDbGFzc1xyXG4gICAgOiBnbG9iYWxDbGFzcyAhPSBudWxsXHJcbiAgICAgICAgPyBnbG9iYWxDbGFzc1xyXG4gICAgICAgIDogZGVmYXVsdENsYXNzO1xuXG5jb25zdCBSb3V0ZXJWaWV3SW1wbCA9IC8qI19fUFVSRV9fKi8gZGVmaW5lQ29tcG9uZW50KHtcclxuICAgIG5hbWU6ICdSb3V0ZXJWaWV3JyxcclxuICAgIC8vICM2NzQgd2UgbWFudWFsbHkgaW5oZXJpdCB0aGVtXHJcbiAgICBpbmhlcml0QXR0cnM6IGZhbHNlLFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBuYW1lOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm91dGU6IE9iamVjdCxcclxuICAgIH0sXHJcbiAgICBzZXR1cChwcm9wcywgeyBhdHRycywgc2xvdHMgfSkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuRGVwcmVjYXRlZFVzYWdlKCk7XHJcbiAgICAgICAgY29uc3QgaW5qZWN0ZWRSb3V0ZSA9IGluamVjdChyb3V0ZXJWaWV3TG9jYXRpb25LZXkpO1xyXG4gICAgICAgIGNvbnN0IHJvdXRlVG9EaXNwbGF5ID0gY29tcHV0ZWQoKCkgPT4gcHJvcHMucm91dGUgfHwgaW5qZWN0ZWRSb3V0ZS52YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgZGVwdGggPSBpbmplY3Qodmlld0RlcHRoS2V5LCAwKTtcclxuICAgICAgICBjb25zdCBtYXRjaGVkUm91dGVSZWYgPSBjb21wdXRlZCgoKSA9PiByb3V0ZVRvRGlzcGxheS52YWx1ZS5tYXRjaGVkW2RlcHRoXSk7XHJcbiAgICAgICAgcHJvdmlkZSh2aWV3RGVwdGhLZXksIGRlcHRoICsgMSk7XHJcbiAgICAgICAgcHJvdmlkZShtYXRjaGVkUm91dGVLZXksIG1hdGNoZWRSb3V0ZVJlZik7XHJcbiAgICAgICAgcHJvdmlkZShyb3V0ZXJWaWV3TG9jYXRpb25LZXksIHJvdXRlVG9EaXNwbGF5KTtcclxuICAgICAgICBjb25zdCB2aWV3UmVmID0gcmVmKCk7XHJcbiAgICAgICAgLy8gd2F0Y2ggYXQgdGhlIHNhbWUgdGltZSB0aGUgY29tcG9uZW50IGluc3RhbmNlLCB0aGUgcm91dGUgcmVjb3JkIHdlIGFyZVxyXG4gICAgICAgIC8vIHJlbmRlcmluZywgYW5kIHRoZSBuYW1lXHJcbiAgICAgICAgd2F0Y2goKCkgPT4gW3ZpZXdSZWYudmFsdWUsIG1hdGNoZWRSb3V0ZVJlZi52YWx1ZSwgcHJvcHMubmFtZV0sIChbaW5zdGFuY2UsIHRvLCBuYW1lXSwgW29sZEluc3RhbmNlLCBmcm9tLCBvbGROYW1lXSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBjb3B5IHJldXNlZCBpbnN0YW5jZXNcclxuICAgICAgICAgICAgaWYgKHRvKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgdXBkYXRlIHRoZSBpbnN0YW5jZSBmb3IgbmV3IGluc3RhbmNlcyBhcyB3ZWxsIGFzIHJldXNlZFxyXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2VzIHdoZW4gbmF2aWdhdGluZyB0byBhIG5ldyByb3V0ZVxyXG4gICAgICAgICAgICAgICAgdG8uaW5zdGFuY2VzW25hbWVdID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29tcG9uZW50IGluc3RhbmNlIGlzIHJldXNlZCBmb3IgYSBkaWZmZXJlbnQgcm91dGUgb3IgbmFtZSBzb1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgY29weSBhbnkgc2F2ZWQgdXBkYXRlIG9yIGxlYXZlIGd1YXJkcy4gV2l0aCBhc3luYyBzZXR1cCwgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudGluZyBjb21wb25lbnQgd2lsbCBtb3VudCBiZWZvcmUgdGhlIG1hdGNoZWRSb3V0ZSBjaGFuZ2VzLFxyXG4gICAgICAgICAgICAgICAgLy8gbWFraW5nIGluc3RhbmNlID09PSBvbGRJbnN0YW5jZSwgc28gd2UgY2hlY2sgaWYgZ3VhcmRzIGhhdmUgYmVlblxyXG4gICAgICAgICAgICAgICAgLy8gYWRkZWQgYmVmb3JlLiBUaGlzIHdvcmtzIGJlY2F1c2Ugd2UgcmVtb3ZlIGd1YXJkcyB3aGVuXHJcbiAgICAgICAgICAgICAgICAvLyB1bm1vdW50aW5nL2RlYWN0aXZhdGluZyBjb21wb25lbnRzXHJcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSAmJiBmcm9tICE9PSB0byAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZSA9PT0gb2xkSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvLmxlYXZlR3VhcmRzLnNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG8ubGVhdmVHdWFyZHMgPSBmcm9tLmxlYXZlR3VhcmRzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvLnVwZGF0ZUd1YXJkcy5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvLnVwZGF0ZUd1YXJkcyA9IGZyb20udXBkYXRlR3VhcmRzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGJlZm9yZVJvdXRlRW50ZXIgbmV4dCBjYWxsYmFja3NcclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmXHJcbiAgICAgICAgICAgICAgICB0byAmJlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gaW5zdGFuY2UgYnV0IHRvIGFuZCBmcm9tIGFyZSB0aGUgc2FtZSB0aGlzIG1pZ2h0IGJlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3QgdmlzaXRcclxuICAgICAgICAgICAgICAgICghZnJvbSB8fCAhaXNTYW1lUm91dGVSZWNvcmQodG8sIGZyb20pIHx8ICFvbGRJbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgICh0by5lbnRlckNhbGxiYWNrc1tuYW1lXSB8fCBbXSkuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayhpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgeyBmbHVzaDogJ3Bvc3QnIH0pO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm91dGVUb0Rpc3BsYXkudmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRSb3V0ZSA9IG1hdGNoZWRSb3V0ZVJlZi52YWx1ZTtcclxuICAgICAgICAgICAgY29uc3QgVmlld0NvbXBvbmVudCA9IG1hdGNoZWRSb3V0ZSAmJiBtYXRjaGVkUm91dGUuY29tcG9uZW50c1twcm9wcy5uYW1lXTtcclxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGUgdmFsdWUgYXQgdGhlIHRpbWUgd2UgcmVuZGVyIGJlY2F1c2Ugd2hlbiB3ZSB1bm1vdW50LCB3ZVxyXG4gICAgICAgICAgICAvLyBuYXZpZ2F0ZWQgdG8gYSBkaWZmZXJlbnQgbG9jYXRpb24gc28gdGhlIHZhbHVlIGlzIGRpZmZlcmVudFxyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TmFtZSA9IHByb3BzLm5hbWU7XHJcbiAgICAgICAgICAgIGlmICghVmlld0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNsb3Qoc2xvdHMuZGVmYXVsdCwgeyBDb21wb25lbnQ6IFZpZXdDb21wb25lbnQsIHJvdXRlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByb3BzIGZyb20gcm91dGUgY29uZmlndXJhdGlvblxyXG4gICAgICAgICAgICBjb25zdCByb3V0ZVByb3BzT3B0aW9uID0gbWF0Y2hlZFJvdXRlLnByb3BzW3Byb3BzLm5hbWVdO1xyXG4gICAgICAgICAgICBjb25zdCByb3V0ZVByb3BzID0gcm91dGVQcm9wc09wdGlvblxyXG4gICAgICAgICAgICAgICAgPyByb3V0ZVByb3BzT3B0aW9uID09PSB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgPyByb3V0ZS5wYXJhbXNcclxuICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiByb3V0ZVByb3BzT3B0aW9uID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcm91dGVQcm9wc09wdGlvbihyb3V0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByb3V0ZVByb3BzT3B0aW9uXHJcbiAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IG9uVm5vZGVVbm1vdW50ZWQgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGluc3RhbmNlIHJlZmVyZW5jZSB0byBwcmV2ZW50IGxlYWtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZS5jb21wb25lbnQuaXNVbm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkUm91dGUuaW5zdGFuY2VzW2N1cnJlbnROYW1lXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGgoVmlld0NvbXBvbmVudCwgYXNzaWduKHt9LCByb3V0ZVByb3BzLCBhdHRycywge1xyXG4gICAgICAgICAgICAgICAgb25Wbm9kZVVubW91bnRlZCxcclxuICAgICAgICAgICAgICAgIHJlZjogdmlld1JlZixcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAvLyBwYXNzIHRoZSB2bm9kZSB0byB0aGUgc2xvdCBhcyBhIHByb3AuXHJcbiAgICAgICAgICAgIC8vIGggYW5kIDxjb21wb25lbnQgOmlzPVwiLi4uXCI+IGJvdGggYWNjZXB0IHZub2Rlc1xyXG4gICAgICAgICAgICBub3JtYWxpemVTbG90KHNsb3RzLmRlZmF1bHQsIHsgQ29tcG9uZW50OiBjb21wb25lbnQsIHJvdXRlIH0pIHx8XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG59KTtcclxuZnVuY3Rpb24gbm9ybWFsaXplU2xvdChzbG90LCBkYXRhKSB7XHJcbiAgICBpZiAoIXNsb3QpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBjb25zdCBzbG90Q29udGVudCA9IHNsb3QoZGF0YSk7XHJcbiAgICByZXR1cm4gc2xvdENvbnRlbnQubGVuZ3RoID09PSAxID8gc2xvdENvbnRlbnRbMF0gOiBzbG90Q29udGVudDtcclxufVxyXG4vLyBleHBvcnQgdGhlIHB1YmxpYyB0eXBlIGZvciBoL3RzeCBpbmZlcmVuY2VcclxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcclxuLyoqXHJcbiAqIENvbXBvbmVudCB0byBkaXNwbGF5IHRoZSBjdXJyZW50IHJvdXRlIHRoZSB1c2VyIGlzIGF0LlxyXG4gKi9cclxuY29uc3QgUm91dGVyVmlldyA9IFJvdXRlclZpZXdJbXBsO1xyXG4vLyB3YXJuIGFnYWluc3QgZGVwcmVjYXRlZCB1c2FnZSB3aXRoIDx0cmFuc2l0aW9uPiAmIDxrZWVwLWFsaXZlPlxyXG4vLyBkdWUgdG8gZnVuY3Rpb25hbCBjb21wb25lbnQgYmVpbmcgbm8gbG9uZ2VyIGVhZ2VyIGluIFZ1ZSAzXHJcbmZ1bmN0aW9uIHdhcm5EZXByZWNhdGVkVXNhZ2UoKSB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgY29uc3QgcGFyZW50TmFtZSA9IGluc3RhbmNlLnBhcmVudCAmJiBpbnN0YW5jZS5wYXJlbnQudHlwZS5uYW1lO1xyXG4gICAgaWYgKHBhcmVudE5hbWUgJiZcclxuICAgICAgICAocGFyZW50TmFtZSA9PT0gJ0tlZXBBbGl2ZScgfHwgcGFyZW50TmFtZS5pbmNsdWRlcygnVHJhbnNpdGlvbicpKSkge1xyXG4gICAgICAgIGNvbnN0IGNvbXAgPSBwYXJlbnROYW1lID09PSAnS2VlcEFsaXZlJyA/ICdrZWVwLWFsaXZlJyA6ICd0cmFuc2l0aW9uJztcclxuICAgICAgICB3YXJuKGA8cm91dGVyLXZpZXc+IGNhbiBubyBsb25nZXIgYmUgdXNlZCBkaXJlY3RseSBpbnNpZGUgPHRyYW5zaXRpb24+IG9yIDxrZWVwLWFsaXZlPi5cXG5gICtcclxuICAgICAgICAgICAgYFVzZSBzbG90IHByb3BzIGluc3RlYWQ6XFxuXFxuYCArXHJcbiAgICAgICAgICAgIGA8cm91dGVyLXZpZXcgdi1zbG90PVwieyBDb21wb25lbnQgfVwiPlxcbmAgK1xyXG4gICAgICAgICAgICBgICA8JHtjb21wfT5cXG5gICtcclxuICAgICAgICAgICAgYCAgICA8Y29tcG9uZW50IDppcz1cIkNvbXBvbmVudFwiIC8+XFxuYCArXHJcbiAgICAgICAgICAgIGAgIDwvJHtjb21wfT5cXG5gICtcclxuICAgICAgICAgICAgYDwvcm91dGVyLXZpZXc+YCk7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZm9ybWF0Um91dGVMb2NhdGlvbihyb3V0ZUxvY2F0aW9uLCB0b29sdGlwKSB7XHJcbiAgICBjb25zdCBjb3B5ID0gYXNzaWduKHt9LCByb3V0ZUxvY2F0aW9uLCB7XHJcbiAgICAgICAgLy8gcmVtb3ZlIHZhcmlhYmxlcyB0aGF0IGNhbiBjb250YWluIHZ1ZSBpbnN0YW5jZXNcclxuICAgICAgICBtYXRjaGVkOiByb3V0ZUxvY2F0aW9uLm1hdGNoZWQubWFwKG1hdGNoZWQgPT4gb21pdChtYXRjaGVkLCBbJ2luc3RhbmNlcycsICdjaGlsZHJlbicsICdhbGlhc09mJ10pKSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBfY3VzdG9tOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IG51bGwsXHJcbiAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxyXG4gICAgICAgICAgICBkaXNwbGF5OiByb3V0ZUxvY2F0aW9uLmZ1bGxQYXRoLFxyXG4gICAgICAgICAgICB0b29sdGlwLFxyXG4gICAgICAgICAgICB2YWx1ZTogY29weSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBmb3JtYXREaXNwbGF5KGRpc3BsYXkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgX2N1c3RvbToge1xyXG4gICAgICAgICAgICBkaXNwbGF5LFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbi8vIHRvIHN1cHBvcnQgbXVsdGlwbGUgcm91dGVyIGluc3RhbmNlc1xyXG5sZXQgcm91dGVySWQgPSAwO1xyXG5mdW5jdGlvbiBhZGREZXZ0b29scyhhcHAsIHJvdXRlciwgbWF0Y2hlcikge1xyXG4gICAgLy8gVGFrZSBvdmVyIHJvdXRlci5iZWZvcmVFYWNoIGFuZCBhZnRlckVhY2hcclxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBhcmUgbm90IHJlZ2lzdGVyaW5nIHRoZSBkZXZ0b29sIHR3aWNlXHJcbiAgICBpZiAocm91dGVyLl9faGFzRGV2dG9vbHMpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgcm91dGVyLl9faGFzRGV2dG9vbHMgPSB0cnVlO1xyXG4gICAgLy8gaW5jcmVtZW50IHRvIHN1cHBvcnQgbXVsdGlwbGUgcm91dGVyIGluc3RhbmNlc1xyXG4gICAgY29uc3QgaWQgPSByb3V0ZXJJZCsrO1xyXG4gICAgc2V0dXBEZXZ0b29sc1BsdWdpbih7XHJcbiAgICAgICAgaWQ6ICdvcmcudnVlanMucm91dGVyJyArIChpZCA/ICcuJyArIGlkIDogJycpLFxyXG4gICAgICAgIGxhYmVsOiAnVnVlIFJvdXRlcicsXHJcbiAgICAgICAgcGFja2FnZU5hbWU6ICd2dWUtcm91dGVyJyxcclxuICAgICAgICBob21lcGFnZTogJ2h0dHBzOi8vbmV4dC5yb3V0ZXIudnVlanMub3JnLycsXHJcbiAgICAgICAgbG9nbzogJ2h0dHBzOi8vdnVlanMub3JnL2ltYWdlcy9pY29ucy9mYXZpY29uLTk2eDk2LnBuZycsXHJcbiAgICAgICAgY29tcG9uZW50U3RhdGVUeXBlczogWydSb3V0aW5nJ10sXHJcbiAgICAgICAgYXBwLFxyXG4gICAgfSwgYXBpID0+IHtcclxuICAgICAgICAvLyBkaXNwbGF5IHN0YXRlIGFkZGVkIGJ5IHRoZSByb3V0ZXJcclxuICAgICAgICBhcGkub24uaW5zcGVjdENvbXBvbmVudCgocGF5bG9hZCwgY3R4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmluc3RhbmNlRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pbnN0YW5jZURhdGEuc3RhdGUucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JvdXRpbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleTogJyRyb3V0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmb3JtYXRSb3V0ZUxvY2F0aW9uKHJvdXRlci5jdXJyZW50Um91dGUudmFsdWUsICdDdXJyZW50IFJvdXRlJyksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIG1hcmsgcm91dGVyLWxpbmsgYXMgYWN0aXZlXHJcbiAgICAgICAgYXBpLm9uLnZpc2l0Q29tcG9uZW50VHJlZSgoeyB0cmVlTm9kZTogbm9kZSwgY29tcG9uZW50SW5zdGFuY2UgfSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBpZiBtdWx0aXBsZSB1c2VMaW5rIGFyZSB1c2VkXHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbXBvbmVudEluc3RhbmNlLl9fdnJsX2RldnRvb2xzKSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuX19kZXZ0b29sc0FwaSA9IGFwaTtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9fdnJsX2RldnRvb2xzLmZvckVhY2goZGV2dG9vbHNEYXRhID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYmFja2dyb3VuZENvbG9yID0gT1JBTkdFXzQwMDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdG9vbHRpcCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXZ0b29sc0RhdGEuaXNFeGFjdEFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBMSU1FXzUwMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcCA9ICdUaGlzIGlzIGV4YWN0bHkgYWN0aXZlJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGV2dG9vbHNEYXRhLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IEJMVUVfNjAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwID0gJ1RoaXMgbGluayBpcyBhY3RpdmUnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBub2RlLnRhZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBkZXZ0b29sc0RhdGEucm91dGUucGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbG9yOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHdhdGNoKHJvdXRlci5jdXJyZW50Um91dGUsICgpID0+IHtcclxuICAgICAgICAgICAgLy8gcmVmcmVzaCBhY3RpdmUgc3RhdGVcclxuICAgICAgICAgICAgcmVmcmVzaFJvdXRlc1ZpZXcoKTtcclxuICAgICAgICAgICAgYXBpLm5vdGlmeUNvbXBvbmVudFVwZGF0ZSgpO1xyXG4gICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclRyZWUocm91dGVySW5zcGVjdG9ySWQpO1xyXG4gICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclN0YXRlKHJvdXRlckluc3BlY3RvcklkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBuYXZpZ2F0aW9uc0xheWVySWQgPSAncm91dGVyOm5hdmlnYXRpb25zOicgKyBpZDtcclxuICAgICAgICBhcGkuYWRkVGltZWxpbmVMYXllcih7XHJcbiAgICAgICAgICAgIGlkOiBuYXZpZ2F0aW9uc0xheWVySWQsXHJcbiAgICAgICAgICAgIGxhYmVsOiBgUm91dGVyJHtpZCA/ICcgJyArIGlkIDogJyd9IE5hdmlnYXRpb25zYCxcclxuICAgICAgICAgICAgY29sb3I6IDB4NDBhOGM0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGNvbnN0IGVycm9yc0xheWVySWQgPSAncm91dGVyOmVycm9ycydcclxuICAgICAgICAvLyBhcGkuYWRkVGltZWxpbmVMYXllcih7XHJcbiAgICAgICAgLy8gICBpZDogZXJyb3JzTGF5ZXJJZCxcclxuICAgICAgICAvLyAgIGxhYmVsOiAnUm91dGVyIEVycm9ycycsXHJcbiAgICAgICAgLy8gICBjb2xvcjogMHhlYTU0NTUsXHJcbiAgICAgICAgLy8gfSlcclxuICAgICAgICByb3V0ZXIub25FcnJvcigoZXJyb3IsIHRvKSA9PiB7XHJcbiAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcclxuICAgICAgICAgICAgICAgIGxheWVySWQ6IG5hdmlnYXRpb25zTGF5ZXJJZCxcclxuICAgICAgICAgICAgICAgIGV2ZW50OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdFcnJvciBkdXJpbmcgTmF2aWdhdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU6IHRvLmZ1bGxQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvZ1R5cGU6ICdlcnJvcicsXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IGVycm9yIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogdG8ubWV0YS5fX25hdmlnYXRpb25JZCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGF0dGFjaGVkIHRvIGBtZXRhYCBhbmQgdXNlZCB0byBncm91cCBldmVudHNcclxuICAgICAgICBsZXQgbmF2aWdhdGlvbklkID0gMDtcclxuICAgICAgICByb3V0ZXIuYmVmb3JlRWFjaCgodG8sIGZyb20pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGd1YXJkOiBmb3JtYXREaXNwbGF5KCdiZWZvcmVFYWNoJyksXHJcbiAgICAgICAgICAgICAgICBmcm9tOiBmb3JtYXRSb3V0ZUxvY2F0aW9uKGZyb20sICdDdXJyZW50IExvY2F0aW9uIGR1cmluZyB0aGlzIG5hdmlnYXRpb24nKSxcclxuICAgICAgICAgICAgICAgIHRvOiBmb3JtYXRSb3V0ZUxvY2F0aW9uKHRvLCAnVGFyZ2V0IGxvY2F0aW9uJyksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIFVzZWQgdG8gZ3JvdXAgbmF2aWdhdGlvbnMgdG9nZXRoZXIsIGhpZGUgZnJvbSBkZXZ0b29sc1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodG8ubWV0YSwgJ19fbmF2aWdhdGlvbklkJywge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hdmlnYXRpb25JZCsrLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgbGF5ZXJJZDogbmF2aWdhdGlvbnNMYXllcklkLFxyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnU3RhcnQgb2YgbmF2aWdhdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU6IHRvLmZ1bGxQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogdG8ubWV0YS5fX25hdmlnYXRpb25JZCxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJvdXRlci5hZnRlckVhY2goKHRvLCBmcm9tLCBmYWlsdXJlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBndWFyZDogZm9ybWF0RGlzcGxheSgnYWZ0ZXJFYWNoJyksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhLmZhaWx1cmUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2N1c3RvbToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFcnJvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZE9ubHk6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZhaWx1cmUgPyBmYWlsdXJlLm1lc3NhZ2UgOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ05hdmlnYXRpb24gRmFpbHVyZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmYWlsdXJlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgZGF0YS5zdGF0dXMgPSBmb3JtYXREaXNwbGF5KCfinYwnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhdGEuc3RhdHVzID0gZm9ybWF0RGlzcGxheSgn4pyFJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd2Ugc2V0IGhlcmUgdG8gaGF2ZSB0aGUgcmlnaHQgb3JkZXJcclxuICAgICAgICAgICAgZGF0YS5mcm9tID0gZm9ybWF0Um91dGVMb2NhdGlvbihmcm9tLCAnQ3VycmVudCBMb2NhdGlvbiBkdXJpbmcgdGhpcyBuYXZpZ2F0aW9uJyk7XHJcbiAgICAgICAgICAgIGRhdGEudG8gPSBmb3JtYXRSb3V0ZUxvY2F0aW9uKHRvLCAnVGFyZ2V0IGxvY2F0aW9uJyk7XHJcbiAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcclxuICAgICAgICAgICAgICAgIGxheWVySWQ6IG5hdmlnYXRpb25zTGF5ZXJJZCxcclxuICAgICAgICAgICAgICAgIGV2ZW50OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdFbmQgb2YgbmF2aWdhdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU6IHRvLmZ1bGxQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBsb2dUeXBlOiBmYWlsdXJlID8gJ3dhcm5pbmcnIDogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSWQ6IHRvLm1ldGEuX19uYXZpZ2F0aW9uSWQsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnNwZWN0b3Igb2YgRXhpc3Rpbmcgcm91dGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uc3Qgcm91dGVySW5zcGVjdG9ySWQgPSAncm91dGVyLWluc3BlY3RvcjonICsgaWQ7XHJcbiAgICAgICAgYXBpLmFkZEluc3BlY3Rvcih7XHJcbiAgICAgICAgICAgIGlkOiByb3V0ZXJJbnNwZWN0b3JJZCxcclxuICAgICAgICAgICAgbGFiZWw6ICdSb3V0ZXMnICsgKGlkID8gJyAnICsgaWQgOiAnJyksXHJcbiAgICAgICAgICAgIGljb246ICdib29rJyxcclxuICAgICAgICAgICAgdHJlZUZpbHRlclBsYWNlaG9sZGVyOiAnU2VhcmNoIHJvdXRlcycsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZnVuY3Rpb24gcmVmcmVzaFJvdXRlc1ZpZXcoKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSByb3V0ZXMgdmlldyBpc24ndCBhY3RpdmVcclxuICAgICAgICAgICAgaWYgKCFhY3RpdmVSb3V0ZXNQYXlsb2FkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYWN0aXZlUm91dGVzUGF5bG9hZDtcclxuICAgICAgICAgICAgLy8gY2hpbGRyZW4gcm91dGVzIHdpbGwgYXBwZWFyIGFzIG5lc3RlZFxyXG4gICAgICAgICAgICBsZXQgcm91dGVzID0gbWF0Y2hlci5nZXRSb3V0ZXMoKS5maWx0ZXIocm91dGUgPT4gIXJvdXRlLnBhcmVudCk7XHJcbiAgICAgICAgICAgIC8vIHJlc2V0IG1hdGNoIHN0YXRlIHRvIGZhbHNlXHJcbiAgICAgICAgICAgIHJvdXRlcy5mb3JFYWNoKHJlc2V0TWF0Y2hTdGF0ZU9uUm91dGVSZWNvcmQpO1xyXG4gICAgICAgICAgICAvLyBhcHBseSBhIG1hdGNoIHN0YXRlIGlmIHRoZXJlIGlzIGEgcGF5bG9hZFxyXG4gICAgICAgICAgICBpZiAocGF5bG9hZC5maWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHJvdXRlcyA9IHJvdXRlcy5maWx0ZXIocm91dGUgPT4gXHJcbiAgICAgICAgICAgICAgICAvLyBzYXZlIG1hdGNoZXMgc3RhdGUgYmFzZWQgb24gdGhlIHBheWxvYWRcclxuICAgICAgICAgICAgICAgIGlzUm91dGVNYXRjaGluZyhyb3V0ZSwgcGF5bG9hZC5maWx0ZXIudG9Mb3dlckNhc2UoKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG1hcmsgYWN0aXZlIHJvdXRlc1xyXG4gICAgICAgICAgICByb3V0ZXMuZm9yRWFjaChyb3V0ZSA9PiBtYXJrUm91dGVSZWNvcmRBY3RpdmUocm91dGUsIHJvdXRlci5jdXJyZW50Um91dGUudmFsdWUpKTtcclxuICAgICAgICAgICAgcGF5bG9hZC5yb290Tm9kZXMgPSByb3V0ZXMubWFwKGZvcm1hdFJvdXRlUmVjb3JkRm9ySW5zcGVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGFjdGl2ZVJvdXRlc1BheWxvYWQ7XHJcbiAgICAgICAgYXBpLm9uLmdldEluc3BlY3RvclRyZWUocGF5bG9hZCA9PiB7XHJcbiAgICAgICAgICAgIGFjdGl2ZVJvdXRlc1BheWxvYWQgPSBwYXlsb2FkO1xyXG4gICAgICAgICAgICBpZiAocGF5bG9hZC5hcHAgPT09IGFwcCAmJiBwYXlsb2FkLmluc3BlY3RvcklkID09PSByb3V0ZXJJbnNwZWN0b3JJZCkge1xyXG4gICAgICAgICAgICAgICAgcmVmcmVzaFJvdXRlc1ZpZXcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc3BsYXkgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCByb3V0ZSByZWNvcmRcclxuICAgICAgICAgKi9cclxuICAgICAgICBhcGkub24uZ2V0SW5zcGVjdG9yU3RhdGUocGF5bG9hZCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmFwcCA9PT0gYXBwICYmIHBheWxvYWQuaW5zcGVjdG9ySWQgPT09IHJvdXRlckluc3BlY3RvcklkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZXMgPSBtYXRjaGVyLmdldFJvdXRlcygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGUgPSByb3V0ZXMuZmluZChyb3V0ZSA9PiByb3V0ZS5yZWNvcmQuX192ZF9pZCA9PT0gcGF5bG9hZC5ub2RlSWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogZm9ybWF0Um91dGVSZWNvcmRNYXRjaGVyRm9yU3RhdGVJbnNwZWN0b3Iocm91dGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhcGkuc2VuZEluc3BlY3RvclRyZWUocm91dGVySW5zcGVjdG9ySWQpO1xyXG4gICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUocm91dGVySW5zcGVjdG9ySWQpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gbW9kaWZpZXJGb3JLZXkoa2V5KSB7XHJcbiAgICBpZiAoa2V5Lm9wdGlvbmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIGtleS5yZXBlYXRhYmxlID8gJyonIDogJz8nO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGtleS5yZXBlYXRhYmxlID8gJysnIDogJyc7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0Um91dGVSZWNvcmRNYXRjaGVyRm9yU3RhdGVJbnNwZWN0b3Iocm91dGUpIHtcclxuICAgIGNvbnN0IHsgcmVjb3JkIH0gPSByb3V0ZTtcclxuICAgIGNvbnN0IGZpZWxkcyA9IFtcclxuICAgICAgICB7IGVkaXRhYmxlOiBmYWxzZSwga2V5OiAncGF0aCcsIHZhbHVlOiByZWNvcmQucGF0aCB9LFxyXG4gICAgXTtcclxuICAgIGlmIChyZWNvcmQubmFtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgZmllbGRzLnB1c2goe1xyXG4gICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGtleTogJ25hbWUnLFxyXG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLm5hbWUsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmaWVsZHMucHVzaCh7IGVkaXRhYmxlOiBmYWxzZSwga2V5OiAncmVnZXhwJywgdmFsdWU6IHJvdXRlLnJlIH0pO1xyXG4gICAgaWYgKHJvdXRlLmtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgZmllbGRzLnB1c2goe1xyXG4gICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGtleTogJ2tleXMnLFxyXG4gICAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICAgICAgX2N1c3RvbToge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZE9ubHk6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogcm91dGUua2V5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGtleSA9PiBgJHtrZXkubmFtZX0ke21vZGlmaWVyRm9yS2V5KGtleSl9YClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKSxcclxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAnUGFyYW0ga2V5cycsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJvdXRlLmtleXMsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlY29yZC5yZWRpcmVjdCAhPSBudWxsKSB7XHJcbiAgICAgICAgZmllbGRzLnB1c2goe1xyXG4gICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGtleTogJ3JlZGlyZWN0JyxcclxuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5yZWRpcmVjdCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChyb3V0ZS5hbGlhcy5sZW5ndGgpIHtcclxuICAgICAgICBmaWVsZHMucHVzaCh7XHJcbiAgICAgICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAga2V5OiAnYWxpYXNlcycsXHJcbiAgICAgICAgICAgIHZhbHVlOiByb3V0ZS5hbGlhcy5tYXAoYWxpYXMgPT4gYWxpYXMucmVjb3JkLnBhdGgpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZmllbGRzLnB1c2goe1xyXG4gICAgICAgIGtleTogJ3Njb3JlJyxcclxuICAgICAgICBlZGl0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgdmFsdWU6IHtcclxuICAgICAgICAgICAgX2N1c3RvbToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogcm91dGUuc2NvcmUubWFwKHNjb3JlID0+IHNjb3JlLmpvaW4oJywgJykpLmpvaW4oJyB8ICcpLFxyXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogJ1Njb3JlIHVzZWQgdG8gc29ydCByb3V0ZXMnLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJvdXRlLnNjb3JlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBmaWVsZHM7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3RlZCBmcm9tIHRhaWx3aW5kIHBhbGV0dGVcclxuICovXHJcbmNvbnN0IFBJTktfNTAwID0gMHhlYzQ4OTk7XHJcbmNvbnN0IEJMVUVfNjAwID0gMHgyNTYzZWI7XHJcbmNvbnN0IExJTUVfNTAwID0gMHg4NGNjMTY7XHJcbmNvbnN0IENZQU5fNDAwID0gMHgyMmQzZWU7XHJcbmNvbnN0IE9SQU5HRV80MDAgPSAweGZiOTIzYztcclxuLy8gY29uc3QgR1JBWV8xMDAgPSAweGY0ZjRmNVxyXG5jb25zdCBEQVJLID0gMHg2NjY2NjY7XHJcbmZ1bmN0aW9uIGZvcm1hdFJvdXRlUmVjb3JkRm9ySW5zcGVjdG9yKHJvdXRlKSB7XHJcbiAgICBjb25zdCB0YWdzID0gW107XHJcbiAgICBjb25zdCB7IHJlY29yZCB9ID0gcm91dGU7XHJcbiAgICBpZiAocmVjb3JkLm5hbWUgIT0gbnVsbCkge1xyXG4gICAgICAgIHRhZ3MucHVzaCh7XHJcbiAgICAgICAgICAgIGxhYmVsOiBTdHJpbmcocmVjb3JkLm5hbWUpLFxyXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IDAsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogQ1lBTl80MDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAocmVjb3JkLmFsaWFzT2YpIHtcclxuICAgICAgICB0YWdzLnB1c2goe1xyXG4gICAgICAgICAgICBsYWJlbDogJ2FsaWFzJyxcclxuICAgICAgICAgICAgdGV4dENvbG9yOiAwLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IE9SQU5HRV80MDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAocm91dGUuX192ZF9tYXRjaCkge1xyXG4gICAgICAgIHRhZ3MucHVzaCh7XHJcbiAgICAgICAgICAgIGxhYmVsOiAnbWF0Y2hlcycsXHJcbiAgICAgICAgICAgIHRleHRDb2xvcjogMCxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBQSU5LXzUwMCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChyb3V0ZS5fX3ZkX2V4YWN0QWN0aXZlKSB7XHJcbiAgICAgICAgdGFncy5wdXNoKHtcclxuICAgICAgICAgICAgbGFiZWw6ICdleGFjdCcsXHJcbiAgICAgICAgICAgIHRleHRDb2xvcjogMCxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBMSU1FXzUwMCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChyb3V0ZS5fX3ZkX2FjdGl2ZSkge1xyXG4gICAgICAgIHRhZ3MucHVzaCh7XHJcbiAgICAgICAgICAgIGxhYmVsOiAnYWN0aXZlJyxcclxuICAgICAgICAgICAgdGV4dENvbG9yOiAwLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IEJMVUVfNjAwLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlY29yZC5yZWRpcmVjdCkge1xyXG4gICAgICAgIHRhZ3MucHVzaCh7XHJcbiAgICAgICAgICAgIGxhYmVsOiAncmVkaXJlY3Q6ICcgK1xyXG4gICAgICAgICAgICAgICAgKHR5cGVvZiByZWNvcmQucmVkaXJlY3QgPT09ICdzdHJpbmcnID8gcmVjb3JkLnJlZGlyZWN0IDogJ09iamVjdCcpLFxyXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IDB4ZmZmZmZmLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IERBUkssXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBhZGQgYW4gaWQgdG8gYmUgYWJsZSB0byBzZWxlY3QgaXQuIFVzaW5nIHRoZSBgcGF0aGAgaXMgbm90IHBvc3NpYmxlIGJlY2F1c2VcclxuICAgIC8vIGVtcHR5IHBhdGggY2hpbGRyZW4gd291bGQgY29sbGlkZSB3aXRoIHRoZWlyIHBhcmVudHNcclxuICAgIGxldCBpZCA9IHJlY29yZC5fX3ZkX2lkO1xyXG4gICAgaWYgKGlkID09IG51bGwpIHtcclxuICAgICAgICBpZCA9IFN0cmluZyhyb3V0ZVJlY29yZElkKyspO1xyXG4gICAgICAgIHJlY29yZC5fX3ZkX2lkID0gaWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIGxhYmVsOiByZWNvcmQucGF0aCxcclxuICAgICAgICB0YWdzLFxyXG4gICAgICAgIGNoaWxkcmVuOiByb3V0ZS5jaGlsZHJlbi5tYXAoZm9ybWF0Um91dGVSZWNvcmRGb3JJbnNwZWN0b3IpLFxyXG4gICAgfTtcclxufVxyXG4vLyAgaW5jcmVtZW50YWwgaWQgZm9yIHJvdXRlIHJlY29yZHMgYW5kIGluc3BlY3RvciBzdGF0ZVxyXG5sZXQgcm91dGVSZWNvcmRJZCA9IDA7XHJcbmNvbnN0IEVYVFJBQ1RfUkVHRVhQX1JFID0gL15cXC8oLiopXFwvKFthLXpdKikkLztcclxuZnVuY3Rpb24gbWFya1JvdXRlUmVjb3JkQWN0aXZlKHJvdXRlLCBjdXJyZW50Um91dGUpIHtcclxuICAgIC8vIG5vIHJvdXRlIHdpbGwgYmUgYWN0aXZlIGlmIG1hdGNoZWQgaXMgZW1wdHlcclxuICAgIC8vIHJlc2V0IHRoZSBtYXRjaGluZyBzdGF0ZVxyXG4gICAgY29uc3QgaXNFeGFjdEFjdGl2ZSA9IGN1cnJlbnRSb3V0ZS5tYXRjaGVkLmxlbmd0aCAmJlxyXG4gICAgICAgIGlzU2FtZVJvdXRlUmVjb3JkKGN1cnJlbnRSb3V0ZS5tYXRjaGVkW2N1cnJlbnRSb3V0ZS5tYXRjaGVkLmxlbmd0aCAtIDFdLCByb3V0ZS5yZWNvcmQpO1xyXG4gICAgcm91dGUuX192ZF9leGFjdEFjdGl2ZSA9IHJvdXRlLl9fdmRfYWN0aXZlID0gaXNFeGFjdEFjdGl2ZTtcclxuICAgIGlmICghaXNFeGFjdEFjdGl2ZSkge1xyXG4gICAgICAgIHJvdXRlLl9fdmRfYWN0aXZlID0gY3VycmVudFJvdXRlLm1hdGNoZWQuc29tZShtYXRjaCA9PiBpc1NhbWVSb3V0ZVJlY29yZChtYXRjaCwgcm91dGUucmVjb3JkKSk7XHJcbiAgICB9XHJcbiAgICByb3V0ZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkUm91dGUgPT4gbWFya1JvdXRlUmVjb3JkQWN0aXZlKGNoaWxkUm91dGUsIGN1cnJlbnRSb3V0ZSkpO1xyXG59XHJcbmZ1bmN0aW9uIHJlc2V0TWF0Y2hTdGF0ZU9uUm91dGVSZWNvcmQocm91dGUpIHtcclxuICAgIHJvdXRlLl9fdmRfbWF0Y2ggPSBmYWxzZTtcclxuICAgIHJvdXRlLmNoaWxkcmVuLmZvckVhY2gocmVzZXRNYXRjaFN0YXRlT25Sb3V0ZVJlY29yZCk7XHJcbn1cclxuZnVuY3Rpb24gaXNSb3V0ZU1hdGNoaW5nKHJvdXRlLCBmaWx0ZXIpIHtcclxuICAgIGNvbnN0IGZvdW5kID0gU3RyaW5nKHJvdXRlLnJlKS5tYXRjaChFWFRSQUNUX1JFR0VYUF9SRSk7XHJcbiAgICByb3V0ZS5fX3ZkX21hdGNoID0gZmFsc2U7XHJcbiAgICBpZiAoIWZvdW5kIHx8IGZvdW5kLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyB1c2UgYSByZWdleHAgd2l0aG91dCAkIGF0IHRoZSBlbmQgdG8gbWF0Y2ggbmVzdGVkIHJvdXRlcyBiZXR0ZXJcclxuICAgIGNvbnN0IG5vbkVuZGluZ1JFID0gbmV3IFJlZ0V4cChmb3VuZFsxXS5yZXBsYWNlKC9cXCQkLywgJycpLCBmb3VuZFsyXSk7XHJcbiAgICBpZiAobm9uRW5kaW5nUkUudGVzdChmaWx0ZXIpKSB7XHJcbiAgICAgICAgLy8gbWFyayBjaGlsZHJlbiBhcyBtYXRjaGVzXHJcbiAgICAgICAgcm91dGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBpc1JvdXRlTWF0Y2hpbmcoY2hpbGQsIGZpbHRlcikpO1xyXG4gICAgICAgIC8vIGV4Y2VwdGlvbiBjYXNlOiBgL2BcclxuICAgICAgICBpZiAocm91dGUucmVjb3JkLnBhdGggIT09ICcvJyB8fCBmaWx0ZXIgPT09ICcvJykge1xyXG4gICAgICAgICAgICByb3V0ZS5fX3ZkX21hdGNoID0gcm91dGUucmUudGVzdChmaWx0ZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaGlkZSB0aGUgLyByb3V0ZVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhdGggPSByb3V0ZS5yZWNvcmQucGF0aC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgY29uc3QgZGVjb2RlZFBhdGggPSBkZWNvZGUocGF0aCk7XHJcbiAgICAvLyBhbHNvIGFsbG93IHBhcnRpYWwgbWF0Y2hpbmcgb24gdGhlIHBhdGhcclxuICAgIGlmICghZmlsdGVyLnN0YXJ0c1dpdGgoJy8nKSAmJlxyXG4gICAgICAgIChkZWNvZGVkUGF0aC5pbmNsdWRlcyhmaWx0ZXIpIHx8IHBhdGguaW5jbHVkZXMoZmlsdGVyKSkpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAoZGVjb2RlZFBhdGguc3RhcnRzV2l0aChmaWx0ZXIpIHx8IHBhdGguc3RhcnRzV2l0aChmaWx0ZXIpKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKHJvdXRlLnJlY29yZC5uYW1lICYmIFN0cmluZyhyb3V0ZS5yZWNvcmQubmFtZSkuaW5jbHVkZXMoZmlsdGVyKSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiByb3V0ZS5jaGlsZHJlbi5zb21lKGNoaWxkID0+IGlzUm91dGVNYXRjaGluZyhjaGlsZCwgZmlsdGVyKSk7XHJcbn1cclxuZnVuY3Rpb24gb21pdChvYmosIGtleXMpIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgZm9yIChsZXQga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgUm91dGVyIGluc3RhbmNlIHRoYXQgY2FuIGJlIHVzZWQgYnkgYSBWdWUgYXBwLlxyXG4gKlxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIHtAbGluayBSb3V0ZXJPcHRpb25zfVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUm91dGVyKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IG1hdGNoZXIgPSBjcmVhdGVSb3V0ZXJNYXRjaGVyKG9wdGlvbnMucm91dGVzLCBvcHRpb25zKTtcclxuICAgIGxldCBwYXJzZVF1ZXJ5JDEgPSBvcHRpb25zLnBhcnNlUXVlcnkgfHwgcGFyc2VRdWVyeTtcclxuICAgIGxldCBzdHJpbmdpZnlRdWVyeSQxID0gb3B0aW9ucy5zdHJpbmdpZnlRdWVyeSB8fCBzdHJpbmdpZnlRdWVyeTtcclxuICAgIGxldCByb3V0ZXJIaXN0b3J5ID0gb3B0aW9ucy5oaXN0b3J5O1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhcm91dGVySGlzdG9yeSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGUgdGhlIFwiaGlzdG9yeVwiIG9wdGlvbiB3aGVuIGNhbGxpbmcgXCJjcmVhdGVSb3V0ZXIoKVwiOicgK1xyXG4gICAgICAgICAgICAnIGh0dHBzOi8vbmV4dC5yb3V0ZXIudnVlanMub3JnL2FwaS8jaGlzdG9yeS4nKTtcclxuICAgIGNvbnN0IGJlZm9yZUd1YXJkcyA9IHVzZUNhbGxiYWNrcygpO1xyXG4gICAgY29uc3QgYmVmb3JlUmVzb2x2ZUd1YXJkcyA9IHVzZUNhbGxiYWNrcygpO1xyXG4gICAgY29uc3QgYWZ0ZXJHdWFyZHMgPSB1c2VDYWxsYmFja3MoKTtcclxuICAgIGNvbnN0IGN1cnJlbnRSb3V0ZSA9IHNoYWxsb3dSZWYoU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRCk7XHJcbiAgICBsZXQgcGVuZGluZ0xvY2F0aW9uID0gU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRDtcclxuICAgIC8vIGxlYXZlIHRoZSBzY3JvbGxSZXN0b3JhdGlvbiBpZiBubyBzY3JvbGxCZWhhdmlvciBpcyBwcm92aWRlZFxyXG4gICAgaWYgKGlzQnJvd3NlciAmJiBvcHRpb25zLnNjcm9sbEJlaGF2aW9yICYmICdzY3JvbGxSZXN0b3JhdGlvbicgaW4gaGlzdG9yeSkge1xyXG4gICAgICAgIGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJztcclxuICAgIH1cclxuICAgIGNvbnN0IG5vcm1hbGl6ZVBhcmFtcyA9IGFwcGx5VG9QYXJhbXMuYmluZChudWxsLCBwYXJhbVZhbHVlID0+ICcnICsgcGFyYW1WYWx1ZSk7XHJcbiAgICBjb25zdCBlbmNvZGVQYXJhbXMgPSBhcHBseVRvUGFyYW1zLmJpbmQobnVsbCwgZW5jb2RlUGFyYW0pO1xyXG4gICAgY29uc3QgZGVjb2RlUGFyYW1zID0gYXBwbHlUb1BhcmFtcy5iaW5kKG51bGwsIGRlY29kZSk7XHJcbiAgICBmdW5jdGlvbiBhZGRSb3V0ZShwYXJlbnRPclJvdXRlLCByb3V0ZSkge1xyXG4gICAgICAgIGxldCBwYXJlbnQ7XHJcbiAgICAgICAgbGV0IHJlY29yZDtcclxuICAgICAgICBpZiAoaXNSb3V0ZU5hbWUocGFyZW50T3JSb3V0ZSkpIHtcclxuICAgICAgICAgICAgcGFyZW50ID0gbWF0Y2hlci5nZXRSZWNvcmRNYXRjaGVyKHBhcmVudE9yUm91dGUpO1xyXG4gICAgICAgICAgICByZWNvcmQgPSByb3V0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlY29yZCA9IHBhcmVudE9yUm91dGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRjaGVyLmFkZFJvdXRlKHJlY29yZCwgcGFyZW50KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZVJvdXRlKG5hbWUpIHtcclxuICAgICAgICBsZXQgcmVjb3JkTWF0Y2hlciA9IG1hdGNoZXIuZ2V0UmVjb3JkTWF0Y2hlcihuYW1lKTtcclxuICAgICAgICBpZiAocmVjb3JkTWF0Y2hlcikge1xyXG4gICAgICAgICAgICBtYXRjaGVyLnJlbW92ZVJvdXRlKHJlY29yZE1hdGNoZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgQ2Fubm90IHJlbW92ZSBub24tZXhpc3RlbnQgcm91dGUgXCIke1N0cmluZyhuYW1lKX1cImApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFJvdXRlcygpIHtcclxuICAgICAgICByZXR1cm4gbWF0Y2hlci5nZXRSb3V0ZXMoKS5tYXAocm91dGVNYXRjaGVyID0+IHJvdXRlTWF0Y2hlci5yZWNvcmQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFzUm91dGUobmFtZSkge1xyXG4gICAgICAgIHJldHVybiAhIW1hdGNoZXIuZ2V0UmVjb3JkTWF0Y2hlcihuYW1lKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc29sdmUocmF3TG9jYXRpb24sIGN1cnJlbnRMb2NhdGlvbikge1xyXG4gICAgICAgIC8vIGNvbnN0IG9iamVjdExvY2F0aW9uID0gcm91dGVyTG9jYXRpb25Bc09iamVjdChyYXdMb2NhdGlvbilcclxuICAgICAgICAvLyB3ZSBjcmVhdGUgYSBjb3B5IHRvIG1vZGlmeSBpdCBsYXRlclxyXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbiA9IGFzc2lnbih7fSwgY3VycmVudExvY2F0aW9uIHx8IGN1cnJlbnRSb3V0ZS52YWx1ZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByYXdMb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbGV0IGxvY2F0aW9uTm9ybWFsaXplZCA9IHBhcnNlVVJMKHBhcnNlUXVlcnkkMSwgcmF3TG9jYXRpb24sIGN1cnJlbnRMb2NhdGlvbi5wYXRoKTtcclxuICAgICAgICAgICAgbGV0IG1hdGNoZWRSb3V0ZSA9IG1hdGNoZXIucmVzb2x2ZSh7IHBhdGg6IGxvY2F0aW9uTm9ybWFsaXplZC5wYXRoIH0sIGN1cnJlbnRMb2NhdGlvbik7XHJcbiAgICAgICAgICAgIGxldCBocmVmID0gcm91dGVySGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uTm9ybWFsaXplZC5mdWxsUGF0aCk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChocmVmLnN0YXJ0c1dpdGgoJy8vJykpXHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgTG9jYXRpb24gXCIke3Jhd0xvY2F0aW9ufVwiIHJlc29sdmVkIHRvIFwiJHtocmVmfVwiLiBBIHJlc29sdmVkIGxvY2F0aW9uIGNhbm5vdCBzdGFydCB3aXRoIG11bHRpcGxlIHNsYXNoZXMuYCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbWF0Y2hlZFJvdXRlLm1hdGNoZWQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgTm8gbWF0Y2ggZm91bmQgZm9yIGxvY2F0aW9uIHdpdGggcGF0aCBcIiR7cmF3TG9jYXRpb259XCJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBsb2NhdGlvbk5vcm1hbGl6ZWQgaXMgYWx3YXlzIGEgbmV3IG9iamVjdFxyXG4gICAgICAgICAgICByZXR1cm4gYXNzaWduKGxvY2F0aW9uTm9ybWFsaXplZCwgbWF0Y2hlZFJvdXRlLCB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXM6IGRlY29kZVBhcmFtcyhtYXRjaGVkUm91dGUucGFyYW1zKSxcclxuICAgICAgICAgICAgICAgIGhhc2g6IGRlY29kZShsb2NhdGlvbk5vcm1hbGl6ZWQuaGFzaCksXHJcbiAgICAgICAgICAgICAgICByZWRpcmVjdGVkRnJvbTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgaHJlZixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtYXRjaGVyTG9jYXRpb247XHJcbiAgICAgICAgLy8gcGF0aCBjb3VsZCBiZSByZWxhdGl2ZSBpbiBvYmplY3QgYXMgd2VsbFxyXG4gICAgICAgIGlmICgncGF0aCcgaW4gcmF3TG9jYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgJ3BhcmFtcycgaW4gcmF3TG9jYXRpb24gJiZcclxuICAgICAgICAgICAgICAgICEoJ25hbWUnIGluIHJhd0xvY2F0aW9uKSAmJlxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmF3TG9jYXRpb24ucGFyYW1zKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFBhdGggXCIke3Jhd0xvY2F0aW9uLnBhdGh9XCIgd2FzIHBhc3NlZCB3aXRoIHBhcmFtcyBidXQgdGhleSB3aWxsIGJlIGlnbm9yZWQuIFVzZSBhIG5hbWVkIHJvdXRlIGFsb25nc2lkZSBwYXJhbXMgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXRjaGVyTG9jYXRpb24gPSBhc3NpZ24oe30sIHJhd0xvY2F0aW9uLCB7XHJcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXJzZVVSTChwYXJzZVF1ZXJ5JDEsIHJhd0xvY2F0aW9uLnBhdGgsIGN1cnJlbnRMb2NhdGlvbi5wYXRoKS5wYXRoLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHBhc3MgZW5jb2RlZCB2YWx1ZXMgdG8gdGhlIG1hdGNoZXIgc28gaXQgY2FuIHByb2R1Y2UgZW5jb2RlZCBwYXRoIGFuZCBmdWxsUGF0aFxyXG4gICAgICAgICAgICBtYXRjaGVyTG9jYXRpb24gPSBhc3NpZ24oe30sIHJhd0xvY2F0aW9uLCB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXM6IGVuY29kZVBhcmFtcyhyYXdMb2NhdGlvbi5wYXJhbXMpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gY3VycmVudCBsb2NhdGlvbiBwYXJhbXMgYXJlIGRlY29kZWQsIHdlIG5lZWQgdG8gZW5jb2RlIHRoZW0gaW4gY2FzZSB0aGVcclxuICAgICAgICAgICAgLy8gbWF0Y2hlciBtZXJnZXMgdGhlIHBhcmFtc1xyXG4gICAgICAgICAgICBjdXJyZW50TG9jYXRpb24ucGFyYW1zID0gZW5jb2RlUGFyYW1zKGN1cnJlbnRMb2NhdGlvbi5wYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbWF0Y2hlZFJvdXRlID0gbWF0Y2hlci5yZXNvbHZlKG1hdGNoZXJMb2NhdGlvbiwgY3VycmVudExvY2F0aW9uKTtcclxuICAgICAgICBjb25zdCBoYXNoID0gcmF3TG9jYXRpb24uaGFzaCB8fCAnJztcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhhc2ggJiYgIWhhc2guc3RhcnRzV2l0aCgnIycpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEEgXFxgaGFzaFxcYCBzaG91bGQgYWx3YXlzIHN0YXJ0IHdpdGggdGhlIGNoYXJhY3RlciBcIiNcIi4gUmVwbGFjZSBcIiR7aGFzaH1cIiB3aXRoIFwiIyR7aGFzaH1cIi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGVjb2RpbmcgdGhlbSkgdGhlIG1hdGNoZXIgbWlnaHQgaGF2ZSBtZXJnZWQgY3VycmVudCBsb2NhdGlvbiBwYXJhbXMgc29cclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJ1biB0aGUgZGVjb2RpbmcgYWdhaW5cclxuICAgICAgICBtYXRjaGVkUm91dGUucGFyYW1zID0gbm9ybWFsaXplUGFyYW1zKGRlY29kZVBhcmFtcyhtYXRjaGVkUm91dGUucGFyYW1zKSk7XHJcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBzdHJpbmdpZnlVUkwoc3RyaW5naWZ5UXVlcnkkMSwgYXNzaWduKHt9LCByYXdMb2NhdGlvbiwge1xyXG4gICAgICAgICAgICBoYXNoOiBlbmNvZGVIYXNoKGhhc2gpLFxyXG4gICAgICAgICAgICBwYXRoOiBtYXRjaGVkUm91dGUucGF0aCxcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgbGV0IGhyZWYgPSByb3V0ZXJIaXN0b3J5LmNyZWF0ZUhyZWYoZnVsbFBhdGgpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgaWYgKGhyZWYuc3RhcnRzV2l0aCgnLy8nKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgTG9jYXRpb24gXCIke3Jhd0xvY2F0aW9ufVwiIHJlc29sdmVkIHRvIFwiJHtocmVmfVwiLiBBIHJlc29sdmVkIGxvY2F0aW9uIGNhbm5vdCBzdGFydCB3aXRoIG11bHRpcGxlIHNsYXNoZXMuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIW1hdGNoZWRSb3V0ZS5tYXRjaGVkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgTm8gbWF0Y2ggZm91bmQgZm9yIGxvY2F0aW9uIHdpdGggcGF0aCBcIiR7J3BhdGgnIGluIHJhd0xvY2F0aW9uID8gcmF3TG9jYXRpb24ucGF0aCA6IHJhd0xvY2F0aW9ufVwiYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFzc2lnbih7XHJcbiAgICAgICAgICAgIGZ1bGxQYXRoLFxyXG4gICAgICAgICAgICAvLyBrZWVwIHRoZSBoYXNoIGVuY29kZWQgc28gZnVsbFBhdGggaXMgZWZmZWN0aXZlbHkgcGF0aCArIGVuY29kZWRRdWVyeSArXHJcbiAgICAgICAgICAgIC8vIGhhc2hcclxuICAgICAgICAgICAgaGFzaCxcclxuICAgICAgICAgICAgcXVlcnk6IFxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgdXNlciBpcyB1c2luZyBhIGN1c3RvbSBxdWVyeSBsaWIgbGlrZSBxcywgd2UgbWlnaHQgaGF2ZVxyXG4gICAgICAgICAgICAvLyBuZXN0ZWQgb2JqZWN0cywgc28gd2Uga2VlcCB0aGUgcXVlcnkgYXMgaXMsIG1lYW5pbmcgaXQgY2FuIGNvbnRhaW5cclxuICAgICAgICAgICAgLy8gbnVtYmVycyBhdCBgJHJvdXRlLnF1ZXJ5YCwgYnV0IGF0IHRoZSBwb2ludCwgdGhlIHVzZXIgd2lsbCBoYXZlIHRvXHJcbiAgICAgICAgICAgIC8vIHVzZSB0aGVpciBvd24gdHlwZSBhbnl3YXkuXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtcm91dGVyLW5leHQvaXNzdWVzLzMyOCNpc3N1ZWNvbW1lbnQtNjQ5NDgxNTY3XHJcbiAgICAgICAgICAgIHN0cmluZ2lmeVF1ZXJ5JDEgPT09IHN0cmluZ2lmeVF1ZXJ5XHJcbiAgICAgICAgICAgICAgICA/IG5vcm1hbGl6ZVF1ZXJ5KHJhd0xvY2F0aW9uLnF1ZXJ5KVxyXG4gICAgICAgICAgICAgICAgOiByYXdMb2NhdGlvbi5xdWVyeSxcclxuICAgICAgICB9LCBtYXRjaGVkUm91dGUsIHtcclxuICAgICAgICAgICAgcmVkaXJlY3RlZEZyb206IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgaHJlZixcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGxvY2F0aW9uQXNPYmplY3QodG8pIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHRvID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgICA/IHBhcnNlVVJMKHBhcnNlUXVlcnkkMSwgdG8sIGN1cnJlbnRSb3V0ZS52YWx1ZS5wYXRoKVxyXG4gICAgICAgICAgICA6IGFzc2lnbih7fSwgdG8pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2hlY2tDYW5jZWxlZE5hdmlnYXRpb24odG8sIGZyb20pIHtcclxuICAgICAgICBpZiAocGVuZGluZ0xvY2F0aW9uICE9PSB0bykge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUm91dGVyRXJyb3IoOCAvKiBOQVZJR0FUSU9OX0NBTkNFTExFRCAqLywge1xyXG4gICAgICAgICAgICAgICAgZnJvbSxcclxuICAgICAgICAgICAgICAgIHRvLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwdXNoKHRvKSB7XHJcbiAgICAgICAgcmV0dXJuIHB1c2hXaXRoUmVkaXJlY3QodG8pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZSh0bykge1xyXG4gICAgICAgIHJldHVybiBwdXNoKGFzc2lnbihsb2NhdGlvbkFzT2JqZWN0KHRvKSwgeyByZXBsYWNlOiB0cnVlIH0pKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlZGlyZWN0UmVjb3JkKHRvKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdE1hdGNoZWQgPSB0by5tYXRjaGVkW3RvLm1hdGNoZWQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKGxhc3RNYXRjaGVkICYmIGxhc3RNYXRjaGVkLnJlZGlyZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcmVkaXJlY3QgfSA9IGxhc3RNYXRjaGVkO1xyXG4gICAgICAgICAgICBsZXQgbmV3VGFyZ2V0TG9jYXRpb24gPSB0eXBlb2YgcmVkaXJlY3QgPT09ICdmdW5jdGlvbicgPyByZWRpcmVjdCh0bykgOiByZWRpcmVjdDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdUYXJnZXRMb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIG5ld1RhcmdldExvY2F0aW9uID1cclxuICAgICAgICAgICAgICAgICAgICBuZXdUYXJnZXRMb2NhdGlvbi5pbmNsdWRlcygnPycpIHx8IG5ld1RhcmdldExvY2F0aW9uLmluY2x1ZGVzKCcjJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAobmV3VGFyZ2V0TG9jYXRpb24gPSBsb2NhdGlvbkFzT2JqZWN0KG5ld1RhcmdldExvY2F0aW9uKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAvLyBmb3JjZSBlbXB0eSBwYXJhbXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcGF0aDogbmV3VGFyZ2V0TG9jYXRpb24gfTtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGZvcmNlIGVtcHR5IHBhcmFtcyB3aGVuIGEgc3RyaW5nIGlzIHBhc3NlZCB0byBsZXRcclxuICAgICAgICAgICAgICAgIC8vIHRoZSByb3V0ZXIgcGFyc2UgdGhlbSBhZ2FpblxyXG4gICAgICAgICAgICAgICAgbmV3VGFyZ2V0TG9jYXRpb24ucGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgISgncGF0aCcgaW4gbmV3VGFyZ2V0TG9jYXRpb24pICYmXHJcbiAgICAgICAgICAgICAgICAhKCduYW1lJyBpbiBuZXdUYXJnZXRMb2NhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgcmVkaXJlY3QgZm91bmQ6XFxuJHtKU09OLnN0cmluZ2lmeShuZXdUYXJnZXRMb2NhdGlvbiwgbnVsbCwgMil9XFxuIHdoZW4gbmF2aWdhdGluZyB0byBcIiR7dG8uZnVsbFBhdGh9XCIuIEEgcmVkaXJlY3QgbXVzdCBjb250YWluIGEgbmFtZSBvciBwYXRoLiBUaGlzIHdpbGwgYnJlYWsgaW4gcHJvZHVjdGlvbi5gKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWRpcmVjdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhc3NpZ24oe1xyXG4gICAgICAgICAgICAgICAgcXVlcnk6IHRvLnF1ZXJ5LFxyXG4gICAgICAgICAgICAgICAgaGFzaDogdG8uaGFzaCxcclxuICAgICAgICAgICAgICAgIHBhcmFtczogdG8ucGFyYW1zLFxyXG4gICAgICAgICAgICB9LCBuZXdUYXJnZXRMb2NhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHVzaFdpdGhSZWRpcmVjdCh0bywgcmVkaXJlY3RlZEZyb20pIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRMb2NhdGlvbiA9IChwZW5kaW5nTG9jYXRpb24gPSByZXNvbHZlKHRvKSk7XHJcbiAgICAgICAgY29uc3QgZnJvbSA9IGN1cnJlbnRSb3V0ZS52YWx1ZTtcclxuICAgICAgICBjb25zdCBkYXRhID0gdG8uc3RhdGU7XHJcbiAgICAgICAgY29uc3QgZm9yY2UgPSB0by5mb3JjZTtcclxuICAgICAgICAvLyB0byBjb3VsZCBiZSBhIHN0cmluZyB3aGVyZSBgcmVwbGFjZWAgaXMgYSBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IHJlcGxhY2UgPSB0by5yZXBsYWNlID09PSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IHNob3VsZFJlZGlyZWN0ID0gaGFuZGxlUmVkaXJlY3RSZWNvcmQodGFyZ2V0TG9jYXRpb24pO1xyXG4gICAgICAgIGlmIChzaG91bGRSZWRpcmVjdClcclxuICAgICAgICAgICAgcmV0dXJuIHB1c2hXaXRoUmVkaXJlY3QoYXNzaWduKGxvY2F0aW9uQXNPYmplY3Qoc2hvdWxkUmVkaXJlY3QpLCB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogZGF0YSxcclxuICAgICAgICAgICAgICAgIGZvcmNlLFxyXG4gICAgICAgICAgICAgICAgcmVwbGFjZSxcclxuICAgICAgICAgICAgfSksIFxyXG4gICAgICAgICAgICAvLyBrZWVwIG9yaWdpbmFsIHJlZGlyZWN0ZWRGcm9tIGlmIGl0IGV4aXN0c1xyXG4gICAgICAgICAgICByZWRpcmVjdGVkRnJvbSB8fCB0YXJnZXRMb2NhdGlvbik7XHJcbiAgICAgICAgLy8gaWYgaXQgd2FzIGEgcmVkaXJlY3Qgd2UgYWxyZWFkeSBjYWxsZWQgYHB1c2hXaXRoUmVkaXJlY3RgIGFib3ZlXHJcbiAgICAgICAgY29uc3QgdG9Mb2NhdGlvbiA9IHRhcmdldExvY2F0aW9uO1xyXG4gICAgICAgIHRvTG9jYXRpb24ucmVkaXJlY3RlZEZyb20gPSByZWRpcmVjdGVkRnJvbTtcclxuICAgICAgICBsZXQgZmFpbHVyZTtcclxuICAgICAgICBpZiAoIWZvcmNlICYmIGlzU2FtZVJvdXRlTG9jYXRpb24oc3RyaW5naWZ5UXVlcnkkMSwgZnJvbSwgdGFyZ2V0TG9jYXRpb24pKSB7XHJcbiAgICAgICAgICAgIGZhaWx1cmUgPSBjcmVhdGVSb3V0ZXJFcnJvcigxNiAvKiBOQVZJR0FUSU9OX0RVUExJQ0FURUQgKi8sIHsgdG86IHRvTG9jYXRpb24sIGZyb20gfSk7XHJcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgc2Nyb2xsIHRvIGFsbG93IHNjcm9sbGluZyB0byB0aGUgc2FtZSBhbmNob3JcclxuICAgICAgICAgICAgaGFuZGxlU2Nyb2xsKGZyb20sIGZyb20sIFxyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgcHVzaCwgdGhlIG9ubHkgd2F5IGZvciBpdCB0byBiZSB0cmlnZ2VyZWQgZnJvbSBhXHJcbiAgICAgICAgICAgIC8vIGhpc3RvcnkubGlzdGVuIGlzIHdpdGggYSByZWRpcmVjdCwgd2hpY2ggbWFrZXMgaXQgYmVjb21lIGEgcHVzaFxyXG4gICAgICAgICAgICB0cnVlLCBcclxuICAgICAgICAgICAgLy8gVGhpcyBjYW5ub3QgYmUgdGhlIGZpcnN0IG5hdmlnYXRpb24gYmVjYXVzZSB0aGUgaW5pdGlhbCBsb2NhdGlvblxyXG4gICAgICAgICAgICAvLyBjYW5ub3QgYmUgbWFudWFsbHkgbmF2aWdhdGVkIHRvXHJcbiAgICAgICAgICAgIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChmYWlsdXJlID8gUHJvbWlzZS5yZXNvbHZlKGZhaWx1cmUpIDogbmF2aWdhdGUodG9Mb2NhdGlvbiwgZnJvbSkpXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IGlzTmF2aWdhdGlvbkZhaWx1cmUoZXJyb3IpXHJcbiAgICAgICAgICAgID8gZXJyb3JcclxuICAgICAgICAgICAgOiAvLyByZWplY3QgYW55IHVua25vd24gZXJyb3JcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJFcnJvcihlcnJvciwgdG9Mb2NhdGlvbiwgZnJvbSkpXHJcbiAgICAgICAgICAgIC50aGVuKChmYWlsdXJlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYXZpZ2F0aW9uRmFpbHVyZShmYWlsdXJlLCAyIC8qIE5BVklHQVRJT05fR1VBUkRfUkVESVJFQ1QgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgcmVkaXJlY3RpbmcgdG8gdGhlIHNhbWUgbG9jYXRpb24gd2Ugd2VyZSBhbHJlYWR5IGF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2FtZVJvdXRlTG9jYXRpb24oc3RyaW5naWZ5UXVlcnkkMSwgcmVzb2x2ZShmYWlsdXJlLnRvKSwgdG9Mb2NhdGlvbikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHdlIGhhdmUgZG9uZSBpdCBhIGNvdXBsZSBvZiB0aW1lc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdGVkRnJvbSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhZGRlZCBvbmx5IGluIGRldlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVkaXJlY3RlZEZyb20uX2NvdW50ID0gcmVkaXJlY3RlZEZyb20uX2NvdW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdGVkRnJvbS5fY291bnQgKyAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDEpID4gMTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRGV0ZWN0ZWQgYW4gaW5maW5pdGUgcmVkaXJlY3Rpb24gaW4gYSBuYXZpZ2F0aW9uIGd1YXJkIHdoZW4gZ29pbmcgZnJvbSBcIiR7ZnJvbS5mdWxsUGF0aH1cIiB0byBcIiR7dG9Mb2NhdGlvbi5mdWxsUGF0aH1cIi4gQWJvcnRpbmcgdG8gYXZvaWQgYSBTdGFjayBPdmVyZmxvdy4gVGhpcyB3aWxsIGJyZWFrIGluIHByb2R1Y3Rpb24gaWYgbm90IGZpeGVkLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdJbmZpbml0ZSByZWRpcmVjdCBpbiBuYXZpZ2F0aW9uIGd1YXJkJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHVzaFdpdGhSZWRpcmVjdChcclxuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIG9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBhc3NpZ24obG9jYXRpb25Bc09iamVjdChmYWlsdXJlLnRvKSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSksIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXNlcnZlIHRoZSBvcmlnaW5hbCByZWRpcmVjdGVkRnJvbSBpZiBhbnlcclxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdGVkRnJvbSB8fCB0b0xvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGZhaWwgd2UgZG9uJ3QgZmluYWxpemUgdGhlIG5hdmlnYXRpb25cclxuICAgICAgICAgICAgICAgIGZhaWx1cmUgPSBmaW5hbGl6ZU5hdmlnYXRpb24odG9Mb2NhdGlvbiwgZnJvbSwgdHJ1ZSwgcmVwbGFjZSwgZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJpZ2dlckFmdGVyRWFjaCh0b0xvY2F0aW9uLCBmcm9tLCBmYWlsdXJlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWx1cmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciB0byByZWplY3QgYW5kIHNraXAgYWxsIG5hdmlnYXRpb24gZ3VhcmRzIGlmIGEgbmV3IG5hdmlnYXRpb24gaGFwcGVuZWRcclxuICAgICAqIEBwYXJhbSB0b1xyXG4gICAgICogQHBhcmFtIGZyb21cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY2hlY2tDYW5jZWxlZE5hdmlnYXRpb25BbmRSZWplY3QodG8sIGZyb20pIHtcclxuICAgICAgICBjb25zdCBlcnJvciA9IGNoZWNrQ2FuY2VsZWROYXZpZ2F0aW9uKHRvLCBmcm9tKTtcclxuICAgICAgICByZXR1cm4gZXJyb3IgPyBQcm9taXNlLnJlamVjdChlcnJvcikgOiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE86IHJlZmFjdG9yIHRoZSB3aG9sZSBiZWZvcmUgZ3VhcmRzIGJ5IGludGVybmFsbHkgdXNpbmcgcm91dGVyLmJlZm9yZUVhY2hcclxuICAgIGZ1bmN0aW9uIG5hdmlnYXRlKHRvLCBmcm9tKSB7XHJcbiAgICAgICAgbGV0IGd1YXJkcztcclxuICAgICAgICBjb25zdCBbbGVhdmluZ1JlY29yZHMsIHVwZGF0aW5nUmVjb3JkcywgZW50ZXJpbmdSZWNvcmRzXSA9IGV4dHJhY3RDaGFuZ2luZ1JlY29yZHModG8sIGZyb20pO1xyXG4gICAgICAgIC8vIGFsbCBjb21wb25lbnRzIGhlcmUgaGF2ZSBiZWVuIHJlc29sdmVkIG9uY2UgYmVjYXVzZSB3ZSBhcmUgbGVhdmluZ1xyXG4gICAgICAgIGd1YXJkcyA9IGV4dHJhY3RDb21wb25lbnRzR3VhcmRzKGxlYXZpbmdSZWNvcmRzLnJldmVyc2UoKSwgJ2JlZm9yZVJvdXRlTGVhdmUnLCB0bywgZnJvbSk7XHJcbiAgICAgICAgLy8gbGVhdmluZ1JlY29yZHMgaXMgYWxyZWFkeSByZXZlcnNlZFxyXG4gICAgICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIGxlYXZpbmdSZWNvcmRzKSB7XHJcbiAgICAgICAgICAgIHJlY29yZC5sZWF2ZUd1YXJkcy5mb3JFYWNoKGd1YXJkID0+IHtcclxuICAgICAgICAgICAgICAgIGd1YXJkcy5wdXNoKGd1YXJkVG9Qcm9taXNlRm4oZ3VhcmQsIHRvLCBmcm9tKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjYW5jZWxlZE5hdmlnYXRpb25DaGVjayA9IGNoZWNrQ2FuY2VsZWROYXZpZ2F0aW9uQW5kUmVqZWN0LmJpbmQobnVsbCwgdG8sIGZyb20pO1xyXG4gICAgICAgIGd1YXJkcy5wdXNoKGNhbmNlbGVkTmF2aWdhdGlvbkNoZWNrKTtcclxuICAgICAgICAvLyBydW4gdGhlIHF1ZXVlIG9mIHBlciByb3V0ZSBiZWZvcmVSb3V0ZUxlYXZlIGd1YXJkc1xyXG4gICAgICAgIHJldHVybiAocnVuR3VhcmRRdWV1ZShndWFyZHMpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gY2hlY2sgZ2xvYmFsIGd1YXJkcyBiZWZvcmVFYWNoXHJcbiAgICAgICAgICAgIGd1YXJkcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGd1YXJkIG9mIGJlZm9yZUd1YXJkcy5saXN0KCkpIHtcclxuICAgICAgICAgICAgICAgIGd1YXJkcy5wdXNoKGd1YXJkVG9Qcm9taXNlRm4oZ3VhcmQsIHRvLCBmcm9tKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3VhcmRzLnB1c2goY2FuY2VsZWROYXZpZ2F0aW9uQ2hlY2spO1xyXG4gICAgICAgICAgICByZXR1cm4gcnVuR3VhcmRRdWV1ZShndWFyZHMpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gY2hlY2sgaW4gY29tcG9uZW50cyBiZWZvcmVSb3V0ZVVwZGF0ZVxyXG4gICAgICAgICAgICBndWFyZHMgPSBleHRyYWN0Q29tcG9uZW50c0d1YXJkcyh1cGRhdGluZ1JlY29yZHMsICdiZWZvcmVSb3V0ZVVwZGF0ZScsIHRvLCBmcm9tKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCByZWNvcmQgb2YgdXBkYXRpbmdSZWNvcmRzKSB7XHJcbiAgICAgICAgICAgICAgICByZWNvcmQudXBkYXRlR3VhcmRzLmZvckVhY2goZ3VhcmQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGd1YXJkcy5wdXNoKGd1YXJkVG9Qcm9taXNlRm4oZ3VhcmQsIHRvLCBmcm9tKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBndWFyZHMucHVzaChjYW5jZWxlZE5hdmlnYXRpb25DaGVjayk7XHJcbiAgICAgICAgICAgIC8vIHJ1biB0aGUgcXVldWUgb2YgcGVyIHJvdXRlIGJlZm9yZUVudGVyIGd1YXJkc1xyXG4gICAgICAgICAgICByZXR1cm4gcnVuR3VhcmRRdWV1ZShndWFyZHMpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gY2hlY2sgdGhlIHJvdXRlIGJlZm9yZUVudGVyXHJcbiAgICAgICAgICAgIGd1YXJkcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiB0by5tYXRjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgdHJpZ2dlciBiZWZvcmVFbnRlciBvbiByZXVzZWQgdmlld3NcclxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYmVmb3JlRW50ZXIgJiYgIWZyb20ubWF0Y2hlZC5pbmNsdWRlcyhyZWNvcmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVjb3JkLmJlZm9yZUVudGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJlZm9yZUVudGVyIG9mIHJlY29yZC5iZWZvcmVFbnRlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkcy5wdXNoKGd1YXJkVG9Qcm9taXNlRm4oYmVmb3JlRW50ZXIsIHRvLCBmcm9tKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBndWFyZHMucHVzaChndWFyZFRvUHJvbWlzZUZuKHJlY29yZC5iZWZvcmVFbnRlciwgdG8sIGZyb20pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3VhcmRzLnB1c2goY2FuY2VsZWROYXZpZ2F0aW9uQ2hlY2spO1xyXG4gICAgICAgICAgICAvLyBydW4gdGhlIHF1ZXVlIG9mIHBlciByb3V0ZSBiZWZvcmVFbnRlciBndWFyZHNcclxuICAgICAgICAgICAgcmV0dXJuIHJ1bkd1YXJkUXVldWUoZ3VhcmRzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IGF0IHRoaXMgcG9pbnQgdG8ubWF0Y2hlZCBpcyBub3JtYWxpemVkIGFuZCBkb2VzIG5vdCBjb250YWluIGFueSAoKSA9PiBQcm9taXNlPENvbXBvbmVudD5cclxuICAgICAgICAgICAgLy8gY2xlYXIgZXhpc3RpbmcgZW50ZXJDYWxsYmFja3MsIHRoZXNlIGFyZSBhZGRlZCBieSBleHRyYWN0Q29tcG9uZW50c0d1YXJkc1xyXG4gICAgICAgICAgICB0by5tYXRjaGVkLmZvckVhY2gocmVjb3JkID0+IChyZWNvcmQuZW50ZXJDYWxsYmFja3MgPSB7fSkpO1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpbi1jb21wb25lbnQgYmVmb3JlUm91dGVFbnRlclxyXG4gICAgICAgICAgICBndWFyZHMgPSBleHRyYWN0Q29tcG9uZW50c0d1YXJkcyhlbnRlcmluZ1JlY29yZHMsICdiZWZvcmVSb3V0ZUVudGVyJywgdG8sIGZyb20pO1xyXG4gICAgICAgICAgICBndWFyZHMucHVzaChjYW5jZWxlZE5hdmlnYXRpb25DaGVjayk7XHJcbiAgICAgICAgICAgIC8vIHJ1biB0aGUgcXVldWUgb2YgcGVyIHJvdXRlIGJlZm9yZUVudGVyIGd1YXJkc1xyXG4gICAgICAgICAgICByZXR1cm4gcnVuR3VhcmRRdWV1ZShndWFyZHMpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gY2hlY2sgZ2xvYmFsIGd1YXJkcyBiZWZvcmVSZXNvbHZlXHJcbiAgICAgICAgICAgIGd1YXJkcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGd1YXJkIG9mIGJlZm9yZVJlc29sdmVHdWFyZHMubGlzdCgpKSB7XHJcbiAgICAgICAgICAgICAgICBndWFyZHMucHVzaChndWFyZFRvUHJvbWlzZUZuKGd1YXJkLCB0bywgZnJvbSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGd1YXJkcy5wdXNoKGNhbmNlbGVkTmF2aWdhdGlvbkNoZWNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJ1bkd1YXJkUXVldWUoZ3VhcmRzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAvLyBjYXRjaCBhbnkgbmF2aWdhdGlvbiBjYW5jZWxlZFxyXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IGlzTmF2aWdhdGlvbkZhaWx1cmUoZXJyLCA4IC8qIE5BVklHQVRJT05fQ0FOQ0VMTEVEICovKVxyXG4gICAgICAgICAgICA/IGVyclxyXG4gICAgICAgICAgICA6IFByb21pc2UucmVqZWN0KGVycikpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyaWdnZXJBZnRlckVhY2godG8sIGZyb20sIGZhaWx1cmUpIHtcclxuICAgICAgICAvLyBuYXZpZ2F0aW9uIGlzIGNvbmZpcm1lZCwgY2FsbCBhZnRlckd1YXJkc1xyXG4gICAgICAgIC8vIFRPRE86IHdyYXAgd2l0aCBlcnJvciBoYW5kbGVyc1xyXG4gICAgICAgIGZvciAoY29uc3QgZ3VhcmQgb2YgYWZ0ZXJHdWFyZHMubGlzdCgpKVxyXG4gICAgICAgICAgICBndWFyZCh0bywgZnJvbSwgZmFpbHVyZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIC0gQ2xlYW5zIHVwIGFueSBuYXZpZ2F0aW9uIGd1YXJkc1xyXG4gICAgICogLSBDaGFuZ2VzIHRoZSB1cmwgaWYgbmVjZXNzYXJ5XHJcbiAgICAgKiAtIENhbGxzIHRoZSBzY3JvbGxCZWhhdmlvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmaW5hbGl6ZU5hdmlnYXRpb24odG9Mb2NhdGlvbiwgZnJvbSwgaXNQdXNoLCByZXBsYWNlLCBkYXRhKSB7XHJcbiAgICAgICAgLy8gYSBtb3JlIHJlY2VudCBuYXZpZ2F0aW9uIHRvb2sgcGxhY2VcclxuICAgICAgICBjb25zdCBlcnJvciA9IGNoZWNrQ2FuY2VsZWROYXZpZ2F0aW9uKHRvTG9jYXRpb24sIGZyb20pO1xyXG4gICAgICAgIGlmIChlcnJvcilcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgIC8vIG9ubHkgY29uc2lkZXIgYXMgcHVzaCBpZiBpdCdzIG5vdCB0aGUgZmlyc3QgbmF2aWdhdGlvblxyXG4gICAgICAgIGNvbnN0IGlzRmlyc3ROYXZpZ2F0aW9uID0gZnJvbSA9PT0gU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRDtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9ICFpc0Jyb3dzZXIgPyB7fSA6IGhpc3Rvcnkuc3RhdGU7XHJcbiAgICAgICAgLy8gY2hhbmdlIFVSTCBvbmx5IGlmIHRoZSB1c2VyIGRpZCBhIHB1c2gvcmVwbGFjZSBhbmQgaWYgaXQncyBub3QgdGhlIGluaXRpYWwgbmF2aWdhdGlvbiBiZWNhdXNlXHJcbiAgICAgICAgLy8gaXQncyBqdXN0IHJlZmxlY3RpbmcgdGhlIHVybFxyXG4gICAgICAgIGlmIChpc1B1c2gpIHtcclxuICAgICAgICAgICAgLy8gb24gdGhlIGluaXRpYWwgbmF2aWdhdGlvbiwgd2Ugd2FudCB0byByZXVzZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIGZyb21cclxuICAgICAgICAgICAgLy8gaGlzdG9yeSBzdGF0ZSBpZiBpdCBleGlzdHNcclxuICAgICAgICAgICAgaWYgKHJlcGxhY2UgfHwgaXNGaXJzdE5hdmlnYXRpb24pXHJcbiAgICAgICAgICAgICAgICByb3V0ZXJIaXN0b3J5LnJlcGxhY2UodG9Mb2NhdGlvbi5mdWxsUGF0aCwgYXNzaWduKHtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGw6IGlzRmlyc3ROYXZpZ2F0aW9uICYmIHN0YXRlICYmIHN0YXRlLnNjcm9sbCxcclxuICAgICAgICAgICAgICAgIH0sIGRhdGEpKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcm91dGVySGlzdG9yeS5wdXNoKHRvTG9jYXRpb24uZnVsbFBhdGgsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhY2NlcHQgY3VycmVudCBuYXZpZ2F0aW9uXHJcbiAgICAgICAgY3VycmVudFJvdXRlLnZhbHVlID0gdG9Mb2NhdGlvbjtcclxuICAgICAgICBoYW5kbGVTY3JvbGwodG9Mb2NhdGlvbiwgZnJvbSwgaXNQdXNoLCBpc0ZpcnN0TmF2aWdhdGlvbik7XHJcbiAgICAgICAgbWFya0FzUmVhZHkoKTtcclxuICAgIH1cclxuICAgIGxldCByZW1vdmVIaXN0b3J5TGlzdGVuZXI7XHJcbiAgICAvLyBhdHRhY2ggbGlzdGVuZXIgdG8gaGlzdG9yeSB0byB0cmlnZ2VyIG5hdmlnYXRpb25zXHJcbiAgICBmdW5jdGlvbiBzZXR1cExpc3RlbmVycygpIHtcclxuICAgICAgICByZW1vdmVIaXN0b3J5TGlzdGVuZXIgPSByb3V0ZXJIaXN0b3J5Lmxpc3RlbigodG8sIF9mcm9tLCBpbmZvKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNhbm5vdCBiZSBhIHJlZGlyZWN0IHJvdXRlIGJlY2F1c2UgaXQgd2FzIGluIGhpc3RvcnlcclxuICAgICAgICAgICAgbGV0IHRvTG9jYXRpb24gPSByZXNvbHZlKHRvKTtcclxuICAgICAgICAgICAgLy8gZHVlIHRvIGR5bmFtaWMgcm91dGluZywgYW5kIHRvIGhhc2ggaGlzdG9yeSB3aXRoIG1hbnVhbCBuYXZpZ2F0aW9uXHJcbiAgICAgICAgICAgIC8vIChtYW51YWxseSBjaGFuZ2luZyB0aGUgdXJsIG9yIGNhbGxpbmcgaGlzdG9yeS5oYXNoID0gJyMvc29tZXdoZXJlJyksXHJcbiAgICAgICAgICAgIC8vIHRoZXJlIGNvdWxkIGJlIGEgcmVkaXJlY3QgcmVjb3JkIGluIGhpc3RvcnlcclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVkaXJlY3QgPSBoYW5kbGVSZWRpcmVjdFJlY29yZCh0b0xvY2F0aW9uKTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZFJlZGlyZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoV2l0aFJlZGlyZWN0KGFzc2lnbihzaG91bGRSZWRpcmVjdCwgeyByZXBsYWNlOiB0cnVlIH0pLCB0b0xvY2F0aW9uKS5jYXRjaChub29wKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwZW5kaW5nTG9jYXRpb24gPSB0b0xvY2F0aW9uO1xyXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gY3VycmVudFJvdXRlLnZhbHVlO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgYmUgbW92ZWQgdG8gd2ViIGhpc3Rvcnk/XHJcbiAgICAgICAgICAgIGlmIChpc0Jyb3dzZXIpIHtcclxuICAgICAgICAgICAgICAgIHNhdmVTY3JvbGxQb3NpdGlvbihnZXRTY3JvbGxLZXkoZnJvbS5mdWxsUGF0aCwgaW5mby5kZWx0YSksIGNvbXB1dGVTY3JvbGxQb3NpdGlvbigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuYXZpZ2F0ZSh0b0xvY2F0aW9uLCBmcm9tKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmF2aWdhdGlvbkZhaWx1cmUoZXJyb3IsIDQgLyogTkFWSUdBVElPTl9BQk9SVEVEICovIHwgOCAvKiBOQVZJR0FUSU9OX0NBTkNFTExFRCAqLykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYXZpZ2F0aW9uRmFpbHVyZShlcnJvciwgMiAvKiBOQVZJR0FUSU9OX0dVQVJEX1JFRElSRUNUICovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhlcmUgd2UgY291bGQgY2FsbCBpZiAoaW5mby5kZWx0YSkgcm91dGVySGlzdG9yeS5nbygtaW5mby5kZWx0YSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBmYWxzZSkgYnV0IHRoaXMgaXMgYnVnIHByb25lIGFzIHdlIGhhdmUgbm8gd2F5IHRvIHdhaXQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmF2aWdhdGlvbiB0byBiZSBmaW5pc2hlZCBiZWZvcmUgY2FsbGluZyBwdXNoV2l0aFJlZGlyZWN0LiBVc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgc2V0VGltZW91dCBvZiAxNm1zIHNlZW1zIHRvIHdvcmsgYnV0IHRoZXJlIGlzIG5vdCBndWFyYW50ZWUgZm9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgdG8gd29yayBvbiBldmVyeSBicm93c2VyLiBTbyBJbnN0ZWFkIHdlIGRvIG5vdCByZXN0b3JlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhpc3RvcnkgZW50cnkgYW5kIHRyaWdnZXIgYSBuZXcgbmF2aWdhdGlvbiBhcyByZXF1ZXN0ZWQgYnkgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmF2aWdhdGlvbiBndWFyZC5cclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZXJyb3IgaXMgYWxyZWFkeSBoYW5kbGVkIGJ5IHJvdXRlci5wdXNoIHdlIGp1c3Qgd2FudCB0byBhdm9pZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvZ2dpbmcgdGhlIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdpdGhSZWRpcmVjdChlcnJvci50bywgdG9Mb2NhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGF2b2lkIGFuIHVuY2F1Z2h0IHJlamVjdGlvbiwgbGV0IHB1c2ggY2FsbCB0cmlnZ2VyRXJyb3JcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZhaWx1cmUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYW51YWwgY2hhbmdlIGluIGhhc2ggaGlzdG9yeSAjOTE2IGVuZGluZyB1cCBpbiB0aGUgVVJMIG5vdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2luZyBidXQgaXQgd2FzIGNoYW5nZWQgYnkgdGhlIG1hbnVhbCB1cmwgY2hhbmdlLCBzbyB3ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIG1hbnVhbGx5IGNoYW5nZSBpdCBvdXJzZWx2ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmF2aWdhdGlvbkZhaWx1cmUoZmFpbHVyZSwgNCAvKiBOQVZJR0FUSU9OX0FCT1JURUQgKi8gfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTYgLyogTkFWSUdBVElPTl9EVVBMSUNBVEVEICovKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWluZm8uZGVsdGEgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8udHlwZSA9PT0gTmF2aWdhdGlvblR5cGUucG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXJIaXN0b3J5LmdvKC0xLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2gobm9vcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXZvaWQgdGhlIHRoZW4gYnJhbmNoXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgcmVzdG9yZSBoaXN0b3J5IG9uIHVua25vd24gZGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5kZWx0YSlcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZXJIaXN0b3J5LmdvKC1pbmZvLmRlbHRhLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAvLyB1bnJlY29nbml6ZWQgZXJyb3IsIHRyYW5zZmVyIHRvIHRoZSBnbG9iYWwgaGFuZGxlclxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXJFcnJvcihlcnJvciwgdG9Mb2NhdGlvbiwgZnJvbSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbigoZmFpbHVyZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZmFpbHVyZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZU5hdmlnYXRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIG5hdmlnYXRpb24sIGFsbCBtYXRjaGVkIGNvbXBvbmVudHMgYXJlIHJlc29sdmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvTG9jYXRpb24sIGZyb20sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIC8vIHJldmVydCB0aGUgbmF2aWdhdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5kZWx0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXJIaXN0b3J5LmdvKC1pbmZvLmRlbHRhLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZm8udHlwZSA9PT0gTmF2aWdhdGlvblR5cGUucG9wICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTmF2aWdhdGlvbkZhaWx1cmUoZmFpbHVyZSwgNCAvKiBOQVZJR0FUSU9OX0FCT1JURUQgKi8gfCAxNiAvKiBOQVZJR0FUSU9OX0RVUExJQ0FURUQgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hbnVhbCBjaGFuZ2UgaW4gaGFzaCBoaXN0b3J5ICM5MTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBsaWtlIGEgcHVzaCBidXQgbGFja3MgdGhlIGluZm9ybWF0aW9uIG9mIHRoZSBkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVySGlzdG9yeS5nbygtMSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyaWdnZXJBZnRlckVhY2godG9Mb2NhdGlvbiwgZnJvbSwgZmFpbHVyZSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2gobm9vcCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBJbml0aWFsaXphdGlvbiBhbmQgRXJyb3JzXHJcbiAgICBsZXQgcmVhZHlIYW5kbGVycyA9IHVzZUNhbGxiYWNrcygpO1xyXG4gICAgbGV0IGVycm9ySGFuZGxlcnMgPSB1c2VDYWxsYmFja3MoKTtcclxuICAgIGxldCByZWFkeTtcclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlciBlcnJvckhhbmRsZXJzIGFkZGVkIHZpYSBvbkVycm9yIGFuZCB0aHJvd3MgdGhlIGVycm9yIGFzIHdlbGxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBlcnJvciB0byB0aHJvd1xyXG4gICAgICogQHBhcmFtIHRvIC0gbG9jYXRpb24gd2Ugd2VyZSBuYXZpZ2F0aW5nIHRvIHdoZW4gdGhlIGVycm9yIGhhcHBlbmVkXHJcbiAgICAgKiBAcGFyYW0gZnJvbSAtIGxvY2F0aW9uIHdlIHdlcmUgbmF2aWdhdGluZyBmcm9tIHdoZW4gdGhlIGVycm9yIGhhcHBlbmVkXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgZXJyb3IgYXMgYSByZWplY3RlZCBwcm9taXNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRyaWdnZXJFcnJvcihlcnJvciwgdG8sIGZyb20pIHtcclxuICAgICAgICBtYXJrQXNSZWFkeShlcnJvcik7XHJcbiAgICAgICAgY29uc3QgbGlzdCA9IGVycm9ySGFuZGxlcnMubGlzdCgpO1xyXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsaXN0LmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyKGVycm9yLCB0bywgZnJvbSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybigndW5jYXVnaHQgZXJyb3IgZHVyaW5nIHJvdXRlIG5hdmlnYXRpb246Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1JlYWR5KCkge1xyXG4gICAgICAgIGlmIChyZWFkeSAmJiBjdXJyZW50Um91dGUudmFsdWUgIT09IFNUQVJUX0xPQ0FUSU9OX05PUk1BTElaRUQpXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICByZWFkeUhhbmRsZXJzLmFkZChbcmVzb2x2ZSwgcmVqZWN0XSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1hcmsgdGhlIHJvdXRlciBhcyByZWFkeSwgcmVzb2x2aW5nIHRoZSBwcm9taXNlZCByZXR1cm5lZCBieSBpc1JlYWR5KCkuIENhblxyXG4gICAgICogb25seSBiZSBjYWxsZWQgb25jZSwgb3RoZXJ3aXNlIGRvZXMgbm90aGluZy5cclxuICAgICAqIEBwYXJhbSBlcnIgLSBvcHRpb25hbCBlcnJvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtYXJrQXNSZWFkeShlcnIpIHtcclxuICAgICAgICBpZiAocmVhZHkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICByZWFkeSA9IHRydWU7XHJcbiAgICAgICAgc2V0dXBMaXN0ZW5lcnMoKTtcclxuICAgICAgICByZWFkeUhhbmRsZXJzXHJcbiAgICAgICAgICAgIC5saXN0KClcclxuICAgICAgICAgICAgLmZvckVhY2goKFtyZXNvbHZlLCByZWplY3RdKSA9PiAoZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCkpKTtcclxuICAgICAgICByZWFkeUhhbmRsZXJzLnJlc2V0KCk7XHJcbiAgICB9XHJcbiAgICAvLyBTY3JvbGwgYmVoYXZpb3JcclxuICAgIGZ1bmN0aW9uIGhhbmRsZVNjcm9sbCh0bywgZnJvbSwgaXNQdXNoLCBpc0ZpcnN0TmF2aWdhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsQmVoYXZpb3IgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgIXNjcm9sbEJlaGF2aW9yKVxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgbGV0IHNjcm9sbFBvc2l0aW9uID0gKCFpc1B1c2ggJiYgZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihnZXRTY3JvbGxLZXkodG8uZnVsbFBhdGgsIDApKSkgfHxcclxuICAgICAgICAgICAgKChpc0ZpcnN0TmF2aWdhdGlvbiB8fCAhaXNQdXNoKSAmJlxyXG4gICAgICAgICAgICAgICAgaGlzdG9yeS5zdGF0ZSAmJlxyXG4gICAgICAgICAgICAgICAgaGlzdG9yeS5zdGF0ZS5zY3JvbGwpIHx8XHJcbiAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG5leHRUaWNrKClcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gc2Nyb2xsQmVoYXZpb3IodG8sIGZyb20sIHNjcm9sbFBvc2l0aW9uKSlcclxuICAgICAgICAgICAgLnRoZW4ocG9zaXRpb24gPT4gcG9zaXRpb24gJiYgc2Nyb2xsVG9Qb3NpdGlvbihwb3NpdGlvbikpXHJcbiAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gdHJpZ2dlckVycm9yKGVyciwgdG8sIGZyb20pKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGdvID0gKGRlbHRhKSA9PiByb3V0ZXJIaXN0b3J5LmdvKGRlbHRhKTtcclxuICAgIGxldCBzdGFydGVkO1xyXG4gICAgY29uc3QgaW5zdGFsbGVkQXBwcyA9IG5ldyBTZXQoKTtcclxuICAgIGNvbnN0IHJvdXRlciA9IHtcclxuICAgICAgICBjdXJyZW50Um91dGUsXHJcbiAgICAgICAgYWRkUm91dGUsXHJcbiAgICAgICAgcmVtb3ZlUm91dGUsXHJcbiAgICAgICAgaGFzUm91dGUsXHJcbiAgICAgICAgZ2V0Um91dGVzLFxyXG4gICAgICAgIHJlc29sdmUsXHJcbiAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICBwdXNoLFxyXG4gICAgICAgIHJlcGxhY2UsXHJcbiAgICAgICAgZ28sXHJcbiAgICAgICAgYmFjazogKCkgPT4gZ28oLTEpLFxyXG4gICAgICAgIGZvcndhcmQ6ICgpID0+IGdvKDEpLFxyXG4gICAgICAgIGJlZm9yZUVhY2g6IGJlZm9yZUd1YXJkcy5hZGQsXHJcbiAgICAgICAgYmVmb3JlUmVzb2x2ZTogYmVmb3JlUmVzb2x2ZUd1YXJkcy5hZGQsXHJcbiAgICAgICAgYWZ0ZXJFYWNoOiBhZnRlckd1YXJkcy5hZGQsXHJcbiAgICAgICAgb25FcnJvcjogZXJyb3JIYW5kbGVycy5hZGQsXHJcbiAgICAgICAgaXNSZWFkeSxcclxuICAgICAgICBpbnN0YWxsKGFwcCkge1xyXG4gICAgICAgICAgICBjb25zdCByb3V0ZXIgPSB0aGlzO1xyXG4gICAgICAgICAgICBhcHAuY29tcG9uZW50KCdSb3V0ZXJMaW5rJywgUm91dGVyTGluayk7XHJcbiAgICAgICAgICAgIGFwcC5jb21wb25lbnQoJ1JvdXRlclZpZXcnLCBSb3V0ZXJWaWV3KTtcclxuICAgICAgICAgICAgYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLiRyb3V0ZXIgPSByb3V0ZXI7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsICckcm91dGUnLCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB1bnJlZihjdXJyZW50Um91dGUpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gdGhpcyBpbml0aWFsIG5hdmlnYXRpb24gaXMgb25seSBuZWNlc3Nhcnkgb24gY2xpZW50LCBvbiBzZXJ2ZXIgaXQgZG9lc24ndFxyXG4gICAgICAgICAgICAvLyBtYWtlIHNlbnNlIGJlY2F1c2UgaXQgd2lsbCBjcmVhdGUgYW4gZXh0cmEgdW5uZWNlc3NhcnkgbmF2aWdhdGlvbiBhbmQgY291bGRcclxuICAgICAgICAgICAgLy8gbGVhZCB0byBwcm9ibGVtc1xyXG4gICAgICAgICAgICBpZiAoaXNCcm93c2VyICYmXHJcbiAgICAgICAgICAgICAgICAvLyB1c2VkIGZvciB0aGUgaW5pdGlhbCBuYXZpZ2F0aW9uIGNsaWVudCBzaWRlIHRvIGF2b2lkIHB1c2hpbmdcclxuICAgICAgICAgICAgICAgIC8vIG11bHRpcGxlIHRpbWVzIHdoZW4gdGhlIHJvdXRlciBpcyB1c2VkIGluIG11bHRpcGxlIGFwcHNcclxuICAgICAgICAgICAgICAgICFzdGFydGVkICYmXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Um91dGUudmFsdWUgPT09IFNUQVJUX0xPQ0FUSU9OX05PUk1BTElaRUQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNlZSBhYm92ZVxyXG4gICAgICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBwdXNoKHJvdXRlckhpc3RvcnkubG9jYXRpb24pLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignVW5leHBlY3RlZCBlcnJvciB3aGVuIHN0YXJ0aW5nIHRoZSByb3V0ZXI6JywgZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWN0aXZlUm91dGUgPSB7fTtcclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIFNUQVJUX0xPQ0FUSU9OX05PUk1BTElaRUQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRoZSBrZXkgbWF0Y2hlc1xyXG4gICAgICAgICAgICAgICAgcmVhY3RpdmVSb3V0ZVtrZXldID0gY29tcHV0ZWQoKCkgPT4gY3VycmVudFJvdXRlLnZhbHVlW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFwcC5wcm92aWRlKHJvdXRlcktleSwgcm91dGVyKTtcclxuICAgICAgICAgICAgYXBwLnByb3ZpZGUocm91dGVMb2NhdGlvbktleSwgcmVhY3RpdmUocmVhY3RpdmVSb3V0ZSkpO1xyXG4gICAgICAgICAgICBhcHAucHJvdmlkZShyb3V0ZXJWaWV3TG9jYXRpb25LZXksIGN1cnJlbnRSb3V0ZSk7XHJcbiAgICAgICAgICAgIGxldCB1bm1vdW50QXBwID0gYXBwLnVubW91bnQ7XHJcbiAgICAgICAgICAgIGluc3RhbGxlZEFwcHMuYWRkKGFwcCk7XHJcbiAgICAgICAgICAgIGFwcC51bm1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFsbGVkQXBwcy5kZWxldGUoYXBwKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YWxsZWRBcHBzLnNpemUgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSGlzdG9yeUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvdXRlLnZhbHVlID0gU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRDtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVubW91bnRBcHAoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiBpc0Jyb3dzZXIpIHtcclxuICAgICAgICAgICAgICAgIGFkZERldnRvb2xzKGFwcCwgcm91dGVyLCBtYXRjaGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHJvdXRlcjtcclxufVxyXG5mdW5jdGlvbiBydW5HdWFyZFF1ZXVlKGd1YXJkcykge1xyXG4gICAgcmV0dXJuIGd1YXJkcy5yZWR1Y2UoKHByb21pc2UsIGd1YXJkKSA9PiBwcm9taXNlLnRoZW4oKCkgPT4gZ3VhcmQoKSksIFByb21pc2UucmVzb2x2ZSgpKTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0Q2hhbmdpbmdSZWNvcmRzKHRvLCBmcm9tKSB7XHJcbiAgICBjb25zdCBsZWF2aW5nUmVjb3JkcyA9IFtdO1xyXG4gICAgY29uc3QgdXBkYXRpbmdSZWNvcmRzID0gW107XHJcbiAgICBjb25zdCBlbnRlcmluZ1JlY29yZHMgPSBbXTtcclxuICAgIGNvbnN0IGxlbiA9IE1hdGgubWF4KGZyb20ubWF0Y2hlZC5sZW5ndGgsIHRvLm1hdGNoZWQubGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBjb25zdCByZWNvcmRGcm9tID0gZnJvbS5tYXRjaGVkW2ldO1xyXG4gICAgICAgIGlmIChyZWNvcmRGcm9tKSB7XHJcbiAgICAgICAgICAgIGlmICh0by5tYXRjaGVkLmZpbmQocmVjb3JkID0+IGlzU2FtZVJvdXRlUmVjb3JkKHJlY29yZCwgcmVjb3JkRnJvbSkpKVxyXG4gICAgICAgICAgICAgICAgdXBkYXRpbmdSZWNvcmRzLnB1c2gocmVjb3JkRnJvbSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGxlYXZpbmdSZWNvcmRzLnB1c2gocmVjb3JkRnJvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlY29yZFRvID0gdG8ubWF0Y2hlZFtpXTtcclxuICAgICAgICBpZiAocmVjb3JkVG8pIHtcclxuICAgICAgICAgICAgLy8gdGhlIHR5cGUgZG9lc24ndCBtYXR0ZXIgYmVjYXVzZSB3ZSBhcmUgY29tcGFyaW5nIHBlciByZWZlcmVuY2VcclxuICAgICAgICAgICAgaWYgKCFmcm9tLm1hdGNoZWQuZmluZChyZWNvcmQgPT4gaXNTYW1lUm91dGVSZWNvcmQocmVjb3JkLCByZWNvcmRUbykpKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRlcmluZ1JlY29yZHMucHVzaChyZWNvcmRUbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2xlYXZpbmdSZWNvcmRzLCB1cGRhdGluZ1JlY29yZHMsIGVudGVyaW5nUmVjb3Jkc107XHJcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHJvdXRlciBpbnN0YW5jZS4gRXF1aXZhbGVudCB0byB1c2luZyBgJHJvdXRlcmAgaW5zaWRlXHJcbiAqIHRlbXBsYXRlcy5cclxuICovXHJcbmZ1bmN0aW9uIHVzZVJvdXRlcigpIHtcclxuICAgIHJldHVybiBpbmplY3Qocm91dGVyS2V5KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY3VycmVudCByb3V0ZSBsb2NhdGlvbi4gRXF1aXZhbGVudCB0byB1c2luZyBgJHJvdXRlYCBpbnNpZGVcclxuICogdGVtcGxhdGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gdXNlUm91dGUoKSB7XHJcbiAgICByZXR1cm4gaW5qZWN0KHJvdXRlTG9jYXRpb25LZXkpO1xyXG59XG5cbmV4cG9ydCB7IE5hdmlnYXRpb25GYWlsdXJlVHlwZSwgUm91dGVyTGluaywgUm91dGVyVmlldywgU1RBUlRfTE9DQVRJT05fTk9STUFMSVpFRCBhcyBTVEFSVF9MT0NBVElPTiwgY3JlYXRlTWVtb3J5SGlzdG9yeSwgY3JlYXRlUm91dGVyLCBjcmVhdGVSb3V0ZXJNYXRjaGVyLCBjcmVhdGVXZWJIYXNoSGlzdG9yeSwgY3JlYXRlV2ViSGlzdG9yeSwgaXNOYXZpZ2F0aW9uRmFpbHVyZSwgbWF0Y2hlZFJvdXRlS2V5LCBvbkJlZm9yZVJvdXRlTGVhdmUsIG9uQmVmb3JlUm91dGVVcGRhdGUsIHBhcnNlUXVlcnksIHJvdXRlTG9jYXRpb25LZXksIHJvdXRlcktleSwgcm91dGVyVmlld0xvY2F0aW9uS2V5LCBzdHJpbmdpZnlRdWVyeSwgdXNlTGluaywgdXNlUm91dGUsIHVzZVJvdXRlciwgdmlld0RlcHRoS2V5IH07XG4iLCJpbXBvcnQgeyBpbml0Q3VzdG9tRm9ybWF0dGVyLCB3YXJuIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcblxuZnVuY3Rpb24gaW5pdERldigpIHtcclxuICAgIHtcclxuICAgICAgICBpbml0Q3VzdG9tRm9ybWF0dGVyKCk7XHJcbiAgICB9XHJcbn1cblxuLy8gVGhpcyBlbnRyeSBleHBvcnRzIHRoZSBydW50aW1lIG9ubHksIGFuZCBpcyBidWlsdCBhc1xyXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICBpbml0RGV2KCk7XHJcbn1cclxuY29uc3QgY29tcGlsZSA9ICgpID0+IHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGBSdW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArXHJcbiAgICAgICAgICAgIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcInZ1ZS9kaXN0L3Z1ZS5lc20tYnVuZGxlci5qc1wiLmBcclxuICAgICAgICAgICAgICAgICkgLyogc2hvdWxkIG5vdCBoYXBwZW4gKi8pO1xyXG4gICAgfVxyXG59O1xuXG5leHBvcnQgeyBjb21waWxlIH07XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgeyBjcmVhdGVBcHAgfSBmcm9tICd2dWUnXHJcblxyXG5pbXBvcnQgQWRtaW5BcHAgZnJvbSAnLi9jb21wb25lbnRzL0FkbWluQXBwLnZ1ZSdcclxuaW1wb3J0IHJvdXRlciBmcm9tICcuLi9yb3V0ZXInXHJcblxyXG5jcmVhdGVBcHAoQWRtaW5BcHApLnVzZShyb3V0ZXIpLm1vdW50KGAjJHt5cmxfd3BfdnVlX3Bsb3RseV9jaGFydHNfb2JqLnByZWZpeH1fX2FkbWluYClcclxuLy8gY3JlYXRlQXBwKEFkbWluQXBwKS5tb3VudChgIyR7eXJsX3dwX3Z1ZV9wbG90bHlfY2hhcnRzX29iai5wcmVmaXh9X19hZG1pbmApIl0sInNvdXJjZVJvb3QiOiIifQ==